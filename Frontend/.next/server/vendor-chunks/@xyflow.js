"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@xyflow";
exports.ids = ["vendor-chunks/@xyflow"];
exports.modules = {

/***/ "(ssr)/./node_modules/@xyflow/react/dist/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Background: () => (/* binding */ Background),\n/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant),\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionMode),\n/* harmony export */   ControlButton: () => (/* binding */ ControlButton),\n/* harmony export */   Controls: () => (/* binding */ Controls),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText),\n/* harmony export */   Handle: () => (/* binding */ Handle),\n/* harmony export */   MarkerType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.MarkerType),\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap),\n/* harmony export */   NodeResizeControl: () => (/* binding */ NodeResizeControl),\n/* harmony export */   NodeResizer: () => (/* binding */ NodeResizer),\n/* harmony export */   NodeToolbar: () => (/* binding */ NodeToolbar),\n/* harmony export */   PanOnScrollMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position),\n/* harmony export */   ReactFlow: () => (/* binding */ index),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   ResizeControlVariant: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   ViewportPortal: () => (/* binding */ ViewportPortal),\n/* harmony export */   addEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   getBezierEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierPath),\n/* harmony export */   getConnectedEdges: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getConnectedEdges),\n/* harmony export */   getEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getEdgeCenter),\n/* harmony export */   getIncomers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getIncomers),\n/* harmony export */   getNodesBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodesBounds),\n/* harmony export */   getOutgoers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getOutgoers),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getViewportForBounds),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   reconnectEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.reconnectEdge),\n/* harmony export */   useConnection: () => (/* binding */ useConnection),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useHandleConnections: () => (/* binding */ useHandleConnections),\n/* harmony export */   useInternalNode: () => (/* binding */ useInternalNode),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeConnections: () => (/* binding */ useNodeConnections),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesData: () => (/* binding */ useNodesData),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/classcat/index.js\");\n/* harmony import */ var _xyflow_system__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @xyflow/system */ \"(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ ConnectionLineType,ConnectionMode,MarkerType,PanOnScrollMode,Position,ResizeControlVariant,SelectionMode,addEdge,getBezierEdgeCenter,getBezierPath,getConnectedEdges,getEdgeCenter,getIncomers,getNodesBounds,getOutgoers,getSmoothStepPath,getStraightPath,getViewportForBounds,reconnectEdge,Background,BackgroundVariant,BaseEdge,BezierEdge,ControlButton,Controls,EdgeLabelRenderer,EdgeText,Handle,MiniMap,NodeResizeControl,NodeResizer,NodeToolbar,Panel,ReactFlow,ReactFlowProvider,SimpleBezierEdge,SmoothStepEdge,StepEdge,StraightEdge,ViewportPortal,applyEdgeChanges,applyNodeChanges,getSimpleBezierPath,isEdge,isNode,useConnection,useEdges,useEdgesState,useHandleConnections,useInternalNode,useKeyPress,useNodeConnections,useNodeId,useNodes,useNodesData,useNodesInitialized,useNodesState,useOnSelectionChange,useOnViewportChange,useReactFlow,useStore,useStoreApi,useUpdateNodeInternals,useViewport auto */ \n\n\n\n\n\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\nconst zustandErrorMessage = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error001']();\n/**\n * Hook for accessing the internal store. Should only be used in rare cases.\n *\n * @public\n * @param selector\n * @param equalityFn\n * @returns The selected state slice\n *\n * @example\n * const nodes = useStore((state: ReactFlowState<MyNodeType>) => state.nodes);\n *\n */ function useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\nfunction useStoreApi() {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useStoreApi.useMemo\": ()=>({\n                getState: store.getState,\n                setState: store.setState,\n                subscribe: store.subscribe\n            })\n    }[\"useStoreApi.useMemo\"], [\n        store\n    ]);\n}\nconst style = {\n    display: 'none'\n};\nconst ariaLiveStyle = {\n    position: 'absolute',\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: 'hidden',\n    clip: 'rect(0px, 0px, 0px, 0px)',\n    clipPath: 'inset(100%)'\n};\nconst ARIA_NODE_DESC_KEY = 'react-flow__node-desc';\nconst ARIA_EDGE_DESC_KEY = 'react-flow__edge-desc';\nconst ARIA_LIVE_MESSAGE = 'react-flow__aria-live';\nconst selector$o = (s)=>s.ariaLiveMessage;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(selector$o);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        id: `${ARIA_LIVE_MESSAGE}-${rfId}`,\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": \"true\",\n        style: ariaLiveStyle,\n        children: ariaLiveMessage\n    });\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n                id: `${ARIA_NODE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: [\n                    \"Press enter or space to select a node.\",\n                    !disableKeyboardA11y && 'You can then use the arrow keys to move the node around.',\n                    \" Press delete to remove it and escape to cancel.\",\n                    ' '\n                ]\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_EDGE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: \"Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.\"\n            }),\n            !disableKeyboardA11y && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AriaLiveMessage, {\n                rfId: rfId\n            })\n        ]\n    });\n}\nconst selector$n = (s)=>s.userSelectionActive ? 'none' : 'all';\nconst Panel = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(({ position = 'top-left', children, className, style, ...rest }, ref)=>{\n    const pointerEvents = useStore(selector$n);\n    const positionClasses = `${position}`.split('-');\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__panel',\n            className,\n            ...positionClasses\n        ]),\n        style: {\n            ...style,\n            pointerEvents\n        },\n        ref: ref,\n        ...rest,\n        children: children\n    });\n});\nfunction Attribution({ proOptions, position = 'bottom-right' }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        className: \"react-flow__attribution\",\n        \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"https://reactflow.dev\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\",\n            \"aria-label\": \"React Flow attribution\",\n            children: \"React Flow\"\n        })\n    });\n}\nconst selector$m = (s)=>{\n    const selectedNodes = [];\n    const selectedEdges = [];\n    for (const [, node] of s.nodeLookup){\n        if (node.selected) {\n            selectedNodes.push(node.internals.userNode);\n        }\n    }\n    for (const [, edge] of s.edgeLookup){\n        if (edge.selected) {\n            selectedEdges.push(edge);\n        }\n    }\n    return {\n        selectedNodes,\n        selectedEdges\n    };\n};\nconst selectId = (obj)=>obj.id;\nfunction areEqual(a, b) {\n    return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));\n}\nfunction SelectionListenerInner({ onSelectionChange }) {\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$m, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"SelectionListenerInner.useEffect\": ()=>{\n            const params = {\n                nodes: selectedNodes,\n                edges: selectedEdges\n            };\n            onSelectionChange?.(params);\n            store.getState().onSelectionChangeHandlers.forEach({\n                \"SelectionListenerInner.useEffect\": (fn)=>fn(params)\n            }[\"SelectionListenerInner.useEffect\"]);\n        }\n    }[\"SelectionListenerInner.useEffect\"], [\n        selectedNodes,\n        selectedEdges,\n        onSelectionChange\n    ]);\n    return null;\n}\nconst changeSelector = (s)=>!!s.onSelectionChangeHandlers;\nfunction SelectionListener({ onSelectionChange }) {\n    const storeHasSelectionChangeHandlers = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChangeHandlers) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListenerInner, {\n            onSelectionChange: onSelectionChange\n        });\n    }\n    return null;\n}\nconst defaultNodeOrigin = [\n    0,\n    0\n];\nconst defaultViewport = {\n    x: 0,\n    y: 0,\n    zoom: 1\n};\n/*\n * This component helps us to update the store with the values coming from the user.\n * We distinguish between values we can update directly with `useDirectStoreUpdater` (like `snapGrid`)\n * and values that have a dedicated setter function in the store (like `setNodes`).\n */ // these fields exist in the global store and we need to keep them up to date\nconst reactFlowFieldsToTrack = [\n    'nodes',\n    'edges',\n    'defaultNodes',\n    'defaultEdges',\n    'onConnect',\n    'onConnectStart',\n    'onConnectEnd',\n    'onClickConnectStart',\n    'onClickConnectEnd',\n    'nodesDraggable',\n    'nodesConnectable',\n    'nodesFocusable',\n    'edgesFocusable',\n    'edgesReconnectable',\n    'elevateNodesOnSelect',\n    'elevateEdgesOnSelect',\n    'minZoom',\n    'maxZoom',\n    'nodeExtent',\n    'onNodesChange',\n    'onEdgesChange',\n    'elementsSelectable',\n    'connectionMode',\n    'snapGrid',\n    'snapToGrid',\n    'translateExtent',\n    'connectOnClick',\n    'defaultEdgeOptions',\n    'fitView',\n    'fitViewOptions',\n    'onNodesDelete',\n    'onEdgesDelete',\n    'onDelete',\n    'onNodeDrag',\n    'onNodeDragStart',\n    'onNodeDragStop',\n    'onSelectionDrag',\n    'onSelectionDragStart',\n    'onSelectionDragStop',\n    'onMoveStart',\n    'onMove',\n    'onMoveEnd',\n    'noPanClassName',\n    'nodeOrigin',\n    'autoPanOnConnect',\n    'autoPanOnNodeDrag',\n    'onError',\n    'connectionRadius',\n    'isValidConnection',\n    'selectNodesOnDrag',\n    'nodeDragThreshold',\n    'onBeforeDelete',\n    'debug',\n    'autoPanSpeed',\n    'paneClickDistance'\n];\n// rfId doesn't exist in ReactFlowProps, but it's one of the fields we want to update\nconst fieldsToTrack = [\n    ...reactFlowFieldsToTrack,\n    'rfId'\n];\nconst selector$l = (s)=>({\n        setNodes: s.setNodes,\n        setEdges: s.setEdges,\n        setMinZoom: s.setMinZoom,\n        setMaxZoom: s.setMaxZoom,\n        setTranslateExtent: s.setTranslateExtent,\n        setNodeExtent: s.setNodeExtent,\n        reset: s.reset,\n        setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,\n        setPaneClickDistance: s.setPaneClickDistance\n    });\nconst initPrevValues = {\n    // these are values that are also passed directly to other components\n    // than the StoreUpdater. We can reduce the number of setStore calls\n    // by setting the same values here as prev fields.\n    translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.infiniteExtent,\n    nodeOrigin: defaultNodeOrigin,\n    minZoom: 0.5,\n    maxZoom: 2,\n    elementsSelectable: true,\n    noPanClassName: 'nopan',\n    rfId: '1',\n    paneClickDistance: 0\n};\nfunction StoreUpdater(props) {\n    const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges, setPaneClickDistance } = useStore(selector$l, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges);\n            return ({\n                \"StoreUpdater.useEffect\": ()=>{\n                    // when we reset the store we also need to reset the previous fields\n                    previousFields.current = initPrevValues;\n                    reset();\n                }\n            })[\"StoreUpdater.useEffect\"];\n        }\n    }[\"StoreUpdater.useEffect\"], []);\n    const previousFields = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(initPrevValues);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            for (const fieldName of fieldsToTrack){\n                const fieldValue = props[fieldName];\n                const previousFieldValue = previousFields.current[fieldName];\n                if (fieldValue === previousFieldValue) continue;\n                if (typeof props[fieldName] === 'undefined') continue;\n                // Custom handling with dedicated setters for some fields\n                if (fieldName === 'nodes') setNodes(fieldValue);\n                else if (fieldName === 'edges') setEdges(fieldValue);\n                else if (fieldName === 'minZoom') setMinZoom(fieldValue);\n                else if (fieldName === 'maxZoom') setMaxZoom(fieldValue);\n                else if (fieldName === 'translateExtent') setTranslateExtent(fieldValue);\n                else if (fieldName === 'nodeExtent') setNodeExtent(fieldValue);\n                else if (fieldName === 'paneClickDistance') setPaneClickDistance(fieldValue);\n                else if (fieldName === 'fitView') store.setState({\n                    fitViewOnInit: fieldValue\n                });\n                else if (fieldName === 'fitViewOptions') store.setState({\n                    fitViewOnInitOptions: fieldValue\n                });\n                else store.setState({\n                    [fieldName]: fieldValue\n                });\n            }\n            previousFields.current = props;\n        }\n    }[\"StoreUpdater.useEffect\"], // Only re-run the effect if one of the fields we track changes\n    fieldsToTrack.map({\n        \"StoreUpdater.useEffect\": (fieldName)=>props[fieldName]\n    }[\"StoreUpdater.useEffect\"]));\n    return null;\n}\nfunction getMediaQuery() {\n    if (true) {\n        return null;\n    }\n    return window.matchMedia('(prefers-color-scheme: dark)');\n}\n/**\n * Hook for receiving the current color mode class 'dark' or 'light'.\n *\n * @internal\n * @param colorMode - The color mode to use ('dark', 'light' or 'system')\n */ function useColorModeClass(colorMode) {\n    const [colorModeClass, setColorModeClass] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(colorMode === 'system' ? null : colorMode);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useColorModeClass.useEffect\": ()=>{\n            if (colorMode !== 'system') {\n                setColorModeClass(colorMode);\n                return;\n            }\n            const mediaQuery = getMediaQuery();\n            const updateColorModeClass = {\n                \"useColorModeClass.useEffect.updateColorModeClass\": ()=>setColorModeClass(mediaQuery?.matches ? 'dark' : 'light')\n            }[\"useColorModeClass.useEffect.updateColorModeClass\"];\n            updateColorModeClass();\n            mediaQuery?.addEventListener('change', updateColorModeClass);\n            return ({\n                \"useColorModeClass.useEffect\": ()=>{\n                    mediaQuery?.removeEventListener('change', updateColorModeClass);\n                }\n            })[\"useColorModeClass.useEffect\"];\n        }\n    }[\"useColorModeClass.useEffect\"], [\n        colorMode\n    ]);\n    return colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? 'dark' : 'light';\n}\nconst defaultDoc = typeof document !== 'undefined' ? document : null;\n/**\n * Hook for handling key events.\n *\n * @public\n * @param param.keyCode - The key code (string or array of strings) to use\n * @param param.options - Options\n * @returns boolean\n */ function useKeyPress(// the keycode can be a string 'a' or an array of strings ['a', 'a+d']\n// a string means a single key 'a' or a combination when '+' is used 'a+d'\n// an array means different possibilites. Explainer: ['a', 'd+s'] here the\n// user can use the single key 'a' or the combination 'd' + 's'\nkeyCode = null, options = {\n    target: defaultDoc,\n    actInsideInputWithModifier: true\n}) {\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(new Set([]));\n    // keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n    // keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n    // used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n    // we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n    // and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n    // we can't find it in the list of keysToWatch.\n    const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useKeyPress.useMemo\": ()=>{\n            if (keyCode !== null) {\n                const keyCodeArr = Array.isArray(keyCode) ? keyCode : [\n                    keyCode\n                ];\n                const keys = keyCodeArr.filter({\n                    \"useKeyPress.useMemo.keys\": (kc)=>typeof kc === 'string'\n                }[\"useKeyPress.useMemo.keys\"])// we first replace all '+' with '\\n'  which we will use to split the keys on\n                // then we replace '\\n\\n' with '\\n+', this way we can also support the combination 'key++'\n                // in the end we simply split on '\\n' to get the key array\n                .map({\n                    \"useKeyPress.useMemo.keys\": (kc)=>kc.replace('+', '\\n').replace('\\n\\n', '\\n+').split('\\n')\n                }[\"useKeyPress.useMemo.keys\"]);\n                const keysFlat = keys.reduce({\n                    \"useKeyPress.useMemo.keysFlat\": (res, item)=>res.concat(...item)\n                }[\"useKeyPress.useMemo.keysFlat\"], []);\n                return [\n                    keys,\n                    keysFlat\n                ];\n            }\n            return [\n                [],\n                []\n            ];\n        }\n    }[\"useKeyPress.useMemo\"], [\n        keyCode\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useKeyPress.useEffect\": ()=>{\n            const target = options?.target || defaultDoc;\n            if (keyCode !== null) {\n                const downHandler = {\n                    \"useKeyPress.useEffect.downHandler\": (event)=>{\n                        modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey;\n                        const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isInputDOMNode)(event);\n                        if (preventAction) {\n                            return false;\n                        }\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        pressedKeys.current.add(event[keyOrCode]);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                            event.preventDefault();\n                            setKeyPressed(true);\n                        }\n                    }\n                }[\"useKeyPress.useEffect.downHandler\"];\n                const upHandler = {\n                    \"useKeyPress.useEffect.upHandler\": (event)=>{\n                        const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isInputDOMNode)(event);\n                        if (preventAction) {\n                            return false;\n                        }\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                            setKeyPressed(false);\n                            pressedKeys.current.clear();\n                        } else {\n                            pressedKeys.current.delete(event[keyOrCode]);\n                        }\n                        // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                        if (event.key === 'Meta') {\n                            pressedKeys.current.clear();\n                        }\n                        modifierPressed.current = false;\n                    }\n                }[\"useKeyPress.useEffect.upHandler\"];\n                const resetHandler = {\n                    \"useKeyPress.useEffect.resetHandler\": ()=>{\n                        pressedKeys.current.clear();\n                        setKeyPressed(false);\n                    }\n                }[\"useKeyPress.useEffect.resetHandler\"];\n                target?.addEventListener('keydown', downHandler);\n                target?.addEventListener('keyup', upHandler);\n                window.addEventListener('blur', resetHandler);\n                window.addEventListener('contextmenu', resetHandler);\n                return ({\n                    \"useKeyPress.useEffect\": ()=>{\n                        target?.removeEventListener('keydown', downHandler);\n                        target?.removeEventListener('keyup', upHandler);\n                        window.removeEventListener('blur', resetHandler);\n                        window.removeEventListener('contextmenu', resetHandler);\n                    }\n                })[\"useKeyPress.useEffect\"];\n            }\n        }\n    }[\"useKeyPress.useEffect\"], [\n        keyCode,\n        setKeyPressed\n    ]);\n    return keyPressed;\n}\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return keyCodes// we only want to compare same sizes of keyCode definitions\n    // and pressed keys. When the user specified 'Meta' as a key somewhere\n    // this would also be truthy without this filter when user presses 'Meta' + 'r'\n    .filter((keys)=>isUp || keys.length === pressedKeys.size)// since we want to support multiple possibilities only one of the\n    // combinations need to be part of the pressed keys\n    .some((keys)=>keys.every((k)=>pressedKeys.has(k)));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? 'code' : 'key';\n}\n/**\n * Hook for getting viewport helper functions.\n *\n * @internal\n * @returns viewport helper functions\n */ const useViewportHelper = ()=>{\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useViewportHelper.useMemo\": ()=>{\n            return {\n                zoomIn: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomOut: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1 / 1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomTo: ({\n                    \"useViewportHelper.useMemo\": (zoomLevel, options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleTo(zoomLevel, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getZoom: ({\n                    \"useViewportHelper.useMemo\": ()=>store.getState().transform[2]\n                })[\"useViewportHelper.useMemo\"],\n                setViewport: ({\n                    \"useViewportHelper.useMemo\": async (viewport, options)=>{\n                        const { transform: [tX, tY, tZoom], panZoom } = store.getState();\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport({\n                            x: viewport.x ?? tX,\n                            y: viewport.y ?? tY,\n                            zoom: viewport.zoom ?? tZoom\n                        }, {\n                            duration: options?.duration\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getViewport: ({\n                    \"useViewportHelper.useMemo\": ()=>{\n                        const [x, y, zoom] = store.getState().transform;\n                        return {\n                            x,\n                            y,\n                            zoom\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                fitView: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { nodeLookup, minZoom, maxZoom, panZoom, domNode } = store.getState();\n                        if (!panZoom || !domNode) {\n                            return Promise.resolve(false);\n                        }\n                        const fitViewNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getFitViewNodes)(nodeLookup, options);\n                        const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getDimensions)(domNode);\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.fitView)({\n                            nodes: fitViewNodes,\n                            width,\n                            height,\n                            minZoom,\n                            maxZoom,\n                            panZoom\n                        }, options);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                setCenter: ({\n                    \"useViewportHelper.useMemo\": async (x, y, options)=>{\n                        const { width, height, maxZoom, panZoom } = store.getState();\n                        const nextZoom = typeof options?.zoom !== 'undefined' ? options.zoom : maxZoom;\n                        const centerX = width / 2 - x * nextZoom;\n                        const centerY = height / 2 - y * nextZoom;\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport({\n                            x: centerX,\n                            y: centerY,\n                            zoom: nextZoom\n                        }, {\n                            duration: options?.duration\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                fitBounds: ({\n                    \"useViewportHelper.useMemo\": async (bounds, options)=>{\n                        const { width, height, minZoom, maxZoom, panZoom } = store.getState();\n                        const viewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport(viewport, {\n                            duration: options?.duration\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                screenToFlowPosition: ({\n                    \"useViewportHelper.useMemo\": (clientPosition, options = {\n                        snapToGrid: true\n                    })=>{\n                        const { transform, snapGrid, domNode } = store.getState();\n                        if (!domNode) {\n                            return clientPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const correctedPosition = {\n                            x: clientPosition.x - domX,\n                            y: clientPosition.y - domY\n                        };\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.pointToRendererPoint)(correctedPosition, transform, options.snapToGrid, snapGrid);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                flowToScreenPosition: ({\n                    \"useViewportHelper.useMemo\": (flowPosition)=>{\n                        const { transform, domNode } = store.getState();\n                        if (!domNode) {\n                            return flowPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const rendererPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.rendererPointToPoint)(flowPosition, transform);\n                        return {\n                            x: rendererPosition.x + domX,\n                            y: rendererPosition.y + domY\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"]\n            };\n        }\n    }[\"useViewportHelper.useMemo\"], []);\n};\n// This function applies changes to nodes or edges that are triggered by React Flow internally.\n// When you drag a node for example, React Flow will send a position change update.\n// This function then applies the changes and returns the updated elements.\nfunction applyChanges(changes, elements) {\n    const updatedElements = [];\n    // By storing a map of changes for each element, we can a quick lookup as we\n    // iterate over the elements array!\n    const changesMap = new Map();\n    const addItemChanges = [];\n    for (const change of changes){\n        if (change.type === 'add') {\n            addItemChanges.push(change);\n            continue;\n        } else if (change.type === 'remove' || change.type === 'replace') {\n            // For a 'remove' change we can safely ignore any other changes queued for\n            // the same element, it's going to be removed anyway!\n            changesMap.set(change.id, [\n                change\n            ]);\n        } else {\n            const elementChanges = changesMap.get(change.id);\n            if (elementChanges) {\n                // If we have some changes queued already, we can do a mutable update of\n                // that array and save ourselves some copying.\n                elementChanges.push(change);\n            } else {\n                changesMap.set(change.id, [\n                    change\n                ]);\n            }\n        }\n    }\n    for (const element of elements){\n        const changes = changesMap.get(element.id);\n        // When there are no changes for an element we can just push it unmodified,\n        // no need to copy it.\n        if (!changes) {\n            updatedElements.push(element);\n            continue;\n        }\n        // If we have a 'remove' change queued, it'll be the only change in the array\n        if (changes[0].type === 'remove') {\n            continue;\n        }\n        if (changes[0].type === 'replace') {\n            updatedElements.push({\n                ...changes[0].item\n            });\n            continue;\n        }\n        // For other types of changes, we want to start with a shallow copy of the\n        // object so React knows this element has changed. Sequential changes will\n        /// each _mutate_ this object, so there's only ever one copy.\n        const updatedElement = {\n            ...element\n        };\n        for (const change of changes){\n            applyChange(change, updatedElement);\n        }\n        updatedElements.push(updatedElement);\n    }\n    // we need to wait for all changes to be applied before adding new items\n    // to be able to add them at the correct index\n    if (addItemChanges.length) {\n        addItemChanges.forEach((change)=>{\n            if (change.index !== undefined) {\n                updatedElements.splice(change.index, 0, {\n                    ...change.item\n                });\n            } else {\n                updatedElements.push({\n                    ...change.item\n                });\n            }\n        });\n    }\n    return updatedElements;\n}\n// Applies a single change to an element. This is a *mutable* update.\nfunction applyChange(change, element) {\n    switch(change.type){\n        case 'select':\n            {\n                element.selected = change.selected;\n                break;\n            }\n        case 'position':\n            {\n                if (typeof change.position !== 'undefined') {\n                    element.position = change.position;\n                }\n                if (typeof change.dragging !== 'undefined') {\n                    element.dragging = change.dragging;\n                }\n                break;\n            }\n        case 'dimensions':\n            {\n                if (typeof change.dimensions !== 'undefined') {\n                    element.measured ??= {};\n                    element.measured.width = change.dimensions.width;\n                    element.measured.height = change.dimensions.height;\n                    if (change.setAttributes) {\n                        element.width = change.dimensions.width;\n                        element.height = change.dimensions.height;\n                    }\n                }\n                if (typeof change.resizing === 'boolean') {\n                    element.resizing = change.resizing;\n                }\n                break;\n            }\n    }\n}\n/**\n * Drop in function that applies node changes to an array of nodes.\n * @public\n * @remarks Various events on the <ReactFlow /> component can produce an {@link NodeChange} that describes how to update the edges of your flow in some way.\n If you don't need any custom behaviour, this util can be used to take an array of these changes and apply them to your edges.\n * @param changes - Array of changes to apply\n * @param nodes - Array of nodes to apply the changes to\n * @returns Array of updated nodes\n * @example\n *  const onNodesChange = useCallback(\n      (changes) => {\n        setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));\n      },\n      [setNodes],\n    );\n  \n    return (\n      <ReactFLow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />\n    );\n */ function applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\n/**\n * Drop in function that applies edge changes to an array of edges.\n * @public\n * @remarks Various events on the <ReactFlow /> component can produce an {@link EdgeChange} that describes how to update the edges of your flow in some way.\n If you don't need any custom behaviour, this util can be used to take an array of these changes and apply them to your edges.\n * @param changes - Array of changes to apply\n * @param edges - Array of edge to apply the changes to\n * @returns Array of updated edges\n * @example\n *  const onEdgesChange = useCallback(\n      (changes) => {\n        setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));\n      },\n      [setEdges],\n    );\n  \n    return (\n      <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />\n    );\n */ function applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nfunction createSelectionChange(id, selected) {\n    return {\n        id,\n        type: 'select',\n        selected\n    };\n}\nfunction getSelectionChanges(items, selectedIds = new Set(), mutateItem = false) {\n    const changes = [];\n    for (const [id, item] of items){\n        const willBeSelected = selectedIds.has(id);\n        // we don't want to set all items to selected=false on the first selection\n        if (!(item.selected === undefined && !willBeSelected) && item.selected !== willBeSelected) {\n            if (mutateItem) {\n                // this hack is needed for nodes. When the user dragged a node, it's selected.\n                // When another node gets dragged, we need to deselect the previous one,\n                // in order to have only one selected node at a time - the onNodesChange callback comes too late here :/\n                item.selected = willBeSelected;\n            }\n            changes.push(createSelectionChange(item.id, willBeSelected));\n        }\n    }\n    return changes;\n}\nfunction getElementsDiffChanges({ items = [], lookup }) {\n    const changes = [];\n    const itemsLookup = new Map(items.map((item)=>[\n            item.id,\n            item\n        ]));\n    for (const [index, item] of items.entries()){\n        const lookupItem = lookup.get(item.id);\n        const storeItem = lookupItem?.internals?.userNode ?? lookupItem;\n        if (storeItem !== undefined && storeItem !== item) {\n            changes.push({\n                id: item.id,\n                item: item,\n                type: 'replace'\n            });\n        }\n        if (storeItem === undefined) {\n            changes.push({\n                item: item,\n                type: 'add',\n                index\n            });\n        }\n    }\n    for (const [id] of lookup){\n        const nextNode = itemsLookup.get(id);\n        if (nextNode === undefined) {\n            changes.push({\n                id,\n                type: 'remove'\n            });\n        }\n    }\n    return changes;\n}\nfunction elementToRemoveChange(item) {\n    return {\n        id: item.id,\n        type: 'remove'\n    };\n}\n/**\n * Test whether an object is useable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */ const isNode = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNodeBase)(element);\n/**\n * Test whether an object is useable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */ const isEdge = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isEdgeBase)(element);\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction fixedForwardRef(render) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(render);\n}\n// we need this hook to prevent a warning when using react-flow in SSR\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\n/**\n * This hook returns a queue that can be used to batch updates.\n *\n * @param runQueue - a function that gets called when the queue is flushed\n * @internal\n *\n * @returns a Queue object\n */ function useQueue(runQueue) {\n    // Because we're using a ref above, we need some way to let React know when to\n    // actually process the queue. We increment this number any time we mutate the\n    // queue, creating a new state to trigger the layout effect below.\n    // Using a boolean dirty flag here instead would lead to issues related to\n    // automatic batching. (https://github.com/xyflow/xyflow/issues/4779)\n    const [serial, setSerial] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(BigInt(0));\n    // A reference of all the batched updates to process before the next render. We\n    // want a reference here so multiple synchronous calls to `setNodes` etc can be\n    // batched together.\n    const [queue] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        \"useQueue.useState\": ()=>createQueue({\n                \"useQueue.useState\": ()=>setSerial({\n                        \"useQueue.useState\": (n)=>n + BigInt(1)\n                    }[\"useQueue.useState\"])\n            }[\"useQueue.useState\"])\n    }[\"useQueue.useState\"]);\n    // Layout effects are guaranteed to run before the next render which means we\n    // shouldn't run into any issues with stale state or weird issues that come from\n    // rendering things one frame later than expected (we used to use `setTimeout`).\n    useIsomorphicLayoutEffect({\n        \"useQueue.useIsomorphicLayoutEffect\": ()=>{\n            const queueItems = queue.get();\n            if (queueItems.length) {\n                runQueue(queueItems);\n                queue.reset();\n            }\n        }\n    }[\"useQueue.useIsomorphicLayoutEffect\"], [\n        serial\n    ]);\n    return queue;\n}\nfunction createQueue(cb) {\n    let queue = [];\n    return {\n        get: ()=>queue,\n        reset: ()=>{\n            queue = [];\n        },\n        push: (item)=>{\n            queue.push(item);\n            cb();\n        }\n    };\n}\nconst BatchContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\n * This is a context provider that holds and processes the node and edge update queues\n * that are needed to handle setNodes, addNodes, setEdges and addEdges.\n *\n * @internal\n */ function BatchProvider({ children }) {\n    const store = useStoreApi();\n    const nodeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"BatchProvider.useCallback[nodeQueueHandler]\": (queueItems)=>{\n            const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup } = store.getState();\n            // This is essentially an `Array.reduce` in imperative clothing. Processing\n            // this queue is a relatively hot path so we'd like to avoid the overhead of\n            // array methods where we can.\n            let next = nodes;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            if (hasDefaultNodes) {\n                setNodes(next);\n            } else if (onNodesChange) {\n                onNodesChange(getElementsDiffChanges({\n                    items: next,\n                    lookup: nodeLookup\n                }));\n            }\n        }\n    }[\"BatchProvider.useCallback[nodeQueueHandler]\"], []);\n    const nodeQueue = useQueue(nodeQueueHandler);\n    const edgeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"BatchProvider.useCallback[edgeQueueHandler]\": (queueItems)=>{\n            const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();\n            let next = edges;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            if (hasDefaultEdges) {\n                setEdges(next);\n            } else if (onEdgesChange) {\n                onEdgesChange(getElementsDiffChanges({\n                    items: next,\n                    lookup: edgeLookup\n                }));\n            }\n        }\n    }[\"BatchProvider.useCallback[edgeQueueHandler]\"], []);\n    const edgeQueue = useQueue(edgeQueueHandler);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"BatchProvider.useMemo[value]\": ()=>({\n                nodeQueue,\n                edgeQueue\n            })\n    }[\"BatchProvider.useMemo[value]\"], []);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useBatchContext() {\n    const batchContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(BatchContext);\n    if (!batchContext) {\n        throw new Error('useBatchContext must be used within a BatchProvider');\n    }\n    return batchContext;\n}\nconst selector$k = (s)=>!!s.panZoom;\n/**\n * Hook for accessing the ReactFlow instance.\n *\n * @public\n * @returns ReactFlowInstance\n */ function useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const batchContext = useBatchContext();\n    const viewportInitialized = useStore(selector$k);\n    const generalHelper = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useReactFlow.useMemo[generalHelper]\": ()=>{\n            const getInternalNode = {\n                \"useReactFlow.useMemo[generalHelper].getInternalNode\": (id)=>store.getState().nodeLookup.get(id)\n            }[\"useReactFlow.useMemo[generalHelper].getInternalNode\"];\n            const setNodes = {\n                \"useReactFlow.useMemo[generalHelper].setNodes\": (payload)=>{\n                    batchContext.nodeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setNodes\"];\n            const setEdges = {\n                \"useReactFlow.useMemo[generalHelper].setEdges\": (payload)=>{\n                    batchContext.edgeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setEdges\"];\n            const getNodeRect = {\n                \"useReactFlow.useMemo[generalHelper].getNodeRect\": (node)=>{\n                    const { nodeLookup, nodeOrigin } = store.getState();\n                    const nodeToUse = isNode(node) ? node : nodeLookup.get(node.id);\n                    const position = nodeToUse.parentId ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.evaluateAbsolutePosition)(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position;\n                    const nodeWithPosition = {\n                        ...nodeToUse,\n                        position,\n                        width: nodeToUse.measured?.width ?? nodeToUse.width,\n                        height: nodeToUse.measured?.height ?? nodeToUse.height\n                    };\n                    return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeToRect)(nodeWithPosition);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].getNodeRect\"];\n            const updateNode = {\n                \"useReactFlow.useMemo[generalHelper].updateNode\": (id, nodeUpdate, options = {\n                    replace: false\n                })=>{\n                    setNodes({\n                        \"useReactFlow.useMemo[generalHelper].updateNode\": (prevNodes)=>prevNodes.map({\n                                \"useReactFlow.useMemo[generalHelper].updateNode\": (node)=>{\n                                    if (node.id === id) {\n                                        const nextNode = typeof nodeUpdate === 'function' ? nodeUpdate(node) : nodeUpdate;\n                                        return options.replace && isNode(nextNode) ? nextNode : {\n                                            ...node,\n                                            ...nextNode\n                                        };\n                                    }\n                                    return node;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateNode\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateNode\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateNode\"];\n            const updateEdge = {\n                \"useReactFlow.useMemo[generalHelper].updateEdge\": (id, edgeUpdate, options = {\n                    replace: false\n                })=>{\n                    setEdges({\n                        \"useReactFlow.useMemo[generalHelper].updateEdge\": (prevEdges)=>prevEdges.map({\n                                \"useReactFlow.useMemo[generalHelper].updateEdge\": (edge)=>{\n                                    if (edge.id === id) {\n                                        const nextEdge = typeof edgeUpdate === 'function' ? edgeUpdate(edge) : edgeUpdate;\n                                        return options.replace && isEdge(nextEdge) ? nextEdge : {\n                                            ...edge,\n                                            ...nextEdge\n                                        };\n                                    }\n                                    return edge;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateEdge\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"];\n            return {\n                getNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>store.getState().nodes.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                    ...n\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNode: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>getInternalNode(id)?.internals.userNode\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getInternalNode,\n                getEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { edges = [] } = store.getState();\n                        return edges.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                    ...e\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getEdge: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>store.getState().edgeLookup.get(id)\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                setNodes,\n                setEdges,\n                addNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newNodes = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.nodeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (nodes)=>[\n                                    ...nodes,\n                                    ...newNodes\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                addEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newEdges = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.edgeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (edges)=>[\n                                    ...edges,\n                                    ...newEdges\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                toObject: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { nodes = [], edges = [], transform } = store.getState();\n                        const [x, y, zoom] = transform;\n                        return {\n                            nodes: nodes.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                        ...n\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            edges: edges.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                        ...e\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            viewport: {\n                                x,\n                                y,\n                                zoom\n                            }\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                deleteElements: ({\n                    \"useReactFlow.useMemo[generalHelper]\": async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] })=>{\n                        const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState();\n                        const { nodes: matchingNodes, edges: matchingEdges } = await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getElementsToRemove)({\n                            nodesToRemove,\n                            edgesToRemove,\n                            nodes,\n                            edges,\n                            onBeforeDelete\n                        });\n                        const hasMatchingEdges = matchingEdges.length > 0;\n                        const hasMatchingNodes = matchingNodes.length > 0;\n                        if (hasMatchingEdges) {\n                            const edgeChanges = matchingEdges.map(elementToRemoveChange);\n                            onEdgesDelete?.(matchingEdges);\n                            triggerEdgeChanges(edgeChanges);\n                        }\n                        if (hasMatchingNodes) {\n                            const nodeChanges = matchingNodes.map(elementToRemoveChange);\n                            onNodesDelete?.(matchingNodes);\n                            triggerNodeChanges(nodeChanges);\n                        }\n                        if (hasMatchingNodes || hasMatchingEdges) {\n                            onDelete?.({\n                                nodes: matchingNodes,\n                                edges: matchingEdges\n                            });\n                        }\n                        return {\n                            deletedNodes: matchingNodes,\n                            deletedEdges: matchingEdges\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getIntersectingNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, partially = true, nodes)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        const hasNodesOption = nodes !== undefined;\n                        if (!nodeRect) {\n                            return [];\n                        }\n                        return (nodes || store.getState().nodes).filter({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>{\n                                const internalNode = store.getState().nodeLookup.get(n.id);\n                                if (internalNode && !isRect && (n.id === nodeOrRect.id || !internalNode.internals.positionAbsolute)) {\n                                    return false;\n                                }\n                                const currNodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeToRect)(hasNodesOption ? n : internalNode);\n                                const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getOverlappingArea)(currNodeRect, nodeRect);\n                                const partiallyVisible = partially && overlappingArea > 0;\n                                return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                isNodeIntersecting: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, area, partially = true)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        if (!nodeRect) {\n                            return false;\n                        }\n                        const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getOverlappingArea)(nodeRect, area);\n                        const partiallyVisible = partially && overlappingArea > 0;\n                        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateNode,\n                updateNodeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateNode(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (node)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(node) : dataUpdate;\n                                return options.replace ? {\n                                    ...node,\n                                    data: nextData\n                                } : {\n                                    ...node,\n                                    data: {\n                                        ...node.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateEdge,\n                updateEdgeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateEdge(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (edge)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(edge) : dataUpdate;\n                                return options.replace ? {\n                                    ...edge,\n                                    data: nextData\n                                } : {\n                                    ...edge,\n                                    data: {\n                                        ...edge.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNodesBounds: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodes)=>{\n                        const { nodeLookup, nodeOrigin } = store.getState();\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodesBounds)(nodes, {\n                            nodeLookup,\n                            nodeOrigin\n                        });\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getHandleConnections: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ({ type, id, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id ? `-${id}` : ''}`)?.values() ?? [])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNodeConnections: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ({ type, handleId, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}${type ? handleId ? `-${type}-${handleId}` : `-${type}` : ''}`)?.values() ?? [])\n                })[\"useReactFlow.useMemo[generalHelper]\"]\n            };\n        }\n    }[\"useReactFlow.useMemo[generalHelper]\"], []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useReactFlow.useMemo\": ()=>{\n            return {\n                ...generalHelper,\n                ...viewportHelper,\n                viewportInitialized\n            };\n        }\n    }[\"useReactFlow.useMemo\"], [\n        viewportInitialized\n    ]);\n}\nconst selected = (item)=>item.selected;\nconst deleteKeyOptions = {\n    actInsideInputWithModifier: false\n};\nconst win$1 =  false ? 0 : undefined;\n/**\n * Hook for handling global key events.\n *\n * @internal\n */ function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, deleteKeyOptions);\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, {\n        target: win$1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            if (deleteKeyPressed) {\n                const { edges, nodes } = store.getState();\n                deleteElements({\n                    nodes: nodes.filter(selected),\n                    edges: edges.filter(selected)\n                });\n                store.setState({\n                    nodesSelectionActive: false\n                });\n            }\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        deleteKeyPressed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            store.setState({\n                multiSelectionActive: multiSelectionKeyPressed\n            });\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        multiSelectionKeyPressed\n    ]);\n}\n/**\n * Hook for handling resize events.\n *\n * @internal\n */ function useResizeHandler(domNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useResizeHandler.useEffect\": ()=>{\n            const updateDimensions = {\n                \"useResizeHandler.useEffect.updateDimensions\": ()=>{\n                    if (!domNode.current) {\n                        return false;\n                    }\n                    const size = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getDimensions)(domNode.current);\n                    if (size.height === 0 || size.width === 0) {\n                        store.getState().onError?.('004', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error004']());\n                    }\n                    store.setState({\n                        width: size.width || 500,\n                        height: size.height || 500\n                    });\n                }\n            }[\"useResizeHandler.useEffect.updateDimensions\"];\n            if (domNode.current) {\n                updateDimensions();\n                window.addEventListener('resize', updateDimensions);\n                const resizeObserver = new ResizeObserver({\n                    \"useResizeHandler.useEffect\": ()=>updateDimensions()\n                }[\"useResizeHandler.useEffect\"]);\n                resizeObserver.observe(domNode.current);\n                return ({\n                    \"useResizeHandler.useEffect\": ()=>{\n                        window.removeEventListener('resize', updateDimensions);\n                        if (resizeObserver && domNode.current) {\n                            resizeObserver.unobserve(domNode.current);\n                        }\n                    }\n                })[\"useResizeHandler.useEffect\"];\n            }\n        }\n    }[\"useResizeHandler.useEffect\"], []);\n}\nconst containerStyle = {\n    position: 'absolute',\n    width: '100%',\n    height: '100%',\n    top: 0,\n    left: 0\n};\nconst selector$j = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        lib: s.lib\n    });\nfunction ZoomPane({ onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance }) {\n    const store = useStoreApi();\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const { userSelectionActive, lib } = useStore(selector$j, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const panZoom = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    useResizeHandler(zoomPane);\n    const onTransformChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"ZoomPane.useCallback[onTransformChange]\": (transform)=>{\n            onViewportChange?.({\n                x: transform[0],\n                y: transform[1],\n                zoom: transform[2]\n            });\n            if (!isControlledViewport) {\n                store.setState({\n                    transform\n                });\n            }\n        }\n    }[\"ZoomPane.useCallback[onTransformChange]\"], [\n        onViewportChange,\n        isControlledViewport\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            if (zoomPane.current) {\n                panZoom.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYPanZoom)({\n                    domNode: zoomPane.current,\n                    minZoom,\n                    maxZoom,\n                    translateExtent,\n                    viewport: defaultViewport,\n                    paneClickDistance,\n                    onDraggingChange: {\n                        \"ZoomPane.useEffect\": (paneDragging)=>store.setState({\n                                paneDragging\n                            })\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomStart: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeStart, onMoveStart } = store.getState();\n                            onMoveStart?.(event, vp);\n                            onViewportChangeStart?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoom: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChange, onMove } = store.getState();\n                            onMove?.(event, vp);\n                            onViewportChange?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomEnd: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeEnd, onMoveEnd } = store.getState();\n                            onMoveEnd?.(event, vp);\n                            onViewportChangeEnd?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"]\n                });\n                const { x, y, zoom } = panZoom.current.getViewport();\n                store.setState({\n                    panZoom: panZoom.current,\n                    transform: [\n                        x,\n                        y,\n                        zoom\n                    ],\n                    domNode: zoomPane.current.closest('.react-flow')\n                });\n                return ({\n                    \"ZoomPane.useEffect\": ()=>{\n                        panZoom.current?.destroy();\n                    }\n                })[\"ZoomPane.useEffect\"];\n            }\n        }\n    }[\"ZoomPane.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            panZoom.current?.update({\n                onPaneContextMenu,\n                zoomOnScroll,\n                zoomOnPinch,\n                panOnScroll,\n                panOnScrollSpeed,\n                panOnScrollMode,\n                zoomOnDoubleClick,\n                panOnDrag,\n                zoomActivationKeyPressed,\n                preventScrolling,\n                noPanClassName,\n                userSelectionActive,\n                noWheelClassName,\n                lib,\n                onTransformChange\n            });\n        }\n    }[\"ZoomPane.useEffect\"], [\n        onPaneContextMenu,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        panOnScrollSpeed,\n        panOnScrollMode,\n        zoomOnDoubleClick,\n        panOnDrag,\n        zoomActivationKeyPressed,\n        preventScrolling,\n        noPanClassName,\n        userSelectionActive,\n        noWheelClassName,\n        lib,\n        onTransformChange\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__renderer\",\n        ref: zoomPane,\n        style: containerStyle,\n        children: children\n    });\n}\nconst selector$i = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        userSelectionRect: s.userSelectionRect\n    });\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$i, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__selection react-flow__container\",\n        style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`\n        }\n    });\n}\nconst wrapHandler = (handler, containerRef)=>{\n    return (event)=>{\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$h = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        elementsSelectable: s.elementsSelectable,\n        dragging: s.paneDragging\n    });\nfunction Pane({ isSelecting, selectionKeyPressed, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.SelectionMode.Full, panOnDrag, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children }) {\n    const store = useStoreApi();\n    const { userSelectionActive, elementsSelectable, dragging } = useStore(selector$h, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    const selectedNodeIds = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(new Set());\n    const selectedEdgeIds = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(new Set());\n    // Used to prevent click events when the user lets go of the selectionKey during a selection\n    const selectionInProgress = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    const selectionStarted = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    const onClick = (event)=>{\n        // We prevent click events when the user let go of the selectionKey during a selection\n        if (selectionInProgress.current) {\n            selectionInProgress.current = false;\n            return;\n        }\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({\n            nodesSelectionActive: false\n        });\n    };\n    const onContextMenu = (event)=>{\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event)=>onPaneScroll(event) : undefined;\n    const onPointerDown = (event)=>{\n        const { resetSelectedElements, domNode } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container.current || !containerBounds.current) {\n            return;\n        }\n        event.target?.setPointerCapture?.(event.pointerId);\n        selectionStarted.current = true;\n        selectionInProgress.current = false;\n        const { x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        resetSelectedElements();\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y\n            }\n        });\n        onSelectionStart?.(event);\n    };\n    const onPointerMove = (event)=>{\n        const { userSelectionRect, transform, nodeLookup, edgeLookup, connectionLookup, triggerNodeChanges, triggerEdgeChanges, defaultEdgeOptions } = store.getState();\n        if (!containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        selectionInProgress.current = true;\n        const { x: mouseX, y: mouseY } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        const { startX, startY } = userSelectionRect;\n        const nextUserSelectRect = {\n            startX,\n            startY,\n            x: mouseX < startX ? mouseX : startX,\n            y: mouseY < startY ? mouseY : startY,\n            width: Math.abs(mouseX - startX),\n            height: Math.abs(mouseY - startY)\n        };\n        const prevSelectedNodeIds = selectedNodeIds.current;\n        const prevSelectedEdgeIds = selectedEdgeIds.current;\n        selectedNodeIds.current = new Set((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodesInside)(nodeLookup, nextUserSelectRect, transform, selectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.SelectionMode.Partial, true).map((node)=>node.id));\n        selectedEdgeIds.current = new Set();\n        const edgesSelectable = defaultEdgeOptions?.selectable ?? true;\n        // We look for all edges connected to the selected nodes\n        for (const nodeId of selectedNodeIds.current){\n            const connections = connectionLookup.get(nodeId);\n            if (!connections) continue;\n            for (const { edgeId } of connections.values()){\n                const edge = edgeLookup.get(edgeId);\n                if (edge && (edge.selectable ?? edgesSelectable)) {\n                    selectedEdgeIds.current.add(edgeId);\n                }\n            }\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.areSetsEqual)(prevSelectedNodeIds, selectedNodeIds.current)) {\n            const changes = getSelectionChanges(nodeLookup, selectedNodeIds.current, true);\n            triggerNodeChanges(changes);\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.areSetsEqual)(prevSelectedEdgeIds, selectedEdgeIds.current)) {\n            const changes = getSelectionChanges(edgeLookup, selectedEdgeIds.current);\n            triggerEdgeChanges(changes);\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect,\n            userSelectionActive: true,\n            nodesSelectionActive: false\n        });\n    };\n    const onPointerUp = (event)=>{\n        if (event.button !== 0 || !selectionStarted.current) {\n            return;\n        }\n        event.target?.releasePointerCapture?.(event.pointerId);\n        const { userSelectionRect } = store.getState();\n        // We only want to trigger click functions when in selection mode if\n        // the user did not move the mouse.\n        if (!userSelectionActive && userSelectionRect && event.target === container.current) {\n            onClick?.(event);\n        }\n        store.setState({\n            userSelectionActive: false,\n            userSelectionRect: null,\n            nodesSelectionActive: selectedNodeIds.current.size > 0\n        });\n        onSelectionEnd?.(event);\n        // If the user kept holding the selectionKey during the selection,\n        // we need to reset the selectionInProgress, so the next click event is not prevented\n        if (selectionKeyPressed || selectionOnDrag) {\n            selectionInProgress.current = false;\n        }\n        selectionStarted.current = false;\n    };\n    const draggable = panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(0);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__pane',\n            {\n                draggable,\n                dragging,\n                selection: isSelecting\n            }\n        ]),\n        onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container),\n        onContextMenu: wrapHandler(onContextMenu, container),\n        onWheel: wrapHandler(onWheel, container),\n        onPointerEnter: hasActiveSelection ? undefined : onPaneMouseEnter,\n        onPointerDown: hasActiveSelection ? onPointerDown : onPaneMouseMove,\n        onPointerMove: hasActiveSelection ? onPointerMove : onPaneMouseMove,\n        onPointerUp: hasActiveSelection ? onPointerUp : undefined,\n        onPointerLeave: onPaneMouseLeave,\n        ref: container,\n        style: containerStyle,\n        children: [\n            children,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UserSelection, {})\n        ]\n    });\n}\n// this handler is called by\n// 1. the click handler when node is not draggable or selectNodesOnDrag = false\n// or\n// 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\nfunction handleNodeClick({ id, store, unselect = false, nodeRef }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState();\n    const node = nodeLookup.get(id);\n    if (!node) {\n        onError?.('012', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error012'](id));\n        return;\n    }\n    store.setState({\n        nodesSelectionActive: false\n    });\n    if (!node.selected) {\n        addSelectedNodes([\n            id\n        ]);\n    } else if (unselect || node.selected && multiSelectionActive) {\n        unselectNodesAndEdges({\n            nodes: [\n                node\n            ],\n            edges: []\n        });\n        requestAnimationFrame(()=>nodeRef?.current?.blur());\n    }\n}\n/**\n * Hook for calling XYDrag helper from @xyflow/system.\n *\n * @internal\n */ function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const xyDrag = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            xyDrag.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYDrag)({\n                getStoreItems: {\n                    \"useDrag.useEffect\": ()=>store.getState()\n                }[\"useDrag.useEffect\"],\n                onNodeMouseDown: {\n                    \"useDrag.useEffect\": (id)=>{\n                        handleNodeClick({\n                            id,\n                            store,\n                            nodeRef\n                        });\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStart: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(true);\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStop: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(false);\n                    }\n                }[\"useDrag.useEffect\"]\n            });\n        }\n    }[\"useDrag.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            if (disabled) {\n                xyDrag.current?.destroy();\n            } else if (nodeRef.current) {\n                xyDrag.current?.update({\n                    noDragClassName,\n                    handleSelector,\n                    domNode: nodeRef.current,\n                    isSelectable,\n                    nodeId,\n                    nodeClickDistance\n                });\n                return ({\n                    \"useDrag.useEffect\": ()=>{\n                        xyDrag.current?.destroy();\n                    }\n                })[\"useDrag.useEffect\"];\n            }\n        }\n    }[\"useDrag.useEffect\"], [\n        noDragClassName,\n        handleSelector,\n        disabled,\n        isSelectable,\n        nodeRef,\n        nodeId\n    ]);\n    return dragging;\n}\nconst selectedAndDraggable = (nodesDraggable)=>(n)=>n.selected && (n.draggable || nodesDraggable && typeof n.draggable === 'undefined');\n/**\n * Hook for updating node positions by passing a direction and factor\n *\n * @internal\n * @returns function for updating node positions\n */ function useMoveSelectedNodes() {\n    const store = useStoreApi();\n    const moveSelectedNodes = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useMoveSelectedNodes.useCallback[moveSelectedNodes]\": (params)=>{\n            const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState();\n            const nodeUpdates = new Map();\n            const isSelected = selectedAndDraggable(nodesDraggable);\n            // by default a node moves 5px on each key press\n            // if snap grid is enabled, we use that for the velocity\n            const xVelo = snapToGrid ? snapGrid[0] : 5;\n            const yVelo = snapToGrid ? snapGrid[1] : 5;\n            const xDiff = params.direction.x * xVelo * params.factor;\n            const yDiff = params.direction.y * yVelo * params.factor;\n            for (const [, node] of nodeLookup){\n                if (!isSelected(node)) {\n                    continue;\n                }\n                let nextPosition = {\n                    x: node.internals.positionAbsolute.x + xDiff,\n                    y: node.internals.positionAbsolute.y + yDiff\n                };\n                if (snapToGrid) {\n                    nextPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.snapPosition)(nextPosition, snapGrid);\n                }\n                const { position, positionAbsolute } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.calculateNodePosition)({\n                    nodeId: node.id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent,\n                    nodeOrigin,\n                    onError\n                });\n                node.position = position;\n                node.internals.positionAbsolute = positionAbsolute;\n                nodeUpdates.set(node.id, node);\n            }\n            updateNodePositions(nodeUpdates);\n        }\n    }[\"useMoveSelectedNodes.useCallback[moveSelectedNodes]\"], []);\n    return moveSelectedNodes;\n}\nconst NodeIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\nconst useNodeId = ()=>{\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(NodeIdContext);\n    return nodeId;\n};\nconst selector$g = (s)=>({\n        connectOnClick: s.connectOnClick,\n        noPanClassName: s.noPanClassName,\n        rfId: s.rfId\n    });\nconst connectingSelector = (nodeId, handleId, type)=>(state)=>{\n        const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state;\n        const { fromHandle, toHandle, isValid } = connection;\n        const connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;\n        return {\n            connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,\n            connectingTo,\n            clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,\n            isPossibleEndHandle: connectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,\n            connectionInProcess: !!fromHandle,\n            valid: connectingTo && isValid\n        };\n    };\nfunction HandleComponent({ type = 'source', position = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) {\n    const handleId = id || null;\n    const isTarget = type === 'target';\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName, rfId } = useStore(selector$g, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, valid } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.('010', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error010']());\n    }\n    const onConnectExtended = (params)=>{\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.addEdge)(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event)=>{\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isMouseEvent)(event.nativeEvent);\n        if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {\n            const currentStore = store.getState();\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYHandle.onPointerDown(event.nativeEvent, {\n                autoPanOnConnect: currentStore.autoPanOnConnect,\n                connectionMode: currentStore.connectionMode,\n                connectionRadius: currentStore.connectionRadius,\n                domNode: currentStore.domNode,\n                nodeLookup: currentStore.nodeLookup,\n                lib: currentStore.lib,\n                isTarget,\n                handleId,\n                nodeId,\n                flowId: currentStore.rfId,\n                panBy: currentStore.panBy,\n                cancelConnection: currentStore.cancelConnection,\n                onConnectStart: currentStore.onConnectStart,\n                onConnectEnd: currentStore.onConnectEnd,\n                updateConnection: currentStore.updateConnection,\n                onConnect: onConnectExtended,\n                isValidConnection: isValidConnection || currentStore.isValidConnection,\n                getTransform: ()=>store.getState().transform,\n                getFromHandle: ()=>store.getState().connection.fromHandle,\n                autoPanSpeed: currentStore.autoPanSpeed\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        } else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event)=>{\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();\n        if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event.nativeEvent, {\n                nodeId,\n                handleId,\n                handleType: type\n            });\n            store.setState({\n                connectionClickStartHandle: {\n                    nodeId,\n                    type,\n                    id: handleId\n                }\n            });\n            return;\n        }\n        const doc = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getHostForElement)(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore;\n        const { connection, isValid } = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYHandle.isValid(event.nativeEvent, {\n            handle: {\n                nodeId,\n                id: handleId,\n                type\n            },\n            connectionMode,\n            fromNodeId: connectionClickStartHandle.nodeId,\n            fromHandleId: connectionClickStartHandle.id || null,\n            fromType: connectionClickStartHandle.type,\n            isValidConnection: isValidConnectionHandler,\n            flowId,\n            doc,\n            lib,\n            nodeLookup\n        });\n        if (isValid && connection) {\n            onConnectExtended(connection);\n        }\n        const connectionClone = structuredClone(connectionState);\n        delete connectionClone.inProgress;\n        connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;\n        onClickConnectEnd?.(event, connectionClone);\n        store.setState({\n            connectionClickStartHandle: null\n        });\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-handleid\": handleId,\n        \"data-nodeid\": nodeId,\n        \"data-handlepos\": position,\n        \"data-id\": `${rfId}-${nodeId}-${handleId}-${type}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__handle',\n            `react-flow__handle-${position}`,\n            'nodrag',\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                clickconnecting: clickConnecting,\n                connectingfrom: connectingFrom,\n                connectingto: connectingTo,\n                valid,\n                // shows where you can start a connection from\n                // and where you can end it while connecting\n                connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess ? isConnectableEnd : isConnectableStart)\n            }\n        ]),\n        onMouseDown: onPointerDown,\n        onTouchStart: onPointerDown,\n        onClick: connectOnClick ? onClick : undefined,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n}\n/**\n * The Handle component is a UI element that is used to connect nodes.\n */ const Handle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(fixedForwardRef(HandleComponent));\nfunction InputNode({ data, isConnectable, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction DefaultNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction GroupNode() {\n    return null;\n}\nfunction OutputNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label\n        ]\n    });\n}\nconst arrowKeyDiffs = {\n    ArrowUp: {\n        x: 0,\n        y: -1\n    },\n    ArrowDown: {\n        x: 0,\n        y: 1\n    },\n    ArrowLeft: {\n        x: -1,\n        y: 0\n    },\n    ArrowRight: {\n        x: 1,\n        y: 0\n    }\n};\nconst builtinNodeTypes = {\n    input: InputNode,\n    default: DefaultNode,\n    output: OutputNode,\n    group: GroupNode\n};\nfunction getNodeInlineStyleDimensions(node) {\n    if (node.internals.handleBounds === undefined) {\n        return {\n            width: node.width ?? node.initialWidth ?? node.style?.width,\n            height: node.height ?? node.initialHeight ?? node.style?.height\n        };\n    }\n    return {\n        width: node.width ?? node.style?.width,\n        height: node.height ?? node.style?.height\n    };\n}\nconst selector$f = (s)=>{\n    const { width, height, x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getInternalNodesBounds)(s.nodeLookup, {\n        filter: (node)=>!!node.selected\n    });\n    return {\n        width: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(width) ? width : null,\n        height: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(height) ? height : null,\n        userSelectionActive: s.userSelectionActive,\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]}) translate(${x}px,${y}px)`\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, transformString, userSelectionActive } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const moveSelectedNodes = useMoveSelectedNodes();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"NodesSelection.useEffect\": ()=>{\n            if (!disableKeyboardA11y) {\n                nodeRef.current?.focus({\n                    preventScroll: true\n                });\n            }\n        }\n    }[\"NodesSelection.useEffect\"], [\n        disableKeyboardA11y\n    ]);\n    useDrag({\n        nodeRef\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu ? (event)=>{\n        const selectedNodes = store.getState().nodes.filter((n)=>n.selected);\n        onSelectionContextMenu(event, selectedNodes);\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            event.preventDefault();\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__nodesselection',\n            'react-flow__container',\n            noPanClassName\n        ]),\n        style: {\n            transform: transformString\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            ref: nodeRef,\n            className: \"react-flow__nodesselection-rect\",\n            onContextMenu: onContextMenu,\n            tabIndex: disableKeyboardA11y ? undefined : -1,\n            onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,\n            style: {\n                width,\n                height\n            }\n        })\n    });\n}\nconst win =  false ? 0 : undefined;\nconst selector$e = (s)=>{\n    return {\n        nodesSelectionActive: s.nodesSelectionActive,\n        userSelectionActive: s.userSelectionActive\n    };\n};\nfunction FlowRendererComponent({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {\n    const { nodesSelectionActive, userSelectionActive } = useStore(selector$e);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode, {\n        target: win\n    });\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode, {\n        target: win\n    });\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const panOnScroll = panActivationKeyPressed || _panOnScroll;\n    const _selectionOnDrag = selectionOnDrag && panOnDrag !== true;\n    const isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;\n    useGlobalKeyHandler({\n        deleteKeyCode,\n        multiSelectionKeyCode\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ZoomPane, {\n        onPaneContextMenu: onPaneContextMenu,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnDrag: !selectionKeyPressed && panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        preventScrolling: preventScrolling,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        onViewportChange: onViewportChange,\n        isControlledViewport: isControlledViewport,\n        paneClickDistance: paneClickDistance,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Pane, {\n            onSelectionStart: onSelectionStart,\n            onSelectionEnd: onSelectionEnd,\n            onPaneClick: onPaneClick,\n            onPaneMouseEnter: onPaneMouseEnter,\n            onPaneMouseMove: onPaneMouseMove,\n            onPaneMouseLeave: onPaneMouseLeave,\n            onPaneContextMenu: onPaneContextMenu,\n            onPaneScroll: onPaneScroll,\n            panOnDrag: panOnDrag,\n            isSelecting: !!isSelecting,\n            selectionMode: selectionMode,\n            selectionKeyPressed: selectionKeyPressed,\n            selectionOnDrag: _selectionOnDrag,\n            children: [\n                children,\n                nodesSelectionActive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodesSelection, {\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\nFlowRendererComponent.displayName = 'FlowRenderer';\nconst FlowRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(FlowRendererComponent);\nconst selector$d = (onlyRenderVisible)=>(s)=>{\n        return onlyRenderVisible ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodesInside)(s.nodeLookup, {\n            x: 0,\n            y: 0,\n            width: s.width,\n            height: s.height\n        }, s.transform, true).map((node)=>node.id) : Array.from(s.nodeLookup.keys());\n    };\n/**\n * Hook for getting the visible node ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible node ids\n */ function useVisibleNodeIds(onlyRenderVisible) {\n    const nodeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(selector$d(onlyRenderVisible), [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodeIds;\n}\nconst selector$c = (s)=>s.updateNodeInternals;\nfunction useResizeObserver() {\n    const updateNodeInternals = useStore(selector$c);\n    const [resizeObserver] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        \"useResizeObserver.useState\": ()=>{\n            if (typeof ResizeObserver === 'undefined') {\n                return null;\n            }\n            return new ResizeObserver({\n                \"useResizeObserver.useState\": (entries)=>{\n                    const updates = new Map();\n                    entries.forEach({\n                        \"useResizeObserver.useState\": (entry)=>{\n                            const id = entry.target.getAttribute('data-id');\n                            updates.set(id, {\n                                id,\n                                nodeElement: entry.target,\n                                force: true\n                            });\n                        }\n                    }[\"useResizeObserver.useState\"]);\n                    updateNodeInternals(updates);\n                }\n            }[\"useResizeObserver.useState\"]);\n        }\n    }[\"useResizeObserver.useState\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useResizeObserver.useEffect\": ()=>{\n            return ({\n                \"useResizeObserver.useEffect\": ()=>{\n                    resizeObserver?.disconnect();\n                }\n            })[\"useResizeObserver.useEffect\"];\n        }\n    }[\"useResizeObserver.useEffect\"], [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\n/**\n * Hook to handle the resize observation + internal updates for the passed node.\n *\n * @internal\n * @returns nodeRef - reference to the node element\n */ function useNodeObserver({ node, nodeType, hasDimensions, resizeObserver }) {\n    const store = useStoreApi();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const observedNode = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(node.sourcePosition);\n    const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(node.targetPosition);\n    const prevType = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(nodeType);\n    const isInitialized = hasDimensions && !!node.internals.handleBounds;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current && !node.hidden && (!isInitialized || observedNode.current !== nodeRef.current)) {\n                if (observedNode.current) {\n                    resizeObserver?.unobserve(observedNode.current);\n                }\n                resizeObserver?.observe(nodeRef.current);\n                observedNode.current = nodeRef.current;\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        isInitialized,\n        node.hidden\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            return ({\n                \"useNodeObserver.useEffect\": ()=>{\n                    if (observedNode.current) {\n                        resizeObserver?.unobserve(observedNode.current);\n                        observedNode.current = null;\n                    }\n                }\n            })[\"useNodeObserver.useEffect\"];\n        }\n    }[\"useNodeObserver.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current) {\n                // when the user programmatically changes the source or handle position, we need to update the internals\n                // to make sure the edges are updated correctly\n                const typeChanged = prevType.current !== nodeType;\n                const sourcePosChanged = prevSourcePosition.current !== node.sourcePosition;\n                const targetPosChanged = prevTargetPosition.current !== node.targetPosition;\n                if (typeChanged || sourcePosChanged || targetPosChanged) {\n                    prevType.current = nodeType;\n                    prevSourcePosition.current = node.sourcePosition;\n                    prevTargetPosition.current = node.targetPosition;\n                    store.getState().updateNodeInternals(new Map([\n                        [\n                            node.id,\n                            {\n                                id: node.id,\n                                nodeElement: nodeRef.current,\n                                force: true\n                            }\n                        ]\n                    ]));\n                }\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        node.id,\n        nodeType,\n        node.sourcePosition,\n        node.targetPosition\n    ]);\n    return nodeRef;\n}\nfunction NodeWrapper({ id, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes, nodeExtent, nodeClickDistance, onError }) {\n    const { node, internals, isParent } = useStore({\n        \"NodeWrapper.useStore\": (s)=>{\n            const node = s.nodeLookup.get(id);\n            const isParent = s.parentLookup.has(id);\n            return {\n                node,\n                internals: node.internals,\n                isParent\n            };\n        }\n    }[\"NodeWrapper.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    let nodeType = node.type || 'default';\n    let NodeComponent = nodeTypes?.[nodeType] || builtinNodeTypes[nodeType];\n    if (NodeComponent === undefined) {\n        onError?.('003', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error003'](nodeType));\n        nodeType = 'default';\n        NodeComponent = builtinNodeTypes.default;\n    }\n    const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === 'undefined');\n    const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === 'undefined');\n    const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === 'undefined');\n    const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === 'undefined');\n    const store = useStoreApi();\n    const hasDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeHasDimensions)(node);\n    const nodeRef = useNodeObserver({\n        node,\n        nodeType,\n        hasDimensions,\n        resizeObserver\n    });\n    const dragging = useDrag({\n        nodeRef,\n        disabled: node.hidden || !isDraggable,\n        noDragClassName,\n        handleSelector: node.dragHandle,\n        nodeId: id,\n        isSelectable,\n        nodeClickDistance\n    });\n    const moveSelectedNodes = useMoveSelectedNodes();\n    if (node.hidden) {\n        return null;\n    }\n    const nodeDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodeDimensions)(node);\n    const inlineDimensions = getNodeInlineStyleDimensions(node);\n    const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n    const onMouseEnterHandler = onMouseEnter ? (event)=>onMouseEnter(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseMoveHandler = onMouseMove ? (event)=>onMouseMove(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseLeaveHandler = onMouseLeave ? (event)=>onMouseLeave(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onContextMenuHandler = onContextMenu ? (event)=>onContextMenu(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onDoubleClickHandler = onDoubleClick ? (event)=>onDoubleClick(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onSelectNodeHandler = (event)=>{\n        const { selectNodesOnDrag, nodeDragThreshold } = store.getState();\n        if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n            // this handler gets called by XYDrag on drag start when selectNodesOnDrag=true\n            // here we only need to call it when selectNodesOnDrag=false\n            handleNodeClick({\n                id,\n                store,\n                nodeRef\n            });\n        }\n        if (onClick) {\n            onClick(event, {\n                ...internals.userNode\n            });\n        }\n    };\n    const onKeyDown = (event)=>{\n        if ((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isInputDOMNode)(event.nativeEvent) || disableKeyboardA11y) {\n            return;\n        }\n        if (_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const unselect = event.key === 'Escape';\n            handleNodeClick({\n                id,\n                store,\n                unselect,\n                nodeRef\n            });\n        } else if (isDraggable && node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            // prevent default scrolling behavior on arrow key press when node is moved\n            event.preventDefault();\n            store.setState({\n                ariaLiveMessage: `Moved selected node ${event.key.replace('Arrow', '').toLowerCase()}. New position, x: ${~~internals.positionAbsolute.x}, y: ${~~internals.positionAbsolute.y}`\n            });\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__node',\n            `react-flow__node-${nodeType}`,\n            {\n                // this is overwritable by passing `nopan` as a class name\n                [noPanClassName]: isDraggable\n            },\n            node.className,\n            {\n                selected: node.selected,\n                selectable: isSelectable,\n                parent: isParent,\n                draggable: isDraggable,\n                dragging\n            }\n        ]),\n        ref: nodeRef,\n        style: {\n            zIndex: internals.z,\n            transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,\n            pointerEvents: hasPointerEvents ? 'all' : 'none',\n            visibility: hasDimensions ? 'visible' : 'hidden',\n            ...node.style,\n            ...inlineDimensions\n        },\n        \"data-id\": id,\n        \"data-testid\": `rf__node-${id}`,\n        onMouseEnter: onMouseEnterHandler,\n        onMouseMove: onMouseMoveHandler,\n        onMouseLeave: onMouseLeaveHandler,\n        onContextMenu: onContextMenuHandler,\n        onClick: onSelectNodeHandler,\n        onDoubleClick: onDoubleClickHandler,\n        onKeyDown: isFocusable ? onKeyDown : undefined,\n        tabIndex: isFocusable ? 0 : undefined,\n        role: isFocusable ? 'button' : undefined,\n        \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`,\n        \"aria-label\": node.ariaLabel,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider, {\n            value: id,\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n                id: id,\n                data: node.data,\n                type: nodeType,\n                positionAbsoluteX: internals.positionAbsolute.x,\n                positionAbsoluteY: internals.positionAbsolute.y,\n                selected: node.selected ?? false,\n                selectable: isSelectable,\n                draggable: isDraggable,\n                deletable: node.deletable ?? true,\n                isConnectable: isConnectable,\n                sourcePosition: node.sourcePosition,\n                targetPosition: node.targetPosition,\n                dragging: dragging,\n                dragHandle: node.dragHandle,\n                zIndex: internals.z,\n                parentId: node.parentId,\n                ...nodeDimensions\n            })\n        })\n    });\n}\nconst selector$b = (s)=>({\n        nodesDraggable: s.nodesDraggable,\n        nodesConnectable: s.nodesConnectable,\n        nodesFocusable: s.nodesFocusable,\n        elementsSelectable: s.elementsSelectable,\n        onError: s.onError\n    });\nfunction NodeRendererComponent(props) {\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements);\n    const resizeObserver = useResizeObserver();\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__nodes\",\n        style: containerStyle,\n        children: nodeIds.map((nodeId)=>{\n            return(// The split of responsibilities between NodeRenderer and\n            // NodeComponentWrapper may appear weird. However, it’s designed to\n            // minimize the cost of updates when individual nodes change.\n            //\n            // For example, when you’re dragging a single node, that node gets\n            // updated multiple times per second. If `NodeRenderer` were to update\n            // every time, it would have to re-run the `nodes.map()` loop every\n            // time. This gets pricey with hundreds of nodes, especially if every\n            // loop cycle does more than just rendering a JSX element!\n            //\n            // As a result of this choice, we took the following implementation\n            // decisions:\n            // - NodeRenderer subscribes *only* to node IDs – and therefore\n            //   rerender *only* when visible nodes are added or removed.\n            // - NodeRenderer performs all operations the result of which can be\n            //   shared between nodes (such as creating the `ResizeObserver`\n            //   instance, or subscribing to `selector`). This means extra prop\n            //   drilling into `NodeComponentWrapper`, but it means we need to run\n            //   these operations only once – instead of once per node.\n            // - Any operations that you’d normally write inside `nodes.map` are\n            //   moved into `NodeComponentWrapper`. This ensures they are\n            //   memorized – so if `NodeRenderer` *has* to rerender, it only\n            //   needs to regenerate the list of nodes, nothing else.\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeWrapper, {\n                id: nodeId,\n                nodeTypes: props.nodeTypes,\n                nodeExtent: props.nodeExtent,\n                onClick: props.onNodeClick,\n                onMouseEnter: props.onNodeMouseEnter,\n                onMouseMove: props.onNodeMouseMove,\n                onMouseLeave: props.onNodeMouseLeave,\n                onContextMenu: props.onNodeContextMenu,\n                onDoubleClick: props.onNodeDoubleClick,\n                noDragClassName: props.noDragClassName,\n                noPanClassName: props.noPanClassName,\n                rfId: props.rfId,\n                disableKeyboardA11y: props.disableKeyboardA11y,\n                resizeObserver: resizeObserver,\n                nodesDraggable: nodesDraggable,\n                nodesConnectable: nodesConnectable,\n                nodesFocusable: nodesFocusable,\n                elementsSelectable: elementsSelectable,\n                nodeClickDistance: props.nodeClickDistance,\n                onError: onError\n            }, nodeId));\n        })\n    });\n}\nNodeRendererComponent.displayName = 'NodeRenderer';\nconst NodeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(NodeRendererComponent);\n/**\n * Hook for getting the visible edge ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible edge ids\n */ function useVisibleEdgeIds(onlyRenderVisible) {\n    const edgeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useVisibleEdgeIds.useStore[edgeIds]\": (s)=>{\n            if (!onlyRenderVisible) {\n                return s.edges.map({\n                    \"useVisibleEdgeIds.useStore[edgeIds]\": (edge)=>edge.id\n                }[\"useVisibleEdgeIds.useStore[edgeIds]\"]);\n            }\n            const visibleEdgeIds = [];\n            if (s.width && s.height) {\n                for (const edge of s.edges){\n                    const sourceNode = s.nodeLookup.get(edge.source);\n                    const targetNode = s.nodeLookup.get(edge.target);\n                    if (sourceNode && targetNode && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isEdgeVisible)({\n                        sourceNode,\n                        targetNode,\n                        width: s.width,\n                        height: s.height,\n                        transform: s.transform\n                    })) {\n                        visibleEdgeIds.push(edge.id);\n                    }\n                }\n            }\n            return visibleEdgeIds;\n        }\n    }[\"useVisibleEdgeIds.useStore[edgeIds]\"], [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edgeIds;\n}\nconst ArrowSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        style: {\n            stroke: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        fill: \"none\",\n        points: \"-5,-4 0,0 -5,4\"\n    });\n};\nconst ArrowClosedSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        style: {\n            stroke: color,\n            fill: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4 -5,-4\"\n    });\n};\nconst MarkerSymbols = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.MarkerType.Arrow]: ArrowSymbol,\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.MarkerType.ArrowClosed]: ArrowClosedSymbol\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useMarkerSymbol.useMemo[symbol]\": ()=>{\n            const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n            if (!symbolExists) {\n                store.getState().onError?.('009', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error009'](type));\n                return null;\n            }\n            return MarkerSymbols[type];\n        }\n    }[\"useMarkerSymbol.useMemo[symbol]\"], [\n        type\n    ]);\n    return symbol;\n}\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = 'strokeWidth', strokeWidth, orient = 'auto-start-reverse' })=>{\n    const Symbol = useMarkerSymbol(type);\n    if (!Symbol) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", {\n        className: \"react-flow__arrowhead\",\n        id: id,\n        markerWidth: `${width}`,\n        markerHeight: `${height}`,\n        viewBox: \"-10 -10 20 20\",\n        markerUnits: markerUnits,\n        orient: orient,\n        refX: \"0\",\n        refY: \"0\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Symbol, {\n            color: color,\n            strokeWidth: strokeWidth\n        })\n    });\n};\n// when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n// when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n// that we can then use for creating our unique marker ids\nconst MarkerDefinitions = ({ defaultColor, rfId })=>{\n    const edges = useStore({\n        \"MarkerDefinitions.useStore[edges]\": (s)=>s.edges\n    }[\"MarkerDefinitions.useStore[edges]\"]);\n    const defaultEdgeOptions = useStore({\n        \"MarkerDefinitions.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"MarkerDefinitions.useStore[defaultEdgeOptions]\"]);\n    const markers = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"MarkerDefinitions.useMemo[markers]\": ()=>{\n            const markers = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.createMarkerIds)(edges, {\n                id: rfId,\n                defaultColor,\n                defaultMarkerStart: defaultEdgeOptions?.markerStart,\n                defaultMarkerEnd: defaultEdgeOptions?.markerEnd\n            });\n            return markers;\n        }\n    }[\"MarkerDefinitions.useMemo[markers]\"], [\n        edges,\n        defaultEdgeOptions,\n        rfId,\n        defaultColor\n    ]);\n    if (!markers.length) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        className: \"react-flow__marker\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n            children: markers.map((marker)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Marker, {\n                    id: marker.id,\n                    type: marker.type,\n                    color: marker.color,\n                    width: marker.width,\n                    height: marker.height,\n                    markerUnits: marker.markerUnits,\n                    strokeWidth: marker.strokeWidth,\n                    orient: marker.orient\n                }, marker.id))\n        })\n    });\n};\nMarkerDefinitions.displayName = 'MarkerDefinitions';\nvar MarkerDefinitions$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(MarkerDefinitions);\nfunction EdgeTextComponent({ x, y, label, labelStyle = {}, labelShowBg = true, labelBgStyle = {}, labelBgPadding = [\n    2,\n    4\n], labelBgBorderRadius = 2, children, className, ...rest }) {\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        x: 1,\n        y: 0,\n        width: 0,\n        height: 0\n    });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        'react-flow__edge-textwrapper',\n        className\n    ]);\n    const edgeTextRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"EdgeTextComponent.useEffect\": ()=>{\n            if (edgeTextRef.current) {\n                const textBbox = edgeTextRef.current.getBBox();\n                setEdgeTextBbox({\n                    x: textBbox.x,\n                    y: textBbox.y,\n                    width: textBbox.width,\n                    height: textBbox.height\n                });\n            }\n        }\n    }[\"EdgeTextComponent.useEffect\"], [\n        label\n    ]);\n    if (typeof label === 'undefined' || !label) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n        transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`,\n        className: edgeTextClasses,\n        visibility: edgeTextBbox.width ? 'visible' : 'hidden',\n        ...rest,\n        children: [\n            labelShowBg && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                width: edgeTextBbox.width + 2 * labelBgPadding[0],\n                x: -labelBgPadding[0],\n                y: -labelBgPadding[1],\n                height: edgeTextBbox.height + 2 * labelBgPadding[1],\n                className: \"react-flow__edge-textbg\",\n                style: labelBgStyle,\n                rx: labelBgBorderRadius,\n                ry: labelBgBorderRadius\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"text\", {\n                className: \"react-flow__edge-text\",\n                y: edgeTextBbox.height / 2,\n                dy: \"0.3em\",\n                ref: edgeTextRef,\n                style: labelStyle,\n                children: label\n            }),\n            children\n        ]\n    });\n}\nEdgeTextComponent.displayName = 'EdgeText';\nconst EdgeText = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(EdgeTextComponent);\nfunction BaseEdge({ path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, interactionWidth = 20, ...props }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                ...props,\n                d: path,\n                fill: \"none\",\n                className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                    'react-flow__edge-path',\n                    props.className\n                ])\n            }),\n            interactionWidth && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: path,\n                fill: \"none\",\n                strokeOpacity: 0,\n                strokeWidth: interactionWidth,\n                className: \"react-flow__edge-interaction\"\n            }),\n            label && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(labelX) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(labelY) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeText, {\n                x: labelX,\n                y: labelY,\n                label: label,\n                labelStyle: labelStyle,\n                labelShowBg: labelShowBg,\n                labelBgStyle: labelBgStyle,\n                labelBgPadding: labelBgPadding,\n                labelBgBorderRadius: labelBgBorderRadius\n            }) : null\n        ]\n    });\n}\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Left || pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Right) {\n        return [\n            0.5 * (x1 + x2),\n            y1\n        ];\n    }\n    return [\n        x1,\n        0.5 * (y1 + y2)\n    ];\n}\nfunction getSimpleBezierPath({ sourceX, sourceY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom, targetX, targetY, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY\n    });\n    const [labelX, labelY, offsetX, offsetY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierEdgeCenter)({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nfunction createSimpleBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = getSimpleBezierPath({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SimpleBezierEdge = createSimpleBezierEdge({\n    isInternal: false\n});\nconst SimpleBezierEdgeInternal = createSimpleBezierEdge({\n    isInternal: true\n});\nSimpleBezierEdge.displayName = 'SimpleBezierEdge';\nSimpleBezierEdgeInternal.displayName = 'SimpleBezierEdgeInternal';\nfunction createSmoothStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getSmoothStepPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            borderRadius: pathOptions?.borderRadius,\n            offset: pathOptions?.offset\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SmoothStepEdge = createSmoothStepEdge({\n    isInternal: false\n});\nconst SmoothStepEdgeInternal = createSmoothStepEdge({\n    isInternal: true\n});\nSmoothStepEdge.displayName = 'SmoothStepEdge';\nSmoothStepEdgeInternal.displayName = 'SmoothStepEdgeInternal';\nfunction createStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(({ id, ...props })=>{\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SmoothStepEdge, {\n            ...props,\n            id: _id,\n            pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n                \"createStepEdge.useMemo\": ()=>({\n                        borderRadius: 0,\n                        offset: props.pathOptions?.offset\n                    })\n            }[\"createStepEdge.useMemo\"], [\n                props.pathOptions?.offset\n            ])\n        });\n    });\n}\nconst StepEdge = createStepEdge({\n    isInternal: false\n});\nconst StepEdgeInternal = createStepEdge({\n    isInternal: true\n});\nStepEdge.displayName = 'StepEdge';\nStepEdgeInternal.displayName = 'StepEdgeInternal';\nfunction createStraightEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getStraightPath)({\n            sourceX,\n            sourceY,\n            targetX,\n            targetY\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst StraightEdge = createStraightEdge({\n    isInternal: false\n});\nconst StraightEdgeInternal = createStraightEdge({\n    isInternal: true\n});\nStraightEdge.displayName = 'StraightEdge';\nStraightEdgeInternal.displayName = 'StraightEdgeInternal';\nfunction createBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            curvature: pathOptions?.curvature\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst BezierEdge = createBezierEdge({\n    isInternal: false\n});\nconst BezierEdgeInternal = createBezierEdge({\n    isInternal: true\n});\nBezierEdge.displayName = 'BezierEdge';\nBezierEdgeInternal.displayName = 'BezierEdgeInternal';\nconst builtinEdgeTypes = {\n    default: BezierEdgeInternal,\n    straight: StraightEdgeInternal,\n    step: StepEdgeInternal,\n    smoothstep: SmoothStepEdgeInternal,\n    simplebezier: SimpleBezierEdgeInternal\n};\nconst nullPosition = {\n    sourceX: null,\n    sourceY: null,\n    targetX: null,\n    targetY: null,\n    sourcePosition: null,\n    targetPosition: null\n};\nconst shiftX = (x, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Left) return x - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Right) return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top) return y - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom) return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = 'react-flow__edgeupdater';\nfunction EdgeAnchor({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            EdgeUpdaterClassName,\n            `${EdgeUpdaterClassName}-${type}`\n        ]),\n        cx: shiftX(centerX, radius, position),\n        cy: shiftY(centerY, radius, position),\n        r: radius,\n        stroke: \"transparent\",\n        fill: \"transparent\"\n    });\n}\nfunction EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {\n    const store = useStoreApi();\n    const handleEdgeUpdater = (event, oppositeHandle)=>{\n        // avoid triggering edge updater if mouse btn is not left\n        if (event.button !== 0) {\n            return;\n        }\n        const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy, updateConnection } = store.getState();\n        const isTarget = oppositeHandle.type === 'target';\n        setReconnecting(true);\n        onReconnectStart?.(event, edge, oppositeHandle.type);\n        const _onReconnectEnd = (evt, connectionState)=>{\n            setReconnecting(false);\n            onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);\n        };\n        const onConnectEdge = (connection)=>onReconnect?.(edge, connection);\n        _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYHandle.onPointerDown(event.nativeEvent, {\n            autoPanOnConnect,\n            connectionMode,\n            connectionRadius,\n            domNode,\n            handleId: oppositeHandle.id,\n            nodeId: oppositeHandle.nodeId,\n            nodeLookup,\n            isTarget,\n            edgeUpdaterType: oppositeHandle.type,\n            lib,\n            flowId,\n            cancelConnection,\n            panBy,\n            isValidConnection,\n            onConnect: onConnectEdge,\n            onConnectStart,\n            onConnectEnd,\n            onReconnectEnd: _onReconnectEnd,\n            updateConnection,\n            getTransform: ()=>store.getState().transform,\n            getFromHandle: ()=>store.getState().connection.fromHandle\n        });\n    };\n    const onReconnectSourceMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.target,\n            id: edge.targetHandle ?? null,\n            type: 'target'\n        });\n    const onReconnectTargetMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.source,\n            id: edge.sourceHandle ?? null,\n            type: 'source'\n        });\n    const onReconnectMouseEnter = ()=>setUpdateHover(true);\n    const onReconnectMouseOut = ()=>setUpdateHover(false);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (isReconnectable === true || isReconnectable === 'source') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: sourcePosition,\n                centerX: sourceX,\n                centerY: sourceY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectSourceMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"source\"\n            }),\n            (isReconnectable === true || isReconnectable === 'target') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: targetPosition,\n                centerX: targetX,\n                centerY: targetY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectTargetMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"target\"\n            })\n        ]\n    });\n}\nfunction EdgeWrapper({ id, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes, noPanClassName, onError, disableKeyboardA11y }) {\n    let edge = useStore({\n        \"EdgeWrapper.useStore[edge]\": (s)=>s.edgeLookup.get(id)\n    }[\"EdgeWrapper.useStore[edge]\"]);\n    const defaultEdgeOptions = useStore({\n        \"EdgeWrapper.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"EdgeWrapper.useStore[defaultEdgeOptions]\"]);\n    edge = defaultEdgeOptions ? {\n        ...defaultEdgeOptions,\n        ...edge\n    } : edge;\n    let edgeType = edge.type || 'default';\n    let EdgeComponent = edgeTypes?.[edgeType] || builtinEdgeTypes[edgeType];\n    if (EdgeComponent === undefined) {\n        onError?.('011', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error011'](edgeType));\n        edgeType = 'default';\n        EdgeComponent = builtinEdgeTypes.default;\n    }\n    const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === 'undefined');\n    const isReconnectable = typeof onReconnect !== 'undefined' && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable === 'undefined');\n    const isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable === 'undefined');\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [reconnecting, setReconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const store = useStoreApi();\n    const { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"EdgeWrapper.useStore.useCallback\": (store)=>{\n            const sourceNode = store.nodeLookup.get(edge.source);\n            const targetNode = store.nodeLookup.get(edge.target);\n            if (!sourceNode || !targetNode) {\n                return {\n                    zIndex: edge.zIndex,\n                    ...nullPosition\n                };\n            }\n            const edgePosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getEdgePosition)({\n                id,\n                sourceNode,\n                targetNode,\n                sourceHandle: edge.sourceHandle || null,\n                targetHandle: edge.targetHandle || null,\n                connectionMode: store.connectionMode,\n                onError\n            });\n            const zIndex = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getElevatedEdgeZIndex)({\n                selected: edge.selected,\n                zIndex: edge.zIndex,\n                sourceNode,\n                targetNode,\n                elevateOnSelect: store.elevateEdgesOnSelect\n            });\n            return {\n                zIndex,\n                ...edgePosition || nullPosition\n            };\n        }\n    }[\"EdgeWrapper.useStore.useCallback\"], [\n        edge.source,\n        edge.target,\n        edge.sourceHandle,\n        edge.targetHandle,\n        edge.selected,\n        edge.zIndex\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"EdgeWrapper.useMemo[markerStartUrl]\": ()=>edge.markerStart ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getMarkerId)(edge.markerStart, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerStartUrl]\"], [\n        edge.markerStart,\n        rfId\n    ]);\n    const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"EdgeWrapper.useMemo[markerEndUrl]\": ()=>edge.markerEnd ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getMarkerId)(edge.markerEnd, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerEndUrl]\"], [\n        edge.markerEnd,\n        rfId\n    ]);\n    if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null) {\n        return null;\n    }\n    const onEdgeClick = (event)=>{\n        const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n        if (isSelectable) {\n            store.setState({\n                nodesSelectionActive: false\n            });\n            if (edge.selected && multiSelectionActive) {\n                unselectNodesAndEdges({\n                    nodes: [],\n                    edges: [\n                        edge\n                    ]\n                });\n                edgeRef.current?.blur();\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n        if (onClick) {\n            onClick(event, edge);\n        }\n    };\n    const onEdgeDoubleClick = onDoubleClick ? (event)=>{\n        onDoubleClick(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeContextMenu = onContextMenu ? (event)=>{\n        onContextMenu(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseEnter = onMouseEnter ? (event)=>{\n        onMouseEnter(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseMove = onMouseMove ? (event)=>{\n        onMouseMove(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseLeave = onMouseLeave ? (event)=>{\n        onMouseLeave(event, {\n            ...edge\n        });\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (!disableKeyboardA11y && _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const { unselectNodesAndEdges, addSelectedEdges } = store.getState();\n            const unselect = event.key === 'Escape';\n            if (unselect) {\n                edgeRef.current?.blur();\n                unselectNodesAndEdges({\n                    edges: [\n                        edge\n                    ]\n                });\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: {\n            zIndex\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                'react-flow__edge',\n                `react-flow__edge-${edgeType}`,\n                edge.className,\n                noPanClassName,\n                {\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    inactive: !isSelectable && !onClick,\n                    updating: updateHover,\n                    selectable: isSelectable\n                }\n            ]),\n            onClick: onEdgeClick,\n            onDoubleClick: onEdgeDoubleClick,\n            onContextMenu: onEdgeContextMenu,\n            onMouseEnter: onEdgeMouseEnter,\n            onMouseMove: onEdgeMouseMove,\n            onMouseLeave: onEdgeMouseLeave,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: isFocusable ? 'button' : 'img',\n            \"data-id\": id,\n            \"data-testid\": `rf__edge-${id}`,\n            \"aria-label\": edge.ariaLabel === null ? undefined : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`,\n            \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined,\n            ref: edgeRef,\n            children: [\n                !reconnecting && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeComponent, {\n                    id: id,\n                    source: edge.source,\n                    target: edge.target,\n                    type: edge.type,\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    selectable: isSelectable,\n                    deletable: edge.deletable ?? true,\n                    label: edge.label,\n                    labelStyle: edge.labelStyle,\n                    labelShowBg: edge.labelShowBg,\n                    labelBgStyle: edge.labelBgStyle,\n                    labelBgPadding: edge.labelBgPadding,\n                    labelBgBorderRadius: edge.labelBgBorderRadius,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    data: edge.data,\n                    style: edge.style,\n                    sourceHandleId: edge.sourceHandle,\n                    targetHandleId: edge.targetHandle,\n                    markerStart: markerStartUrl,\n                    markerEnd: markerEndUrl,\n                    pathOptions: 'pathOptions' in edge ? edge.pathOptions : undefined,\n                    interactionWidth: edge.interactionWidth\n                }),\n                isReconnectable && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeUpdateAnchors, {\n                    edge: edge,\n                    isReconnectable: isReconnectable,\n                    reconnectRadius: reconnectRadius,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    setUpdateHover: setUpdateHover,\n                    setReconnecting: setReconnecting\n                })\n            ]\n        })\n    });\n}\nconst selector$a = (s)=>({\n        edgesFocusable: s.edgesFocusable,\n        edgesReconnectable: s.edgesReconnectable,\n        elementsSelectable: s.elementsSelectable,\n        connectionMode: s.connectionMode,\n        onError: s.onError\n    });\nfunction EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {\n    const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"react-flow__edges\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MarkerDefinitions$1, {\n                defaultColor: defaultMarkerColor,\n                rfId: rfId\n            }),\n            edgeIds.map((id)=>{\n                return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeWrapper, {\n                    id: id,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    noPanClassName: noPanClassName,\n                    onReconnect: onReconnect,\n                    onContextMenu: onEdgeContextMenu,\n                    onMouseEnter: onEdgeMouseEnter,\n                    onMouseMove: onEdgeMouseMove,\n                    onMouseLeave: onEdgeMouseLeave,\n                    onClick: onEdgeClick,\n                    reconnectRadius: reconnectRadius,\n                    onDoubleClick: onEdgeDoubleClick,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    rfId: rfId,\n                    onError: onError,\n                    edgeTypes: edgeTypes,\n                    disableKeyboardA11y: disableKeyboardA11y\n                }, id);\n            })\n        ]\n    });\n}\nEdgeRendererComponent.displayName = 'EdgeRenderer';\nconst EdgeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(EdgeRendererComponent);\nconst selector$9 = (s)=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$9);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__viewport xyflow__viewport react-flow__container\",\n        style: {\n            transform\n        },\n        children: children\n    });\n}\n/**\n * Hook for calling onInit handler.\n *\n * @internal\n */ function useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useOnInitHandler.useEffect\": ()=>{\n            if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n                setTimeout({\n                    \"useOnInitHandler.useEffect\": ()=>onInit(rfInstance)\n                }[\"useOnInitHandler.useEffect\"], 1);\n                isInitialized.current = true;\n            }\n        }\n    }[\"useOnInitHandler.useEffect\"], [\n        onInit,\n        rfInstance.viewportInitialized\n    ]);\n}\nconst selector$8 = (state)=>state.panZoom?.syncViewport;\n/**\n * Hook for syncing the viewport with the panzoom instance.\n *\n * @internal\n * @param viewport\n */ function useViewportSync(viewport) {\n    const syncViewport = useStore(selector$8);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useViewportSync.useEffect\": ()=>{\n            if (viewport) {\n                syncViewport?.(viewport);\n                store.setState({\n                    transform: [\n                        viewport.x,\n                        viewport.y,\n                        viewport.zoom\n                    ]\n                });\n            }\n        }\n    }[\"useViewportSync.useEffect\"], [\n        viewport,\n        syncViewport\n    ]);\n    return null;\n}\nfunction storeSelector$1(s) {\n    return s.connection.inProgress ? {\n        ...s.connection,\n        to: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.pointToRendererPoint)(s.connection.to, s.transform)\n    } : {\n        ...s.connection\n    };\n}\nfunction getSelector(connectionSelector) {\n    if (connectionSelector) {\n        const combinedSelector = (s)=>{\n            const connection = storeSelector$1(s);\n            return connectionSelector(connection);\n        };\n        return combinedSelector;\n    }\n    return storeSelector$1;\n}\n/**\n * Hook for accessing the connection state.\n *\n * @public\n * @returns ConnectionState\n */ function useConnection(connectionSelector) {\n    const combinedSelector = getSelector(connectionSelector);\n    return useStore(combinedSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n}\nconst selector$7 = (s)=>({\n        nodesConnectable: s.nodesConnectable,\n        isValid: s.connection.isValid,\n        inProgress: s.connection.inProgress,\n        width: s.width,\n        height: s.height\n    });\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodesConnectable, width, height, isValid, inProgress } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const renderConnection = !!(width && nodesConnectable && inProgress);\n    if (!renderConnection) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: containerStyle,\n        width: width,\n        height: height,\n        className: \"react-flow__connectionline react-flow__container\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                'react-flow__connection',\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getConnectionStatus)(isValid)\n            ]),\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLine, {\n                style: style,\n                type: type,\n                CustomComponent: component,\n                isValid: isValid\n            })\n        })\n    });\n}\nconst ConnectionLine = ({ style, type = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.Bezier, CustomComponent, isValid })=>{\n    const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition } = useConnection();\n    if (!inProgress) {\n        return;\n    }\n    if (CustomComponent) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomComponent, {\n            connectionLineType: type,\n            connectionLineStyle: style,\n            fromNode: fromNode,\n            fromHandle: fromHandle,\n            fromX: from.x,\n            fromY: from.y,\n            toX: to.x,\n            toY: to.y,\n            fromPosition: fromPosition,\n            toPosition: toPosition,\n            connectionStatus: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getConnectionStatus)(isValid),\n            toNode: toNode,\n            toHandle: toHandle\n        });\n    }\n    let path = '';\n    const pathParams = {\n        sourceX: from.x,\n        sourceY: from.y,\n        sourcePosition: fromPosition,\n        targetX: to.x,\n        targetY: to.y,\n        targetPosition: toPosition\n    };\n    switch(type){\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.Bezier:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierPath)(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.SimpleBezier:\n            [path] = getSimpleBezierPath(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.Step:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getSmoothStepPath)({\n                ...pathParams,\n                borderRadius: 0\n            });\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.SmoothStep:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getSmoothStepPath)(pathParams);\n            break;\n        default:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getStraightPath)(pathParams);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: path,\n        fill: \"none\",\n        className: \"react-flow__connection-path\",\n        style: style\n    });\n};\nConnectionLine.displayName = 'ConnectionLine';\nconst emptyTypes = {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {\n    const typesRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(nodeOrEdgeTypes);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useNodeOrEdgeTypesWarning.useEffect\": ()=>{\n            if (true) {\n                const usedKeys = new Set([\n                    ...Object.keys(typesRef.current),\n                    ...Object.keys(nodeOrEdgeTypes)\n                ]);\n                for (const key of usedKeys){\n                    if (typesRef.current[key] !== nodeOrEdgeTypes[key]) {\n                        store.getState().onError?.('002', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error002']());\n                        break;\n                    }\n                }\n                typesRef.current = nodeOrEdgeTypes;\n            }\n        }\n    }[\"useNodeOrEdgeTypesWarning.useEffect\"], [\n        nodeOrEdgeTypes\n    ]);\n}\nfunction useStylesLoadedWarning() {\n    const store = useStoreApi();\n    const checked = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useStylesLoadedWarning.useEffect\": ()=>{\n            if (true) {\n                if (!checked.current) {\n                    const pane = document.querySelector('.react-flow__pane');\n                    if (pane && !(window.getComputedStyle(pane).zIndex === '1')) {\n                        store.getState().onError?.('013', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error013']('react'));\n                    }\n                    checked.current = true;\n                }\n            }\n        }\n    }[\"useStylesLoadedWarning.useEffect\"], []);\n}\nfunction GraphViewComponent({ nodeTypes, edgeTypes, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {\n    useNodeOrEdgeTypesWarning(nodeTypes);\n    useNodeOrEdgeTypesWarning(edgeTypes);\n    useStylesLoadedWarning();\n    useOnInitHandler(onInit);\n    useViewportSync(viewport);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FlowRenderer, {\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        paneClickDistance: paneClickDistance,\n        deleteKeyCode: deleteKeyCode,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        onSelectionContextMenu: onSelectionContextMenu,\n        preventScrolling: preventScrolling,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y,\n        onViewportChange: onViewportChange,\n        isControlledViewport: !!viewport,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Viewport, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeRenderer, {\n                    edgeTypes: edgeTypes,\n                    onEdgeClick: onEdgeClick,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLineWrapper, {\n                    style: connectionLineStyle,\n                    type: connectionLineType,\n                    component: connectionLineComponent,\n                    containerStyle: connectionLineContainerStyle\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__edgelabel-renderer\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeRenderer, {\n                    nodeTypes: nodeTypes,\n                    onNodeClick: onNodeClick,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    nodeClickDistance: nodeClickDistance,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    noPanClassName: noPanClassName,\n                    noDragClassName: noDragClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__viewport-portal\"\n                })\n            ]\n        })\n    });\n}\nGraphViewComponent.displayName = 'GraphView';\nconst GraphView = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(GraphViewComponent);\nconst getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, nodeOrigin, nodeExtent } = {})=>{\n    const nodeLookup = new Map();\n    const parentLookup = new Map();\n    const connectionLookup = new Map();\n    const edgeLookup = new Map();\n    const storeEdges = defaultEdges ?? edges ?? [];\n    const storeNodes = defaultNodes ?? nodes ?? [];\n    const storeNodeOrigin = nodeOrigin ?? [\n        0,\n        0\n    ];\n    const storeNodeExtent = nodeExtent ?? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.infiniteExtent;\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.updateConnectionLookup)(connectionLookup, edgeLookup, storeEdges);\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.adoptUserNodes)(storeNodes, nodeLookup, parentLookup, {\n        nodeOrigin: storeNodeOrigin,\n        nodeExtent: storeNodeExtent,\n        elevateNodesOnSelect: false\n    });\n    let transform = [\n        0,\n        0,\n        1\n    ];\n    if (fitView && width && height) {\n        const bounds = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getInternalNodesBounds)(nodeLookup, {\n            filter: (node)=>!!((node.width || node.initialWidth) && (node.height || node.initialHeight))\n        });\n        const { x, y, zoom } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getViewportForBounds)(bounds, width, height, 0.5, 2, 0.1);\n        transform = [\n            x,\n            y,\n            zoom\n        ];\n    }\n    return {\n        rfId: '1',\n        width: 0,\n        height: 0,\n        transform,\n        nodes: storeNodes,\n        nodeLookup,\n        parentLookup,\n        edges: storeEdges,\n        edgeLookup,\n        connectionLookup,\n        onNodesChange: null,\n        onEdgesChange: null,\n        hasDefaultNodes: defaultNodes !== undefined,\n        hasDefaultEdges: defaultEdges !== undefined,\n        panZoom: null,\n        minZoom: 0.5,\n        maxZoom: 2,\n        translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.infiniteExtent,\n        nodeExtent: storeNodeExtent,\n        nodesSelectionActive: false,\n        userSelectionActive: false,\n        userSelectionRect: null,\n        connectionMode: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionMode.Strict,\n        domNode: null,\n        paneDragging: false,\n        noPanClassName: 'nopan',\n        nodeOrigin: storeNodeOrigin,\n        nodeDragThreshold: 1,\n        snapGrid: [\n            15,\n            15\n        ],\n        snapToGrid: false,\n        nodesDraggable: true,\n        nodesConnectable: true,\n        nodesFocusable: true,\n        edgesFocusable: true,\n        edgesReconnectable: true,\n        elementsSelectable: true,\n        elevateNodesOnSelect: true,\n        elevateEdgesOnSelect: false,\n        fitViewOnInit: false,\n        fitViewDone: false,\n        fitViewOnInitOptions: undefined,\n        selectNodesOnDrag: true,\n        multiSelectionActive: false,\n        connection: {\n            ..._xyflow_system__WEBPACK_IMPORTED_MODULE_2__.initialConnection\n        },\n        connectionClickStartHandle: null,\n        connectOnClick: true,\n        ariaLiveMessage: '',\n        autoPanOnConnect: true,\n        autoPanOnNodeDrag: true,\n        autoPanSpeed: 15,\n        connectionRadius: 20,\n        onError: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.devWarn,\n        isValidConnection: undefined,\n        onSelectionChangeHandlers: [],\n        lib: 'react',\n        debug: false\n    };\n};\nconst createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView: fitView$1, nodeOrigin, nodeExtent })=>(0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.createWithEqualityFn)((set, get)=>({\n            ...getInitialState({\n                nodes,\n                edges,\n                width,\n                height,\n                fitView: fitView$1,\n                nodeOrigin,\n                nodeExtent,\n                defaultNodes,\n                defaultEdges\n            }),\n            setNodes: (nodes)=>{\n                const { nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect } = get();\n                // setNodes() is called exclusively in response to user actions:\n                // - either when the `<ReactFlow nodes>` prop is updated in the controlled ReactFlow setup,\n                // - or when the user calls something like `reactFlowInstance.setNodes()` in an uncontrolled ReactFlow setup.\n                //\n                // When this happens, we take the note objects passed by the user and extend them with fields\n                // relevant for internal React Flow operations.\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: true\n                });\n                set({\n                    nodes\n                });\n            },\n            setEdges: (edges)=>{\n                const { connectionLookup, edgeLookup } = get();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.updateConnectionLookup)(connectionLookup, edgeLookup, edges);\n                set({\n                    edges\n                });\n            },\n            setDefaultNodesAndEdges: (nodes, edges)=>{\n                if (nodes) {\n                    const { setNodes } = get();\n                    setNodes(nodes);\n                    set({\n                        hasDefaultNodes: true\n                    });\n                }\n                if (edges) {\n                    const { setEdges } = get();\n                    setEdges(edges);\n                    set({\n                        hasDefaultEdges: true\n                    });\n                }\n            },\n            // Every node gets registerd at a ResizeObserver. Whenever a node\n            // changes its dimensions, this function is called to measure the\n            // new dimensions and update the nodes.\n            updateNodeInternals: (updates, params = {\n                triggerFitView: true\n            })=>{\n                const { triggerNodeChanges, nodeLookup, parentLookup, fitViewOnInit, fitViewDone, fitViewOnInitOptions, domNode, nodeOrigin, nodeExtent, debug, fitViewSync } = get();\n                const { changes, updatedInternals } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.updateNodeInternals)(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent);\n                if (!updatedInternals) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.updateAbsolutePositions)(nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent\n                });\n                if (params.triggerFitView) {\n                    // we call fitView once initially after all dimensions are set\n                    let nextFitViewDone = fitViewDone;\n                    if (!fitViewDone && fitViewOnInit) {\n                        nextFitViewDone = fitViewSync({\n                            ...fitViewOnInitOptions,\n                            nodes: fitViewOnInitOptions?.nodes\n                        });\n                    }\n                    // here we are cirmumventing the onNodesChange handler\n                    // in order to be able to display nodes even if the user\n                    // has not provided an onNodesChange handler.\n                    // Nodes are only rendered if they have a width and height\n                    // attribute which they get from this handler.\n                    set({\n                        fitViewDone: nextFitViewDone\n                    });\n                } else {\n                    // we always want to trigger useStore calls whenever updateNodeInternals is called\n                    set({});\n                }\n                if (changes?.length > 0) {\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    triggerNodeChanges?.(changes);\n                }\n            },\n            updateNodePositions: (nodeDragItems, dragging = false)=>{\n                const parentExpandChildren = [];\n                const changes = [];\n                for (const [id, dragItem] of nodeDragItems){\n                    const expandParent = !!(dragItem?.expandParent && dragItem?.parentId && dragItem?.position);\n                    const change = {\n                        id,\n                        type: 'position',\n                        position: expandParent ? {\n                            x: Math.max(0, dragItem.position.x),\n                            y: Math.max(0, dragItem.position.y)\n                        } : dragItem.position,\n                        dragging\n                    };\n                    if (expandParent) {\n                        parentExpandChildren.push({\n                            id,\n                            parentId: dragItem.parentId,\n                            rect: {\n                                ...dragItem.internals.positionAbsolute,\n                                width: dragItem.measured.width,\n                                height: dragItem.measured.height\n                            }\n                        });\n                    }\n                    changes.push(change);\n                }\n                if (parentExpandChildren.length > 0) {\n                    const { nodeLookup, parentLookup, nodeOrigin } = get();\n                    const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleExpandParent)(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n                    changes.push(...parentExpandChanges);\n                }\n                get().triggerNodeChanges(changes);\n            },\n            triggerNodeChanges: (changes)=>{\n                const { onNodesChange, setNodes, nodes, hasDefaultNodes, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultNodes) {\n                        const updatedNodes = applyNodeChanges(changes, nodes);\n                        setNodes(updatedNodes);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    onNodesChange?.(changes);\n                }\n            },\n            triggerEdgeChanges: (changes)=>{\n                const { onEdgesChange, setEdges, edges, hasDefaultEdges, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultEdges) {\n                        const updatedEdges = applyEdgeChanges(changes, edges);\n                        setEdges(updatedEdges);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger edge changes', changes);\n                    }\n                    onEdgesChange?.(changes);\n                }\n            },\n            addSelectedNodes: (selectedNodeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const nodeChanges = selectedNodeIds.map((nodeId)=>createSelectionChange(nodeId, true));\n                    triggerNodeChanges(nodeChanges);\n                    return;\n                }\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set([\n                    ...selectedNodeIds\n                ]), true));\n                triggerEdgeChanges(getSelectionChanges(edgeLookup));\n            },\n            addSelectedEdges: (selectedEdgeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const changedEdges = selectedEdgeIds.map((edgeId)=>createSelectionChange(edgeId, true));\n                    triggerEdgeChanges(changedEdges);\n                    return;\n                }\n                triggerEdgeChanges(getSelectionChanges(edgeLookup, new Set([\n                    ...selectedEdgeIds\n                ])));\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set(), true));\n            },\n            unselectNodesAndEdges: ({ nodes, edges } = {})=>{\n                const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodesToUnselect = nodes ? nodes : storeNodes;\n                const edgesToUnselect = edges ? edges : storeEdges;\n                const nodeChanges = nodesToUnselect.map((n)=>{\n                    const internalNode = nodeLookup.get(n.id);\n                    if (internalNode) {\n                        // we need to unselect the internal node that was selected previously before we\n                        // send the change to the user to prevent it to be selected while dragging the new node\n                        internalNode.selected = false;\n                    }\n                    return createSelectionChange(n.id, false);\n                });\n                const edgeChanges = edgesToUnselect.map((edge)=>createSelectionChange(edge.id, false));\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setMinZoom: (minZoom)=>{\n                const { panZoom, maxZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    minZoom\n                });\n            },\n            setMaxZoom: (maxZoom)=>{\n                const { panZoom, minZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    maxZoom\n                });\n            },\n            setTranslateExtent: (translateExtent)=>{\n                get().panZoom?.setTranslateExtent(translateExtent);\n                set({\n                    translateExtent\n                });\n            },\n            setPaneClickDistance: (clickDistance)=>{\n                get().panZoom?.setClickDistance(clickDistance);\n            },\n            resetSelectedElements: ()=>{\n                const { edges, nodes, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodeChanges = nodes.reduce((res, node)=>node.selected ? [\n                        ...res,\n                        createSelectionChange(node.id, false)\n                    ] : res, []);\n                const edgeChanges = edges.reduce((res, edge)=>edge.selected ? [\n                        ...res,\n                        createSelectionChange(edge.id, false)\n                    ] : res, []);\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setNodeExtent: (nextNodeExtent)=>{\n                const { nodes, nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, nodeExtent } = get();\n                if (nextNodeExtent[0][0] === nodeExtent[0][0] && nextNodeExtent[0][1] === nodeExtent[0][1] && nextNodeExtent[1][0] === nodeExtent[1][0] && nextNodeExtent[1][1] === nodeExtent[1][1]) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent: nextNodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: false\n                });\n                set({\n                    nodeExtent: nextNodeExtent\n                });\n            },\n            panBy: (delta)=>{\n                const { transform, width, height, panZoom, translateExtent } = get();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.panBy)({\n                    delta,\n                    panZoom,\n                    transform,\n                    translateExtent,\n                    width,\n                    height\n                });\n            },\n            fitView: (options)=>{\n                const { panZoom, width, height, minZoom, maxZoom, nodeLookup } = get();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                const fitViewNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getFitViewNodes)(nodeLookup, options);\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.fitView)({\n                    nodes: fitViewNodes,\n                    width,\n                    height,\n                    panZoom,\n                    minZoom,\n                    maxZoom\n                }, options);\n            },\n            // we can't call an asnychronous function in updateNodeInternals\n            // for that we created this sync version of fitView\n            fitViewSync: (options)=>{\n                const { panZoom, width, height, minZoom, maxZoom, nodeLookup } = get();\n                if (!panZoom) {\n                    return false;\n                }\n                const fitViewNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getFitViewNodes)(nodeLookup, options);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.fitView)({\n                    nodes: fitViewNodes,\n                    width,\n                    height,\n                    panZoom,\n                    minZoom,\n                    maxZoom\n                }, options);\n                return fitViewNodes.size > 0;\n            },\n            cancelConnection: ()=>{\n                set({\n                    connection: {\n                        ..._xyflow_system__WEBPACK_IMPORTED_MODULE_2__.initialConnection\n                    }\n                });\n            },\n            updateConnection: (connection)=>{\n                set({\n                    connection\n                });\n            },\n            reset: ()=>set({\n                    ...getInitialState()\n                })\n        }), Object.is);\nfunction ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, fitView, nodeOrigin, nodeExtent, children }) {\n    const [store] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        \"ReactFlowProvider.useState\": ()=>createStore({\n                nodes,\n                edges,\n                defaultNodes,\n                defaultEdges,\n                width,\n                height,\n                fitView,\n                nodeOrigin,\n                nodeExtent\n            })\n    }[\"ReactFlowProvider.useState\"]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider$1, {\n        value: store,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchProvider, {\n            children: children\n        })\n    });\n}\nfunction Wrapper({ children, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, nodeOrigin, nodeExtent }) {\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(StoreContext);\n    if (isWrapped) {\n        // we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n        // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: children\n        });\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactFlowProvider, {\n        initialNodes: nodes,\n        initialEdges: edges,\n        defaultNodes: defaultNodes,\n        defaultEdges: defaultEdges,\n        initialWidth: width,\n        initialHeight: height,\n        fitView: fitView,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent,\n        children: children\n    });\n}\nconst wrapperStyle = {\n    width: '100%',\n    height: '100%',\n    overflow: 'hidden',\n    position: 'relative',\n    zIndex: 0\n};\nfunction ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes, edgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = 'Backspace', selectionKeyCode = 'Shift', selectionOnDrag = false, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.SelectionMode.Full, panActivationKeyCode = 'Space', multiSelectionKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isMacOs)() ? 'Meta' : 'Control', zoomActivationKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isMacOs)() ? 'Meta' : 'Control', snapToGrid, snapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag, nodesDraggable, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = true, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = '#b1b1b7', zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 0, nodeClickDistance = 0, children, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = 'nodrag', noWheelClassName = 'nowheel', noPanClassName = 'nopan', fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect, elevateEdgesOnSelect, disableKeyboardA11y = false, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style, id, nodeDragThreshold, viewport, onViewportChange, width, height, colorMode = 'light', debug, ...rest }, ref) {\n    const rfId = id || '1';\n    const colorModeClassName = useColorModeClass(colorMode);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-testid\": \"rf__wrapper\",\n        ...rest,\n        style: {\n            ...style,\n            ...wrapperStyle\n        },\n        ref: ref,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow',\n            className,\n            colorModeClassName\n        ]),\n        id: id,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Wrapper, {\n            nodes: nodes,\n            edges: edges,\n            width: width,\n            height: height,\n            fitView: fitView,\n            nodeOrigin: nodeOrigin,\n            nodeExtent: nodeExtent,\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(GraphView, {\n                    onInit: onInit,\n                    onNodeClick: onNodeClick,\n                    onEdgeClick: onEdgeClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    nodeTypes: nodeTypes,\n                    edgeTypes: edgeTypes,\n                    connectionLineType: connectionLineType,\n                    connectionLineStyle: connectionLineStyle,\n                    connectionLineComponent: connectionLineComponent,\n                    connectionLineContainerStyle: connectionLineContainerStyle,\n                    selectionKeyCode: selectionKeyCode,\n                    selectionOnDrag: selectionOnDrag,\n                    selectionMode: selectionMode,\n                    deleteKeyCode: deleteKeyCode,\n                    multiSelectionKeyCode: multiSelectionKeyCode,\n                    panActivationKeyCode: panActivationKeyCode,\n                    zoomActivationKeyCode: zoomActivationKeyCode,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    defaultViewport: defaultViewport$1,\n                    translateExtent: translateExtent,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    preventScrolling: preventScrolling,\n                    zoomOnScroll: zoomOnScroll,\n                    zoomOnPinch: zoomOnPinch,\n                    zoomOnDoubleClick: zoomOnDoubleClick,\n                    panOnScroll: panOnScroll,\n                    panOnScrollSpeed: panOnScrollSpeed,\n                    panOnScrollMode: panOnScrollMode,\n                    panOnDrag: panOnDrag,\n                    onPaneClick: onPaneClick,\n                    onPaneMouseEnter: onPaneMouseEnter,\n                    onPaneMouseMove: onPaneMouseMove,\n                    onPaneMouseLeave: onPaneMouseLeave,\n                    onPaneScroll: onPaneScroll,\n                    onPaneContextMenu: onPaneContextMenu,\n                    paneClickDistance: paneClickDistance,\n                    nodeClickDistance: nodeClickDistance,\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    onSelectionStart: onSelectionStart,\n                    onSelectionEnd: onSelectionEnd,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noDragClassName: noDragClassName,\n                    noWheelClassName: noWheelClassName,\n                    noPanClassName: noPanClassName,\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    viewport: viewport,\n                    onViewportChange: onViewportChange\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StoreUpdater, {\n                    nodes: nodes,\n                    edges: edges,\n                    defaultNodes: defaultNodes,\n                    defaultEdges: defaultEdges,\n                    onConnect: onConnect,\n                    onConnectStart: onConnectStart,\n                    onConnectEnd: onConnectEnd,\n                    onClickConnectStart: onClickConnectStart,\n                    onClickConnectEnd: onClickConnectEnd,\n                    nodesDraggable: nodesDraggable,\n                    nodesConnectable: nodesConnectable,\n                    nodesFocusable: nodesFocusable,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    elevateNodesOnSelect: elevateNodesOnSelect,\n                    elevateEdgesOnSelect: elevateEdgesOnSelect,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    nodeExtent: nodeExtent,\n                    onNodesChange: onNodesChange,\n                    onEdgesChange: onEdgesChange,\n                    snapToGrid: snapToGrid,\n                    snapGrid: snapGrid,\n                    connectionMode: connectionMode,\n                    translateExtent: translateExtent,\n                    connectOnClick: connectOnClick,\n                    defaultEdgeOptions: defaultEdgeOptions,\n                    fitView: fitView,\n                    fitViewOptions: fitViewOptions,\n                    onNodesDelete: onNodesDelete,\n                    onEdgesDelete: onEdgesDelete,\n                    onDelete: onDelete,\n                    onNodeDragStart: onNodeDragStart,\n                    onNodeDrag: onNodeDrag,\n                    onNodeDragStop: onNodeDragStop,\n                    onSelectionDrag: onSelectionDrag,\n                    onSelectionDragStart: onSelectionDragStart,\n                    onSelectionDragStop: onSelectionDragStop,\n                    onMove: onMove,\n                    onMoveStart: onMoveStart,\n                    onMoveEnd: onMoveEnd,\n                    noPanClassName: noPanClassName,\n                    nodeOrigin: nodeOrigin,\n                    rfId: rfId,\n                    autoPanOnConnect: autoPanOnConnect,\n                    autoPanOnNodeDrag: autoPanOnNodeDrag,\n                    autoPanSpeed: autoPanSpeed,\n                    onError: onError,\n                    connectionRadius: connectionRadius,\n                    isValidConnection: isValidConnection,\n                    selectNodesOnDrag: selectNodesOnDrag,\n                    nodeDragThreshold: nodeDragThreshold,\n                    onBeforeDelete: onBeforeDelete,\n                    paneClickDistance: paneClickDistance,\n                    debug: debug\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListener, {\n                    onSelectionChange: onSelectionChange\n                }),\n                children,\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Attribution, {\n                    proOptions: proOptions,\n                    position: attributionPosition\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(A11yDescriptions, {\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\nvar index = fixedForwardRef(ReactFlow);\nconst selector$6 = (s)=>s.domNode?.querySelector('.react-flow__edgelabel-renderer');\nfunction EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$6);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, edgeLabelRenderer);\n}\nconst selector$5 = (s)=>s.domNode?.querySelector('.react-flow__viewport-portal');\nfunction ViewportPortal({ children }) {\n    const viewPortalDiv = useStore(selector$5);\n    if (!viewPortalDiv) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, viewPortalDiv);\n}\n/**\n * Hook for updating node internals.\n *\n * @public\n * @returns function for updating node internals\n */ function useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useUpdateNodeInternals.useCallback\": (id)=>{\n            const { domNode, updateNodeInternals } = store.getState();\n            const updateIds = Array.isArray(id) ? id : [\n                id\n            ];\n            const updates = new Map();\n            updateIds.forEach({\n                \"useUpdateNodeInternals.useCallback\": (updateId)=>{\n                    const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n                    if (nodeElement) {\n                        updates.set(updateId, {\n                            id: updateId,\n                            nodeElement,\n                            force: true\n                        });\n                    }\n                }\n            }[\"useUpdateNodeInternals.useCallback\"]);\n            requestAnimationFrame({\n                \"useUpdateNodeInternals.useCallback\": ()=>updateNodeInternals(updates, {\n                        triggerFitView: false\n                    })\n            }[\"useUpdateNodeInternals.useCallback\"]);\n        }\n    }[\"useUpdateNodeInternals.useCallback\"], []);\n}\nconst nodesSelector = (state)=>state.nodes;\n/**\n * Hook for getting the current nodes from the store.\n *\n * @public\n * @returns An array of nodes\n */ function useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodes;\n}\nconst edgesSelector = (state)=>state.edges;\n/**\n * Hook for getting the current edges from the store.\n *\n * @public\n * @returns An array of edges\n */ function useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edges;\n}\nconst viewportSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2]\n    });\n/**\n * Hook for getting the current viewport from the store.\n *\n * @public\n * @returns The current viewport\n */ function useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return viewport;\n}\n/**\n * Hook for managing the state of nodes - should only be used for prototyping / simple use cases.\n *\n * @public\n * @param initialNodes\n * @returns an array [nodes, setNodes, onNodesChange]\n */ function useNodesState(initialNodes) {\n    const [nodes, setNodes] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(initialNodes);\n    const onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useNodesState.useCallback[onNodesChange]\": (changes)=>setNodes({\n                \"useNodesState.useCallback[onNodesChange]\": (nds)=>applyNodeChanges(changes, nds)\n            }[\"useNodesState.useCallback[onNodesChange]\"])\n    }[\"useNodesState.useCallback[onNodesChange]\"], []);\n    return [\n        nodes,\n        setNodes,\n        onNodesChange\n    ];\n}\n/**\n * Hook for managing the state of edges - should only be used for prototyping / simple use cases.\n *\n * @public\n * @param initialEdges\n * @returns an array [edges, setEdges, onEdgesChange]\n */ function useEdgesState(initialEdges) {\n    const [edges, setEdges] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(initialEdges);\n    const onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useEdgesState.useCallback[onEdgesChange]\": (changes)=>setEdges({\n                \"useEdgesState.useCallback[onEdgesChange]\": (eds)=>applyEdgeChanges(changes, eds)\n            }[\"useEdgesState.useCallback[onEdgesChange]\"])\n    }[\"useEdgesState.useCallback[onEdgesChange]\"], []);\n    return [\n        edges,\n        setEdges,\n        onEdgesChange\n    ];\n}\n/**\n * Hook for registering an onViewportChange handler.\n *\n * @public\n * @param params.onStart - gets called when the viewport starts changing\n * @param params.onChange - gets called when the viewport changes\n * @param params.onEnd - gets called when the viewport stops changing\n */ function useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeStart: onStart\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChange: onChange\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeEnd: onEnd\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onEnd\n    ]);\n}\n/**\n * Hook for registering an onSelectionChange handler.\n *\n * @public\n * @param params.onChange - The handler to register\n */ function useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useOnSelectionChange.useEffect\": ()=>{\n            const nextOnSelectionChangeHandlers = [\n                ...store.getState().onSelectionChangeHandlers,\n                onChange\n            ];\n            store.setState({\n                onSelectionChangeHandlers: nextOnSelectionChangeHandlers\n            });\n            return ({\n                \"useOnSelectionChange.useEffect\": ()=>{\n                    const nextHandlers = store.getState().onSelectionChangeHandlers.filter({\n                        \"useOnSelectionChange.useEffect.nextHandlers\": (fn)=>fn !== onChange\n                    }[\"useOnSelectionChange.useEffect.nextHandlers\"]);\n                    store.setState({\n                        onSelectionChangeHandlers: nextHandlers\n                    });\n                }\n            })[\"useOnSelectionChange.useEffect\"];\n        }\n    }[\"useOnSelectionChange.useEffect\"], [\n        onChange\n    ]);\n}\nconst selector$4 = (options)=>(s)=>{\n        if (s.nodeLookup.size === 0) {\n            return false;\n        }\n        for (const [, { hidden, internals }] of s.nodeLookup){\n            if (options.includeHiddenNodes || !hidden) {\n                if (internals.handleBounds === undefined || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeHasDimensions)(internals.userNode)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\nconst defaultOptions = {\n    includeHiddenNodes: false\n};\n/**\n * Hook which returns true when all nodes are initialized.\n *\n * @public\n * @param options.includeHiddenNodes - defaults to false\n * @returns boolean indicating whether all nodes are initialized\n */ function useNodesInitialized(options = defaultOptions) {\n    const initialized = useStore(selector$4(options));\n    return initialized;\n}\n/**\n * Hook to check if a <Handle /> is connected to another <Handle /> and get the connections.\n *\n * @public\n * @deprecated Use `useNodeConnections` instead.\n * @param param.type - handle type 'source' or 'target'\n * @param param.nodeId - node id - if not provided, the node id from the NodeIdContext is used\n * @param param.id - the handle id (this is only needed if the node has multiple handles of the same type)\n * @param param.onConnect - gets called when a connection is established\n * @param param.onDisconnect - gets called when a connection is removed\n * @returns an array with handle connections\n */ function useHandleConnections({ type, id, nodeId, onConnect, onDisconnect }) {\n    console.warn('[DEPRECATED] `useHandleConnections` is deprecated. Instead use `useNodeConnections` https://reactflow.dev/api-reference/hooks/useNodeConnections');\n    const _nodeId = useNodeId();\n    const currentNodeId = nodeId ?? _nodeId;\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const connections = useStore({\n        \"useHandleConnections.useStore[connections]\": (state)=>state.connectionLookup.get(`${currentNodeId}-${type}${id ? `-${id}` : ''}`)\n    }[\"useHandleConnections.useStore[connections]\"], _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useHandleConnections.useEffect\": ()=>{\n            // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n            if (prevConnections.current && prevConnections.current !== connections) {\n                const _connections = connections ?? new Map();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n            }\n            prevConnections.current = connections ?? new Map();\n        }\n    }[\"useHandleConnections.useEffect\"], [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useHandleConnections.useMemo\": ()=>Array.from(connections?.values() ?? [])\n    }[\"useHandleConnections.useMemo\"], [\n        connections\n    ]);\n}\nconst error014 = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error014']();\n/**\n * Hook to retrieve all edges connected to a node. Can be filtered by handle type and id.\n *\n * @public\n * @param param.id - node id - optional if called inside a custom node\n * @param param.handleType - filter by handle type 'source' or 'target'\n * @param param.handleId - filter by handle id (this is only needed if the node has multiple handles of the same type)\n * @param param.onConnect - gets called when a connection is established\n * @param param.onDisconnect - gets called when a connection is removed\n * @returns an array with connections\n */ function useNodeConnections({ id, handleType, handleId, onConnect, onDisconnect } = {}) {\n    const nodeId = useNodeId();\n    const currentNodeId = id ?? nodeId;\n    if (!currentNodeId) {\n        throw new Error(error014);\n    }\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const connections = useStore({\n        \"useNodeConnections.useStore[connections]\": (state)=>state.connectionLookup.get(`${currentNodeId}${handleType ? handleId ? `-${handleType}-${handleId}` : `-${handleType}` : ''}`)\n    }[\"useNodeConnections.useStore[connections]\"], _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"useNodeConnections.useEffect\": ()=>{\n            // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n            if (prevConnections.current && prevConnections.current !== connections) {\n                const _connections = connections ?? new Map();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n            }\n            prevConnections.current = connections ?? new Map();\n        }\n    }[\"useNodeConnections.useEffect\"], [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)({\n        \"useNodeConnections.useMemo\": ()=>Array.from(connections?.values() ?? [])\n    }[\"useNodeConnections.useMemo\"], [\n        connections\n    ]);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodesData(nodeIds) {\n    const nodesData = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useNodesData.useStore[nodesData]\": (s)=>{\n            const data = [];\n            const isArrayOfIds = Array.isArray(nodeIds);\n            const _nodeIds = isArrayOfIds ? nodeIds : [\n                nodeIds\n            ];\n            for (const nodeId of _nodeIds){\n                const node = s.nodeLookup.get(nodeId);\n                if (node) {\n                    data.push({\n                        id: node.id,\n                        type: node.type,\n                        data: node.data\n                    });\n                }\n            }\n            return isArrayOfIds ? data : data[0] ?? null;\n        }\n    }[\"useNodesData.useStore[nodesData]\"], [\n        nodeIds\n    ]), _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.shallowNodeData);\n    return nodesData;\n}\n/**\n * Hook for getting an internal node by id\n *\n * @public\n * @param id - id of the node\n * @returns array with visible node ids\n */ function useInternalNode(id) {\n    const node = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"useInternalNode.useStore[node]\": (s)=>s.nodeLookup.get(id)\n    }[\"useInternalNode.useStore[node]\"], [\n        id\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return node;\n}\nfunction LinePattern({ dimensions, lineWidth, variant, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        strokeWidth: lineWidth,\n        d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__background-pattern',\n            variant,\n            className\n        ])\n    });\n}\nfunction DotPattern({ radius, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: radius,\n        cy: radius,\n        r: radius,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__background-pattern',\n            'dots',\n            className\n        ])\n    });\n}\nvar BackgroundVariant;\n(function(BackgroundVariant) {\n    BackgroundVariant[\"Lines\"] = \"lines\";\n    BackgroundVariant[\"Dots\"] = \"dots\";\n    BackgroundVariant[\"Cross\"] = \"cross\";\n})(BackgroundVariant || (BackgroundVariant = {}));\nconst defaultSize = {\n    [BackgroundVariant.Dots]: 1,\n    [BackgroundVariant.Lines]: 1,\n    [BackgroundVariant.Cross]: 6\n};\nconst selector$3 = (s)=>({\n        transform: s.transform,\n        patternId: `pattern-${s.rfId}`\n    });\nfunction BackgroundComponent({ id, variant = BackgroundVariant.Dots, // only used for dots and cross\ngap = 20, // only used for lines and cross\nsize, lineWidth = 1, offset = 0, color, bgColor, style, className, patternClassName }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const { transform, patternId } = useStore(selector$3, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const patternSize = size || defaultSize[variant];\n    const isDots = variant === BackgroundVariant.Dots;\n    const isCross = variant === BackgroundVariant.Cross;\n    const gapXY = Array.isArray(gap) ? gap : [\n        gap,\n        gap\n    ];\n    const scaledGap = [\n        gapXY[0] * transform[2] || 1,\n        gapXY[1] * transform[2] || 1\n    ];\n    const scaledSize = patternSize * transform[2];\n    const offsetXY = Array.isArray(offset) ? offset : [\n        offset,\n        offset\n    ];\n    const patternDimensions = isCross ? [\n        scaledSize,\n        scaledSize\n    ] : scaledGap;\n    const scaledOffset = [\n        offsetXY[0] * transform[2] || 1 + patternDimensions[0] / 2,\n        offsetXY[1] * transform[2] || 1 + patternDimensions[1] / 2\n    ];\n    const _patternId = `${patternId}${id ? id : ''}`;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__background',\n            className\n        ]),\n        style: {\n            ...style,\n            ...containerStyle,\n            '--xy-background-color-props': bgColor,\n            '--xy-background-pattern-color-props': color\n        },\n        ref: ref,\n        \"data-testid\": \"rf__background\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pattern\", {\n                id: _patternId,\n                x: transform[0] % scaledGap[0],\n                y: transform[1] % scaledGap[1],\n                width: scaledGap[0],\n                height: scaledGap[1],\n                patternUnits: \"userSpaceOnUse\",\n                patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`,\n                children: isDots ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DotPattern, {\n                    radius: scaledSize / 2,\n                    className: patternClassName\n                }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinePattern, {\n                    dimensions: patternDimensions,\n                    lineWidth: lineWidth,\n                    variant: variant,\n                    className: patternClassName\n                })\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"0\",\n                y: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                fill: `url(#${_patternId})`\n            })\n        ]\n    });\n}\nBackgroundComponent.displayName = 'Background';\nconst Background = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(BackgroundComponent);\nfunction PlusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z\"\n        })\n    });\n}\nfunction MinusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 5\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M0 0h32v4.2H0z\"\n        })\n    });\n}\nfunction FitViewIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 30\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z\"\n        })\n    });\n}\nfunction LockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z\"\n        })\n    });\n}\nfunction UnlockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z\"\n        })\n    });\n}\nfunction ControlButton({ children, className, ...rest }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n        type: \"button\",\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__controls-button',\n            className\n        ]),\n        ...rest,\n        children: children\n    });\n}\nconst selector$2 = (s)=>({\n        isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,\n        minZoomReached: s.transform[2] <= s.minZoom,\n        maxZoomReached: s.transform[2] >= s.maxZoom\n    });\nfunction ControlsComponent({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = 'bottom-left', orientation = 'vertical', 'aria-label': ariaLabel = 'React Flow controls' }) {\n    const store = useStoreApi();\n    const { isInteractive, minZoomReached, maxZoomReached } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { zoomIn, zoomOut, fitView } = useReactFlow();\n    const onZoomInHandler = ()=>{\n        zoomIn();\n        onZoomIn?.();\n    };\n    const onZoomOutHandler = ()=>{\n        zoomOut();\n        onZoomOut?.();\n    };\n    const onFitViewHandler = ()=>{\n        fitView(fitViewOptions);\n        onFitView?.();\n    };\n    const onToggleInteractivity = ()=>{\n        store.setState({\n            nodesDraggable: !isInteractive,\n            nodesConnectable: !isInteractive,\n            elementsSelectable: !isInteractive\n        });\n        onInteractiveChange?.(!isInteractive);\n    };\n    const orientationClass = orientation === 'horizontal' ? 'horizontal' : 'vertical';\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Panel, {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__controls',\n            orientationClass,\n            className\n        ]),\n        position: position,\n        style: style,\n        \"data-testid\": \"rf__controls\",\n        \"aria-label\": ariaLabel,\n        children: [\n            showZoom && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomInHandler,\n                        className: \"react-flow__controls-zoomin\",\n                        title: \"zoom in\",\n                        \"aria-label\": \"zoom in\",\n                        disabled: maxZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PlusIcon, {})\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomOutHandler,\n                        className: \"react-flow__controls-zoomout\",\n                        title: \"zoom out\",\n                        \"aria-label\": \"zoom out\",\n                        disabled: minZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MinusIcon, {})\n                    })\n                ]\n            }),\n            showFitView && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-fitview\",\n                onClick: onFitViewHandler,\n                title: \"fit view\",\n                \"aria-label\": \"fit view\",\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FitViewIcon, {})\n            }),\n            showInteractive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-interactive\",\n                onClick: onToggleInteractivity,\n                title: \"toggle interactivity\",\n                \"aria-label\": \"toggle interactivity\",\n                children: isInteractive ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnlockIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LockIcon, {})\n            }),\n            children\n        ]\n    });\n}\nControlsComponent.displayName = 'Controls';\nconst Controls = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(ControlsComponent);\nfunction MiniMapNodeComponent({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected, onClick }) {\n    const { background, backgroundColor } = style || {};\n    const fill = color || background || backgroundColor;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__minimap-node',\n            {\n                selected\n            },\n            className\n        ]),\n        x: x,\n        y: y,\n        rx: borderRadius,\n        ry: borderRadius,\n        width: width,\n        height: height,\n        style: {\n            fill,\n            stroke: strokeColor,\n            strokeWidth\n        },\n        shapeRendering: shapeRendering,\n        onClick: onClick ? (event)=>onClick(event, id) : undefined\n    });\n}\nconst MiniMapNode = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(MiniMapNodeComponent);\nconst selectorNodeIds = (s)=>s.nodes.map((node)=>node.id);\nconst getAttrFunction = (func)=>func instanceof Function ? func : ()=>func;\nfunction MiniMapNodes({ nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, // We need to rename the prop to be `CapitalCase` so that JSX will render it as\n// a component properly.\nnodeComponent: NodeComponent = MiniMapNode, onClick }) {\n    const nodeIds = useStore(selectorNodeIds, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const shapeRendering =  true ? 'crispEdges' : 0;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: nodeIds.map((nodeId)=>// The split of responsibilities between MiniMapNodes and\n            // NodeComponentWrapper may appear weird. However, it’s designed to\n            // minimize the cost of updates when individual nodes change.\n            //\n            // For more details, see a similar commit in `NodeRenderer/index.tsx`.\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponentWrapper, {\n                id: nodeId,\n                nodeColorFunc: nodeColorFunc,\n                nodeStrokeColorFunc: nodeStrokeColorFunc,\n                nodeClassNameFunc: nodeClassNameFunc,\n                nodeBorderRadius: nodeBorderRadius,\n                nodeStrokeWidth: nodeStrokeWidth,\n                NodeComponent: NodeComponent,\n                onClick: onClick,\n                shapeRendering: shapeRendering\n            }, nodeId))\n    });\n}\nfunction NodeComponentWrapperInner({ id, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {\n    const { node, x, y, width, height } = useStore({\n        \"NodeComponentWrapperInner.useStore\": (s)=>{\n            const node = s.nodeLookup.get(id);\n            const { x, y } = node.internals.positionAbsolute;\n            const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodeDimensions)(node);\n            return {\n                node,\n                x,\n                y,\n                width,\n                height\n            };\n        }\n    }[\"NodeComponentWrapperInner.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!node || node.hidden || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeHasDimensions)(node)) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        style: node.style,\n        selected: !!node.selected,\n        className: nodeClassNameFunc(node),\n        color: nodeColorFunc(node),\n        borderRadius: nodeBorderRadius,\n        strokeColor: nodeStrokeColorFunc(node),\n        strokeWidth: nodeStrokeWidth,\n        shapeRendering: shapeRendering,\n        onClick: onClick,\n        id: node.id\n    });\n}\nconst NodeComponentWrapper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(NodeComponentWrapperInner);\nvar MiniMapNodes$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(MiniMapNodes);\nconst defaultWidth = 200;\nconst defaultHeight = 150;\nconst selector$1 = (s)=>{\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2]\n    };\n    return {\n        viewBB,\n        boundingRect: s.nodeLookup.size > 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBoundsOfRects)((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getInternalNodesBounds)(s.nodeLookup), viewBB) : viewBB,\n        rfId: s.rfId,\n        panZoom: s.panZoom,\n        translateExtent: s.translateExtent,\n        flowWidth: s.width,\n        flowHeight: s.height\n    };\n};\nconst ARIA_LABEL_KEY = 'react-flow__minimap-desc';\nfunction MiniMapComponent({ style, className, nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, // We need to rename the prop to be `CapitalCase` so that JSX will render it as\n// a component properly.\nnodeComponent, bgColor, maskColor, maskStrokeColor, maskStrokeWidth, position = 'bottom-right', onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel = 'React Flow mini map', inversePan, zoomStep = 10, offsetScale = 5 }) {\n    const store = useStoreApi();\n    const svg = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight } = useStore(selector$1, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = offsetScale * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);\n    const minimapInstance = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    viewScaleRef.current = viewScale;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            if (svg.current && panZoom) {\n                minimapInstance.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYMinimap)({\n                    domNode: svg.current,\n                    panZoom,\n                    getTransform: {\n                        \"MiniMapComponent.useEffect\": ()=>store.getState().transform\n                    }[\"MiniMapComponent.useEffect\"],\n                    getViewScale: {\n                        \"MiniMapComponent.useEffect\": ()=>viewScaleRef.current\n                    }[\"MiniMapComponent.useEffect\"]\n                });\n                return ({\n                    \"MiniMapComponent.useEffect\": ()=>{\n                        minimapInstance.current?.destroy();\n                    }\n                })[\"MiniMapComponent.useEffect\"];\n            }\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        panZoom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            minimapInstance.current?.update({\n                translateExtent,\n                width: flowWidth,\n                height: flowHeight,\n                inversePan,\n                pannable,\n                zoomStep,\n                zoomable\n            });\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        pannable,\n        zoomable,\n        inversePan,\n        zoomStep,\n        translateExtent,\n        flowWidth,\n        flowHeight\n    ]);\n    const onSvgClick = onClick ? (event)=>{\n        const [x, y] = minimapInstance.current?.pointer(event) || [\n            0,\n            0\n        ];\n        onClick(event, {\n            x,\n            y\n        });\n    } : undefined;\n    const onSvgNodeClick = onNodeClick ? (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"MiniMapComponent.useCallback\": (event, nodeId)=>{\n            const node = store.getState().nodeLookup.get(nodeId);\n            onNodeClick(event, node);\n        }\n    }[\"MiniMapComponent.useCallback\"], []) : undefined;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        style: {\n            ...style,\n            '--xy-minimap-background-color-props': typeof bgColor === 'string' ? bgColor : undefined,\n            '--xy-minimap-mask-background-color-props': typeof maskColor === 'string' ? maskColor : undefined,\n            '--xy-minimap-mask-stroke-color-props': typeof maskStrokeColor === 'string' ? maskStrokeColor : undefined,\n            '--xy-minimap-mask-stroke-width-props': typeof maskStrokeWidth === 'number' ? maskStrokeWidth * viewScale : undefined,\n            '--xy-minimap-node-background-color-props': typeof nodeColor === 'string' ? nodeColor : undefined,\n            '--xy-minimap-node-stroke-color-props': typeof nodeStrokeColor === 'string' ? nodeStrokeColor : undefined,\n            '--xy-minimap-node-stroke-width-props': typeof nodeStrokeWidth === 'string' ? nodeStrokeWidth : undefined\n        },\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__minimap',\n            className\n        ]),\n        \"data-testid\": \"rf__minimap\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n            width: elementWidth,\n            height: elementHeight,\n            viewBox: `${x} ${y} ${width} ${height}`,\n            className: \"react-flow__minimap-svg\",\n            role: \"img\",\n            \"aria-labelledby\": labelledBy,\n            ref: svg,\n            onClick: onSvgClick,\n            children: [\n                ariaLabel && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"title\", {\n                    id: labelledBy,\n                    children: ariaLabel\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MiniMapNodes$1, {\n                    onClick: onSvgNodeClick,\n                    nodeColor: nodeColor,\n                    nodeStrokeColor: nodeStrokeColor,\n                    nodeBorderRadius: nodeBorderRadius,\n                    nodeClassName: nodeClassName,\n                    nodeStrokeWidth: nodeStrokeWidth,\n                    nodeComponent: nodeComponent\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    className: \"react-flow__minimap-mask\",\n                    d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,\n                    fillRule: \"evenodd\",\n                    pointerEvents: \"none\"\n                })\n            ]\n        })\n    });\n}\nMiniMapComponent.displayName = 'MiniMap';\nconst MiniMap = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(MiniMapComponent);\nfunction ResizeControl({ nodeId, position, variant = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ResizeControlVariant.Handle, className, style = {}, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === 'string' ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const defaultPosition = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ResizeControlVariant.Line ? 'right' : 'bottom-right';\n    const controlPosition = position ?? defaultPosition;\n    const resizer = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"ResizeControl.useEffect\": ()=>{\n            if (!resizeControlRef.current || !id) {\n                return;\n            }\n            if (!resizer.current) {\n                resizer.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYResizer)({\n                    domNode: resizeControlRef.current,\n                    nodeId: id,\n                    getStoreItems: {\n                        \"ResizeControl.useEffect\": ()=>{\n                            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();\n                            return {\n                                nodeLookup,\n                                transform,\n                                snapGrid,\n                                snapToGrid,\n                                nodeOrigin,\n                                paneDomNode: domNode\n                            };\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onChange: {\n                        \"ResizeControl.useEffect\": (change, childChanges)=>{\n                            const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState();\n                            const changes = [];\n                            const nextPosition = {\n                                x: change.x,\n                                y: change.y\n                            };\n                            const node = nodeLookup.get(id);\n                            if (node && node.expandParent && node.parentId) {\n                                const origin = node.origin ?? nodeOrigin;\n                                const width = change.width ?? node.measured.width;\n                                const height = change.height ?? node.measured.height;\n                                const child = {\n                                    id: node.id,\n                                    parentId: node.parentId,\n                                    rect: {\n                                        width,\n                                        height,\n                                        ...(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.evaluateAbsolutePosition)({\n                                            x: change.x ?? node.position.x,\n                                            y: change.y ?? node.position.y\n                                        }, {\n                                            width,\n                                            height\n                                        }, node.parentId, nodeLookup, origin)\n                                    }\n                                };\n                                const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleExpandParent)([\n                                    child\n                                ], nodeLookup, parentLookup, nodeOrigin);\n                                changes.push(...parentExpandChanges);\n                                // when the parent was expanded by the child node, its position will be clamped at\n                                // 0,0 when node origin is 0,0 and to width, height if it's 1,1\n                                nextPosition.x = change.x ? Math.max(origin[0] * width, change.x) : undefined;\n                                nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : undefined;\n                            }\n                            if (nextPosition.x !== undefined && nextPosition.y !== undefined) {\n                                const positionChange = {\n                                    id,\n                                    type: 'position',\n                                    position: {\n                                        ...nextPosition\n                                    }\n                                };\n                                changes.push(positionChange);\n                            }\n                            if (change.width !== undefined && change.height !== undefined) {\n                                const dimensionChange = {\n                                    id,\n                                    type: 'dimensions',\n                                    resizing: true,\n                                    setAttributes: true,\n                                    dimensions: {\n                                        width: change.width,\n                                        height: change.height\n                                    }\n                                };\n                                changes.push(dimensionChange);\n                            }\n                            for (const childChange of childChanges){\n                                const positionChange = {\n                                    ...childChange,\n                                    type: 'position'\n                                };\n                                changes.push(positionChange);\n                            }\n                            triggerNodeChanges(changes);\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onEnd: {\n                        \"ResizeControl.useEffect\": ()=>{\n                            const dimensionChange = {\n                                id: id,\n                                type: 'dimensions',\n                                resizing: false\n                            };\n                            store.getState().triggerNodeChanges([\n                                dimensionChange\n                            ]);\n                        }\n                    }[\"ResizeControl.useEffect\"]\n                });\n            }\n            resizer.current.update({\n                controlPosition,\n                boundaries: {\n                    minWidth,\n                    minHeight,\n                    maxWidth,\n                    maxHeight\n                },\n                keepAspectRatio,\n                onResizeStart,\n                onResize,\n                onResizeEnd,\n                shouldResize\n            });\n            return ({\n                \"ResizeControl.useEffect\": ()=>{\n                    resizer.current?.destroy();\n                }\n            })[\"ResizeControl.useEffect\"];\n        }\n    }[\"ResizeControl.useEffect\"], [\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n        shouldResize\n    ]);\n    const positionClassNames = controlPosition.split('-');\n    const colorStyleProp = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ResizeControlVariant.Line ? 'borderColor' : 'backgroundColor';\n    const controlStyle = color ? {\n        ...style,\n        [colorStyleProp]: color\n    } : style;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            'react-flow__resize-control',\n            'nodrag',\n            ...positionClassNames,\n            variant,\n            className\n        ]),\n        ref: resizeControlRef,\n        style: controlStyle,\n        children: children\n    });\n}\nconst NodeResizeControl = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(ResizeControl);\nfunction NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XY_RESIZER_LINE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: lineClassName,\n                    style: lineStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    variant: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ResizeControlVariant.Line,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position)),\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XY_RESIZER_HANDLE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: handleClassName,\n                    style: handleStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position))\n        ]\n    });\n}\nconst selector = (state)=>state.domNode?.querySelector('.react-flow__renderer');\nfunction NodeToolbarPortal({ children }) {\n    const wrapperRef = useStore(selector);\n    if (!wrapperRef) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, wrapperRef);\n}\nconst nodeEqualityFn = (a, b)=>a?.internals.positionAbsolute.x !== b?.internals.positionAbsolute.x || a?.internals.positionAbsolute.y !== b?.internals.positionAbsolute.y || a?.measured.width !== b?.measured.width || a?.measured.height !== b?.measured.height || a?.selected !== b?.selected || a?.internals.z !== b?.internals.z;\nconst nodesEqualityFn = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, node] of a){\n        if (nodeEqualityFn(node, b.get(key))) {\n            return false;\n        }\n    }\n    return true;\n};\nconst storeSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2],\n        selectedNodesCount: state.nodes.filter((node)=>node.selected).length\n    });\nfunction NodeToolbar({ nodeId, children, className, style, isVisible, position = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top, offset = 10, align = 'center', ...rest }) {\n    const contextNodeId = useNodeId();\n    const nodesSelector = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)({\n        \"NodeToolbar.useCallback[nodesSelector]\": (state)=>{\n            const nodeIds = Array.isArray(nodeId) ? nodeId : [\n                nodeId || contextNodeId || ''\n            ];\n            const internalNodes = nodeIds.reduce({\n                \"NodeToolbar.useCallback[nodesSelector].internalNodes\": (res, id)=>{\n                    const node = state.nodeLookup.get(id);\n                    if (node) {\n                        res.set(node.id, node);\n                    }\n                    return res;\n                }\n            }[\"NodeToolbar.useCallback[nodesSelector].internalNodes\"], new Map());\n            return internalNodes;\n        }\n    }[\"NodeToolbar.useCallback[nodesSelector]\"], [\n        nodeId,\n        contextNodeId\n    ]);\n    const nodes = useStore(nodesSelector, nodesEqualityFn);\n    const { x, y, zoom, selectedNodesCount } = useStore(storeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    // if isVisible is not set, we show the toolbar only if its node is selected and no other node is selected\n    const isActive = typeof isVisible === 'boolean' ? isVisible : nodes.size === 1 && nodes.values().next().value.selected && selectedNodesCount === 1;\n    if (!isActive || !nodes.size) {\n        return null;\n    }\n    const nodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getInternalNodesBounds)(nodes);\n    const nodesArray = Array.from(nodes.values());\n    const zIndex = Math.max(...nodesArray.map((node)=>node.internals.z + 1));\n    const wrapperStyle = {\n        position: 'absolute',\n        transform: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodeToolbarTransform)(nodeRect, {\n            x,\n            y,\n            zoom\n        }, position, offset, align),\n        zIndex,\n        ...style\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeToolbarPortal, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: wrapperStyle,\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                'react-flow__node-toolbar',\n                className\n            ]),\n            ...rest,\n            \"data-id\": nodesArray.reduce((acc, node)=>`${acc}${node.id} `, '').trim(),\n            children: children\n        })\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvN0JBQ3dEO0FBQzlCO0FBQ2twQztBQUMxMUI7QUFDMU07QUFDckQ7QUFDekM7QUFDRDtBQUV6QyxNQUFNMkYsNkJBQWVkLG9EQUFhQSxDQUFDO0FBQ25DLE1BQU1lLGFBQWFELGFBQWFFLFFBQVE7QUFFeEMsTUFBTUMsc0JBQXNCMUYseURBQWEsQ0FBQyxXQUFXO0FBQ3JEOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsU0FBUzJGLFNBQVNDLFFBQVEsRUFBRUMsVUFBVTtJQUNsQyxNQUFNQyxRQUFRcEIsaURBQVVBLENBQUNhO0lBQ3pCLElBQUlPLFVBQVUsTUFBTTtRQUNoQixNQUFNLElBQUlDLE1BQU1MO0lBQ3BCO0lBQ0EsT0FBT1AsMkVBQXNCQSxDQUFDVyxPQUFPRixVQUFVQztBQUNuRDtBQUNBLFNBQVNHO0lBQ0wsTUFBTUYsUUFBUXBCLGlEQUFVQSxDQUFDYTtJQUN6QixJQUFJTyxVQUFVLE1BQU07UUFDaEIsTUFBTSxJQUFJQyxNQUFNTDtJQUNwQjtJQUNBLE9BQU9mLDhDQUFPQTsrQkFBQyxJQUFPO2dCQUNsQnNCLFVBQVVILE1BQU1HLFFBQVE7Z0JBQ3hCQyxVQUFVSixNQUFNSSxRQUFRO2dCQUN4QkMsV0FBV0wsTUFBTUssU0FBUztZQUM5Qjs4QkFBSTtRQUFDTDtLQUFNO0FBQ2Y7QUFFQSxNQUFNTSxRQUFRO0lBQUVDLFNBQVM7QUFBTztBQUNoQyxNQUFNQyxnQkFBZ0I7SUFDbEJDLFVBQVU7SUFDVkMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLFFBQVEsQ0FBQztJQUNUQyxRQUFRO0lBQ1JDLFNBQVM7SUFDVEMsVUFBVTtJQUNWQyxNQUFNO0lBQ05DLFVBQVU7QUFDZDtBQUNBLE1BQU1DLHFCQUFxQjtB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Q0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJMG1DLElBQUk7WUFBSXptQyxVQUFVQTtRQUFTO0lBQUc7QUFDclA7QUFFZ3FCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXERoYXJtZXNoIHJhaWt3YXJcXERlc2t0b3BcXE9zaW50QXNzaWdubWVudFxcYXNzaWdubWVudFxcRnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQHh5Zmxvd1xccmVhY3RcXGRpc3RcXGVzbVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcbmltcG9ydCB7IGpzeHMsIEZyYWdtZW50LCBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgY2MgZnJvbSAnY2xhc3NjYXQnO1xuaW1wb3J0IHsgZXJyb3JNZXNzYWdlcywgaW5maW5pdGVFeHRlbnQsIGlzSW5wdXRET01Ob2RlLCBnZXRGaXRWaWV3Tm9kZXMsIGdldERpbWVuc2lvbnMsIGZpdFZpZXcsIGdldFZpZXdwb3J0Rm9yQm91bmRzLCBwb2ludFRvUmVuZGVyZXJQb2ludCwgcmVuZGVyZXJQb2ludFRvUG9pbnQsIGlzTm9kZUJhc2UsIGlzRWRnZUJhc2UsIGdldEVsZW1lbnRzVG9SZW1vdmUsIGlzUmVjdE9iamVjdCwgbm9kZVRvUmVjdCwgZ2V0T3ZlcmxhcHBpbmdBcmVhLCBnZXROb2Rlc0JvdW5kcywgZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uLCBYWVBhblpvb20sIFBhbk9uU2Nyb2xsTW9kZSwgU2VsZWN0aW9uTW9kZSwgZ2V0RXZlbnRQb3NpdGlvbiwgZ2V0Tm9kZXNJbnNpZGUsIGFyZVNldHNFcXVhbCwgWFlEcmFnLCBzbmFwUG9zaXRpb24sIGNhbGN1bGF0ZU5vZGVQb3NpdGlvbiwgUG9zaXRpb24sIENvbm5lY3Rpb25Nb2RlLCBpc01vdXNlRXZlbnQsIFhZSGFuZGxlLCBnZXRIb3N0Rm9yRWxlbWVudCwgYWRkRWRnZSwgZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcywgaXNOdW1lcmljLCBub2RlSGFzRGltZW5zaW9ucywgZ2V0Tm9kZURpbWVuc2lvbnMsIGVsZW1lbnRTZWxlY3Rpb25LZXlzLCBpc0VkZ2VWaXNpYmxlLCBNYXJrZXJUeXBlLCBjcmVhdGVNYXJrZXJJZHMsIGdldEJlemllckVkZ2VDZW50ZXIsIGdldFNtb290aFN0ZXBQYXRoLCBnZXRTdHJhaWdodFBhdGgsIGdldEJlemllclBhdGgsIGdldEVkZ2VQb3NpdGlvbiwgZ2V0RWxldmF0ZWRFZGdlWkluZGV4LCBnZXRNYXJrZXJJZCwgZ2V0Q29ubmVjdGlvblN0YXR1cywgQ29ubmVjdGlvbkxpbmVUeXBlLCB1cGRhdGVDb25uZWN0aW9uTG9va3VwLCBhZG9wdFVzZXJOb2RlcywgaW5pdGlhbENvbm5lY3Rpb24sIGRldldhcm4sIHVwZGF0ZU5vZGVJbnRlcm5hbHMsIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zLCBoYW5kbGVFeHBhbmRQYXJlbnQsIHBhbkJ5LCBpc01hY09zLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsLCBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlLCBzaGFsbG93Tm9kZURhdGEsIFhZTWluaW1hcCwgZ2V0Qm91bmRzT2ZSZWN0cywgUmVzaXplQ29udHJvbFZhcmlhbnQsIFhZUmVzaXplciwgWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUywgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLCBnZXROb2RlVG9vbGJhclRyYW5zZm9ybSB9IGZyb20gJ0B4eWZsb3cvc3lzdGVtJztcbmV4cG9ydCB7IENvbm5lY3Rpb25MaW5lVHlwZSwgQ29ubmVjdGlvbk1vZGUsIE1hcmtlclR5cGUsIFBhbk9uU2Nyb2xsTW9kZSwgUG9zaXRpb24sIFJlc2l6ZUNvbnRyb2xWYXJpYW50LCBTZWxlY3Rpb25Nb2RlLCBhZGRFZGdlLCBnZXRCZXppZXJFZGdlQ2VudGVyLCBnZXRCZXppZXJQYXRoLCBnZXRDb25uZWN0ZWRFZGdlcywgZ2V0RWRnZUNlbnRlciwgZ2V0SW5jb21lcnMsIGdldE5vZGVzQm91bmRzLCBnZXRPdXRnb2VycywgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIHJlY29ubmVjdEVkZ2UgfSBmcm9tICdAeHlmbG93L3N5c3RlbSc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCBmb3J3YXJkUmVmLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUxheW91dEVmZmVjdCwgdXNlQ2FsbGJhY2ssIG1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTdG9yZVdpdGhFcXVhbGl0eUZuLCBjcmVhdGVXaXRoRXF1YWxpdHlGbiB9IGZyb20gJ3p1c3RhbmQvdHJhZGl0aW9uYWwnO1xuaW1wb3J0IHsgc2hhbGxvdyB9IGZyb20gJ3p1c3RhbmQvc2hhbGxvdyc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuXG5jb25zdCBTdG9yZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgUHJvdmlkZXIkMSA9IFN0b3JlQ29udGV4dC5Qcm92aWRlcjtcblxuY29uc3QgenVzdGFuZEVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAxJ10oKTtcbi8qKlxuICogSG9vayBmb3IgYWNjZXNzaW5nIHRoZSBpbnRlcm5hbCBzdG9yZS4gU2hvdWxkIG9ubHkgYmUgdXNlZCBpbiByYXJlIGNhc2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBzZWxlY3RvclxuICogQHBhcmFtIGVxdWFsaXR5Rm5cbiAqIEByZXR1cm5zIFRoZSBzZWxlY3RlZCBzdGF0ZSBzbGljZVxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBub2RlcyA9IHVzZVN0b3JlKChzdGF0ZTogUmVhY3RGbG93U3RhdGU8TXlOb2RlVHlwZT4pID0+IHN0YXRlLm5vZGVzKTtcbiAqXG4gKi9cbmZ1bmN0aW9uIHVzZVN0b3JlKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKHN0b3JlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih6dXN0YW5kRXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4oc3RvcmUsIHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JlQXBpKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICAgIGlmIChzdG9yZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoenVzdGFuZEVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgc2V0U3RhdGU6IHN0b3JlLnNldFN0YXRlLFxuICAgICAgICBzdWJzY3JpYmU6IHN0b3JlLnN1YnNjcmliZSxcbiAgICB9KSwgW3N0b3JlXSk7XG59XG5cbmNvbnN0IHN0eWxlID0geyBkaXNwbGF5OiAnbm9uZScgfTtcbmNvbnN0IGFyaWFMaXZlU3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2lkdGg6IDEsXG4gICAgaGVpZ2h0OiAxLFxuICAgIG1hcmdpbjogLTEsXG4gICAgYm9yZGVyOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIGNsaXA6ICdyZWN0KDBweCwgMHB4LCAwcHgsIDBweCknLFxuICAgIGNsaXBQYXRoOiAnaW5zZXQoMTAwJSknLFxufTtcbmNvbnN0IEFSSUFfTk9ERV9ERVNDX0tFWSA9ICdyZWFjdC1mbG93X19ub2RlLWRlc2MnO1xuY29uc3QgQVJJQV9FREdFX0RFU0NfS0VZID0gJ3JlYWN0LWZsb3dfX2VkZ2UtZGVzYyc7XG5jb25zdCBBUklBX0xJVkVfTUVTU0FHRSA9ICdyZWFjdC1mbG93X19hcmlhLWxpdmUnO1xuY29uc3Qgc2VsZWN0b3IkbyA9IChzKSA9PiBzLmFyaWFMaXZlTWVzc2FnZTtcbmZ1bmN0aW9uIEFyaWFMaXZlTWVzc2FnZSh7IHJmSWQgfSkge1xuICAgIGNvbnN0IGFyaWFMaXZlTWVzc2FnZSA9IHVzZVN0b3JlKHNlbGVjdG9yJG8pO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfTElWRV9NRVNTQUdFfS0ke3JmSWR9YCwgXCJhcmlhLWxpdmVcIjogXCJhc3NlcnRpdmVcIiwgXCJhcmlhLWF0b21pY1wiOiBcInRydWVcIiwgc3R5bGU6IGFyaWFMaXZlU3R5bGUsIGNoaWxkcmVuOiBhcmlhTGl2ZU1lc3NhZ2UgfSkpO1xufVxuZnVuY3Rpb24gQTExeURlc2NyaXB0aW9ucyh7IHJmSWQsIGRpc2FibGVLZXlib2FyZEExMXkgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgeyBpZDogYCR7QVJJQV9OT0RFX0RFU0NfS0VZfS0ke3JmSWR9YCwgc3R5bGU6IHN0eWxlLCBjaGlsZHJlbjogW1wiUHJlc3MgZW50ZXIgb3Igc3BhY2UgdG8gc2VsZWN0IGEgbm9kZS5cIiwgIWRpc2FibGVLZXlib2FyZEExMXkgJiYgJ1lvdSBjYW4gdGhlbiB1c2UgdGhlIGFycm93IGtleXMgdG8gbW92ZSB0aGUgbm9kZSBhcm91bmQuJywgXCIgUHJlc3MgZGVsZXRlIHRvIHJlbW92ZSBpdCBhbmQgZXNjYXBlIHRvIGNhbmNlbC5cIiwgJyAnXSB9KSwganN4KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfRURHRV9ERVNDX0tFWX0tJHtyZklkfWAsIHN0eWxlOiBzdHlsZSwgY2hpbGRyZW46IFwiUHJlc3MgZW50ZXIgb3Igc3BhY2UgdG8gc2VsZWN0IGFuIGVkZ2UuIFlvdSBjYW4gdGhlbiBwcmVzcyBkZWxldGUgdG8gcmVtb3ZlIGl0IG9yIGVzY2FwZSB0byBjYW5jZWwuXCIgfSksICFkaXNhYmxlS2V5Ym9hcmRBMTF5ICYmIGpzeChBcmlhTGl2ZU1lc3NhZ2UsIHsgcmZJZDogcmZJZCB9KV0gfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRuID0gKHMpID0+IChzLnVzZXJTZWxlY3Rpb25BY3RpdmUgPyAnbm9uZScgOiAnYWxsJyk7XG5jb25zdCBQYW5lbCA9IGZvcndhcmRSZWYoKHsgcG9zaXRpb24gPSAndG9wLWxlZnQnLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgLi4ucmVzdCB9LCByZWYpID0+IHtcbiAgICBjb25zdCBwb2ludGVyRXZlbnRzID0gdXNlU3RvcmUoc2VsZWN0b3Ikbik7XG4gICAgY29uc3QgcG9zaXRpb25DbGFzc2VzID0gYCR7cG9zaXRpb259YC5zcGxpdCgnLScpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX3BhbmVsJywgY2xhc3NOYW1lLCAuLi5wb3NpdGlvbkNsYXNzZXNdKSwgc3R5bGU6IHsgLi4uc3R5bGUsIHBvaW50ZXJFdmVudHMgfSwgcmVmOiByZWYsIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59KTtcblxuZnVuY3Rpb24gQXR0cmlidXRpb24oeyBwcm9PcHRpb25zLCBwb3NpdGlvbiA9ICdib3R0b20tcmlnaHQnIH0pIHtcbiAgICBpZiAocHJvT3B0aW9ucz8uaGlkZUF0dHJpYnV0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChQYW5lbCwgeyBwb3NpdGlvbjogcG9zaXRpb24sIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19hdHRyaWJ1dGlvblwiLCBcImRhdGEtbWVzc2FnZVwiOiBcIlBsZWFzZSBvbmx5IGhpZGUgdGhpcyBhdHRyaWJ1dGlvbiB3aGVuIHlvdSBhcmUgc3Vic2NyaWJlZCB0byBSZWFjdCBGbG93IFBybzogaHR0cHM6Ly9wcm8ucmVhY3RmbG93LmRldlwiLCBjaGlsZHJlbjoganN4KFwiYVwiLCB7IGhyZWY6IFwiaHR0cHM6Ly9yZWFjdGZsb3cuZGV2XCIsIHRhcmdldDogXCJfYmxhbmtcIiwgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIiwgXCJhcmlhLWxhYmVsXCI6IFwiUmVhY3QgRmxvdyBhdHRyaWJ1dGlvblwiLCBjaGlsZHJlbjogXCJSZWFjdCBGbG93XCIgfSkgfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRtID0gKHMpID0+IHtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gW107XG4gICAgY29uc3Qgc2VsZWN0ZWRFZGdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgWywgbm9kZV0gb2Ygcy5ub2RlTG9va3VwKSB7XG4gICAgICAgIGlmIChub2RlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVzLnB1c2gobm9kZS5pbnRlcm5hbHMudXNlck5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgWywgZWRnZV0gb2Ygcy5lZGdlTG9va3VwKSB7XG4gICAgICAgIGlmIChlZGdlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZEVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcyB9O1xufTtcbmNvbnN0IHNlbGVjdElkID0gKG9iaikgPT4gb2JqLmlkO1xuZnVuY3Rpb24gYXJlRXF1YWwoYSwgYikge1xuICAgIHJldHVybiAoc2hhbGxvdyhhLnNlbGVjdGVkTm9kZXMubWFwKHNlbGVjdElkKSwgYi5zZWxlY3RlZE5vZGVzLm1hcChzZWxlY3RJZCkpICYmXG4gICAgICAgIHNoYWxsb3coYS5zZWxlY3RlZEVkZ2VzLm1hcChzZWxlY3RJZCksIGIuc2VsZWN0ZWRFZGdlcy5tYXAoc2VsZWN0SWQpKSk7XG59XG5mdW5jdGlvbiBTZWxlY3Rpb25MaXN0ZW5lcklubmVyKHsgb25TZWxlY3Rpb25DaGFuZ2UgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IHNlbGVjdGVkTm9kZXMsIHNlbGVjdGVkRWRnZXMgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJG0sIGFyZUVxdWFsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IG5vZGVzOiBzZWxlY3RlZE5vZGVzLCBlZGdlczogc2VsZWN0ZWRFZGdlcyB9O1xuICAgICAgICBvblNlbGVjdGlvbkNoYW5nZT8uKHBhcmFtcyk7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycy5mb3JFYWNoKChmbikgPT4gZm4ocGFyYW1zKSk7XG4gICAgfSwgW3NlbGVjdGVkTm9kZXMsIHNlbGVjdGVkRWRnZXMsIG9uU2VsZWN0aW9uQ2hhbmdlXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBjaGFuZ2VTZWxlY3RvciA9IChzKSA9PiAhIXMub25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycztcbmZ1bmN0aW9uIFNlbGVjdGlvbkxpc3RlbmVyKHsgb25TZWxlY3Rpb25DaGFuZ2UgfSkge1xuICAgIGNvbnN0IHN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgPSB1c2VTdG9yZShjaGFuZ2VTZWxlY3Rvcik7XG4gICAgaWYgKG9uU2VsZWN0aW9uQ2hhbmdlIHx8IHN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMpIHtcbiAgICAgICAgcmV0dXJuIGpzeChTZWxlY3Rpb25MaXN0ZW5lcklubmVyLCB7IG9uU2VsZWN0aW9uQ2hhbmdlOiBvblNlbGVjdGlvbkNoYW5nZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGRlZmF1bHROb2RlT3JpZ2luID0gWzAsIDBdO1xuY29uc3QgZGVmYXVsdFZpZXdwb3J0ID0geyB4OiAwLCB5OiAwLCB6b29tOiAxIH07XG5cbi8qXG4gKiBUaGlzIGNvbXBvbmVudCBoZWxwcyB1cyB0byB1cGRhdGUgdGhlIHN0b3JlIHdpdGggdGhlIHZhbHVlcyBjb21pbmcgZnJvbSB0aGUgdXNlci5cbiAqIFdlIGRpc3Rpbmd1aXNoIGJldHdlZW4gdmFsdWVzIHdlIGNhbiB1cGRhdGUgZGlyZWN0bHkgd2l0aCBgdXNlRGlyZWN0U3RvcmVVcGRhdGVyYCAobGlrZSBgc25hcEdyaWRgKVxuICogYW5kIHZhbHVlcyB0aGF0IGhhdmUgYSBkZWRpY2F0ZWQgc2V0dGVyIGZ1bmN0aW9uIGluIHRoZSBzdG9yZSAobGlrZSBgc2V0Tm9kZXNgKS5cbiAqL1xuLy8gdGhlc2UgZmllbGRzIGV4aXN0IGluIHRoZSBnbG9iYWwgc3RvcmUgYW5kIHdlIG5lZWQgdG8ga2VlcCB0aGVtIHVwIHRvIGRhdGVcbmNvbnN0IHJlYWN0Rmxvd0ZpZWxkc1RvVHJhY2sgPSBbXG4gICAgJ25vZGVzJyxcbiAgICAnZWRnZXMnLFxuICAgICdkZWZhdWx0Tm9kZXMnLFxuICAgICdkZWZhdWx0RWRnZXMnLFxuICAgICdvbkNvbm5lY3QnLFxuICAgICdvbkNvbm5lY3RTdGFydCcsXG4gICAgJ29uQ29ubmVjdEVuZCcsXG4gICAgJ29uQ2xpY2tDb25uZWN0U3RhcnQnLFxuICAgICdvbkNsaWNrQ29ubmVjdEVuZCcsXG4gICAgJ25vZGVzRHJhZ2dhYmxlJyxcbiAgICAnbm9kZXNDb25uZWN0YWJsZScsXG4gICAgJ25vZGVzRm9jdXNhYmxlJyxcbiAgICAnZWRnZXNGb2N1c2FibGUnLFxuICAgICdlZGdlc1JlY29ubmVjdGFibGUnLFxuICAgICdlbGV2YXRlTm9kZXNPblNlbGVjdCcsXG4gICAgJ2VsZXZhdGVFZGdlc09uU2VsZWN0JyxcbiAgICAnbWluWm9vbScsXG4gICAgJ21heFpvb20nLFxuICAgICdub2RlRXh0ZW50JyxcbiAgICAnb25Ob2Rlc0NoYW5nZScsXG4gICAgJ29uRWRnZXNDaGFuZ2UnLFxuICAgICdlbGVtZW50c1NlbGVjdGFibGUnLFxuICAgICdjb25uZWN0aW9uTW9kZScsXG4gICAgJ3NuYXBHcmlkJyxcbiAgICAnc25hcFRvR3JpZCcsXG4gICAgJ3RyYW5zbGF0ZUV4dGVudCcsXG4gICAgJ2Nvbm5lY3RPbkNsaWNrJyxcbiAgICAnZGVmYXVsdEVkZ2VPcHRpb25zJyxcbiAgICAnZml0VmlldycsXG4gICAgJ2ZpdFZpZXdPcHRpb25zJyxcbiAgICAnb25Ob2Rlc0RlbGV0ZScsXG4gICAgJ29uRWRnZXNEZWxldGUnLFxuICAgICdvbkRlbGV0ZScsXG4gICAgJ29uTm9kZURyYWcnLFxuICAgICdvbk5vZGVEcmFnU3RhcnQnLFxuICAgICdvbk5vZGVEcmFnU3RvcCcsXG4gICAgJ29uU2VsZWN0aW9uRHJhZycsXG4gICAgJ29uU2VsZWN0aW9uRHJhZ1N0YXJ0JyxcbiAgICAnb25TZWxlY3Rpb25EcmFnU3RvcCcsXG4gICAgJ29uTW92ZVN0YXJ0JyxcbiAgICAnb25Nb3ZlJyxcbiAgICAnb25Nb3ZlRW5kJyxcbiAgICAnbm9QYW5DbGFzc05hbWUnLFxuICAgICdub2RlT3JpZ2luJyxcbiAgICAnYXV0b1Bhbk9uQ29ubmVjdCcsXG4gICAgJ2F1dG9QYW5Pbk5vZGVEcmFnJyxcbiAgICAnb25FcnJvcicsXG4gICAgJ2Nvbm5lY3Rpb25SYWRpdXMnLFxuICAgICdpc1ZhbGlkQ29ubmVjdGlvbicsXG4gICAgJ3NlbGVjdE5vZGVzT25EcmFnJyxcbiAgICAnbm9kZURyYWdUaHJlc2hvbGQnLFxuICAgICdvbkJlZm9yZURlbGV0ZScsXG4gICAgJ2RlYnVnJyxcbiAgICAnYXV0b1BhblNwZWVkJyxcbiAgICAncGFuZUNsaWNrRGlzdGFuY2UnLFxuXTtcbi8vIHJmSWQgZG9lc24ndCBleGlzdCBpbiBSZWFjdEZsb3dQcm9wcywgYnV0IGl0J3Mgb25lIG9mIHRoZSBmaWVsZHMgd2Ugd2FudCB0byB1cGRhdGVcbmNvbnN0IGZpZWxkc1RvVHJhY2sgPSBbLi4ucmVhY3RGbG93RmllbGRzVG9UcmFjaywgJ3JmSWQnXTtcbmNvbnN0IHNlbGVjdG9yJGwgPSAocykgPT4gKHtcbiAgICBzZXROb2Rlczogcy5zZXROb2RlcyxcbiAgICBzZXRFZGdlczogcy5zZXRFZGdlcyxcbiAgICBzZXRNaW5ab29tOiBzLnNldE1pblpvb20sXG4gICAgc2V0TWF4Wm9vbTogcy5zZXRNYXhab29tLFxuICAgIHNldFRyYW5zbGF0ZUV4dGVudDogcy5zZXRUcmFuc2xhdGVFeHRlbnQsXG4gICAgc2V0Tm9kZUV4dGVudDogcy5zZXROb2RlRXh0ZW50LFxuICAgIHJlc2V0OiBzLnJlc2V0LFxuICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzOiBzLnNldERlZmF1bHROb2Rlc0FuZEVkZ2VzLFxuICAgIHNldFBhbmVDbGlja0Rpc3RhbmNlOiBzLnNldFBhbmVDbGlja0Rpc3RhbmNlLFxufSk7XG5jb25zdCBpbml0UHJldlZhbHVlcyA9IHtcbiAgICAvLyB0aGVzZSBhcmUgdmFsdWVzIHRoYXQgYXJlIGFsc28gcGFzc2VkIGRpcmVjdGx5IHRvIG90aGVyIGNvbXBvbmVudHNcbiAgICAvLyB0aGFuIHRoZSBTdG9yZVVwZGF0ZXIuIFdlIGNhbiByZWR1Y2UgdGhlIG51bWJlciBvZiBzZXRTdG9yZSBjYWxsc1xuICAgIC8vIGJ5IHNldHRpbmcgdGhlIHNhbWUgdmFsdWVzIGhlcmUgYXMgcHJldiBmaWVsZHMuXG4gICAgdHJhbnNsYXRlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICBub2RlT3JpZ2luOiBkZWZhdWx0Tm9kZU9yaWdpbixcbiAgICBtaW5ab29tOiAwLjUsXG4gICAgbWF4Wm9vbTogMixcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHRydWUsXG4gICAgbm9QYW5DbGFzc05hbWU6ICdub3BhbicsXG4gICAgcmZJZDogJzEnLFxuICAgIHBhbmVDbGlja0Rpc3RhbmNlOiAwLFxufTtcbmZ1bmN0aW9uIFN0b3JlVXBkYXRlcihwcm9wcykge1xuICAgIGNvbnN0IHsgc2V0Tm9kZXMsIHNldEVkZ2VzLCBzZXRNaW5ab29tLCBzZXRNYXhab29tLCBzZXRUcmFuc2xhdGVFeHRlbnQsIHNldE5vZGVFeHRlbnQsIHJlc2V0LCBzZXREZWZhdWx0Tm9kZXNBbmRFZGdlcywgc2V0UGFuZUNsaWNrRGlzdGFuY2UsIH0gPSB1c2VTdG9yZShzZWxlY3RvciRsLCBzaGFsbG93KTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMocHJvcHMuZGVmYXVsdE5vZGVzLCBwcm9wcy5kZWZhdWx0RWRnZXMpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2hlbiB3ZSByZXNldCB0aGUgc3RvcmUgd2UgYWxzbyBuZWVkIHRvIHJlc2V0IHRoZSBwcmV2aW91cyBmaWVsZHNcbiAgICAgICAgICAgIHByZXZpb3VzRmllbGRzLmN1cnJlbnQgPSBpbml0UHJldlZhbHVlcztcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHByZXZpb3VzRmllbGRzID0gdXNlUmVmKGluaXRQcmV2VmFsdWVzKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBmaWVsZHNUb1RyYWNrKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gcHJvcHNbZmllbGROYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRmllbGRWYWx1ZSA9IHByZXZpb3VzRmllbGRzLmN1cnJlbnRbZmllbGROYW1lXTtcbiAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlID09PSBwcmV2aW91c0ZpZWxkVmFsdWUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BzW2ZpZWxkTmFtZV0gPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gQ3VzdG9tIGhhbmRsaW5nIHdpdGggZGVkaWNhdGVkIHNldHRlcnMgZm9yIHNvbWUgZmllbGRzXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lID09PSAnbm9kZXMnKVxuICAgICAgICAgICAgICAgIHNldE5vZGVzKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnZWRnZXMnKVxuICAgICAgICAgICAgICAgIHNldEVkZ2VzKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnbWluWm9vbScpXG4gICAgICAgICAgICAgICAgc2V0TWluWm9vbShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ21heFpvb20nKVxuICAgICAgICAgICAgICAgIHNldE1heFpvb20oZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICd0cmFuc2xhdGVFeHRlbnQnKVxuICAgICAgICAgICAgICAgIHNldFRyYW5zbGF0ZUV4dGVudChmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ25vZGVFeHRlbnQnKVxuICAgICAgICAgICAgICAgIHNldE5vZGVFeHRlbnQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdwYW5lQ2xpY2tEaXN0YW5jZScpXG4gICAgICAgICAgICAgICAgc2V0UGFuZUNsaWNrRGlzdGFuY2UoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAvLyBSZW5hbWVkIGZpZWxkc1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnZml0VmlldycpXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBmaXRWaWV3T25Jbml0OiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnZml0Vmlld09wdGlvbnMnKVxuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld09uSW5pdE9wdGlvbnM6IGZpZWxkVmFsdWUgfSk7XG4gICAgICAgICAgICAvLyBHZW5lcmFsIGNhc2VcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IFtmaWVsZE5hbWVdOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzRmllbGRzLmN1cnJlbnQgPSBwcm9wcztcbiAgICB9LCBcbiAgICAvLyBPbmx5IHJlLXJ1biB0aGUgZWZmZWN0IGlmIG9uZSBvZiB0aGUgZmllbGRzIHdlIHRyYWNrIGNoYW5nZXNcbiAgICBmaWVsZHNUb1RyYWNrLm1hcCgoZmllbGROYW1lKSA9PiBwcm9wc1tmaWVsZE5hbWVdKSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldE1lZGlhUXVlcnkoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJyk7XG59XG4vKipcbiAqIEhvb2sgZm9yIHJlY2VpdmluZyB0aGUgY3VycmVudCBjb2xvciBtb2RlIGNsYXNzICdkYXJrJyBvciAnbGlnaHQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGNvbG9yTW9kZSAtIFRoZSBjb2xvciBtb2RlIHRvIHVzZSAoJ2RhcmsnLCAnbGlnaHQnIG9yICdzeXN0ZW0nKVxuICovXG5mdW5jdGlvbiB1c2VDb2xvck1vZGVDbGFzcyhjb2xvck1vZGUpIHtcbiAgICBjb25zdCBbY29sb3JNb2RlQ2xhc3MsIHNldENvbG9yTW9kZUNsYXNzXSA9IHVzZVN0YXRlKGNvbG9yTW9kZSA9PT0gJ3N5c3RlbScgPyBudWxsIDogY29sb3JNb2RlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY29sb3JNb2RlICE9PSAnc3lzdGVtJykge1xuICAgICAgICAgICAgc2V0Q29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gZ2V0TWVkaWFRdWVyeSgpO1xuICAgICAgICBjb25zdCB1cGRhdGVDb2xvck1vZGVDbGFzcyA9ICgpID0+IHNldENvbG9yTW9kZUNsYXNzKG1lZGlhUXVlcnk/Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnKTtcbiAgICAgICAgdXBkYXRlQ29sb3JNb2RlQ2xhc3MoKTtcbiAgICAgICAgbWVkaWFRdWVyeT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29sb3JNb2RlQ2xhc3MpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbWVkaWFRdWVyeT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29sb3JNb2RlQ2xhc3MpO1xuICAgICAgICB9O1xuICAgIH0sIFtjb2xvck1vZGVdKTtcbiAgICByZXR1cm4gY29sb3JNb2RlQ2xhc3MgIT09IG51bGwgPyBjb2xvck1vZGVDbGFzcyA6IGdldE1lZGlhUXVlcnkoKT8ubWF0Y2hlcyA/ICdkYXJrJyA6ICdsaWdodCc7XG59XG5cbmNvbnN0IGRlZmF1bHREb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsO1xuLyoqXG4gKiBIb29rIGZvciBoYW5kbGluZyBrZXkgZXZlbnRzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBwYXJhbS5rZXlDb2RlIC0gVGhlIGtleSBjb2RlIChzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncykgdG8gdXNlXG4gKiBAcGFyYW0gcGFyYW0ub3B0aW9ucyAtIE9wdGlvbnNcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL1xuZnVuY3Rpb24gdXNlS2V5UHJlc3MoXG4vLyB0aGUga2V5Y29kZSBjYW4gYmUgYSBzdHJpbmcgJ2EnIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgWydhJywgJ2ErZCddXG4vLyBhIHN0cmluZyBtZWFucyBhIHNpbmdsZSBrZXkgJ2EnIG9yIGEgY29tYmluYXRpb24gd2hlbiAnKycgaXMgdXNlZCAnYStkJ1xuLy8gYW4gYXJyYXkgbWVhbnMgZGlmZmVyZW50IHBvc3NpYmlsaXRlcy4gRXhwbGFpbmVyOiBbJ2EnLCAnZCtzJ10gaGVyZSB0aGVcbi8vIHVzZXIgY2FuIHVzZSB0aGUgc2luZ2xlIGtleSAnYScgb3IgdGhlIGNvbWJpbmF0aW9uICdkJyArICdzJ1xua2V5Q29kZSA9IG51bGwsIG9wdGlvbnMgPSB7IHRhcmdldDogZGVmYXVsdERvYywgYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXI6IHRydWUgfSkge1xuICAgIGNvbnN0IFtrZXlQcmVzc2VkLCBzZXRLZXlQcmVzc2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIGlmIGEgbW9kaWZpZXIga2V5IGlzIHByZXNzZWQgaW4gb3JkZXIgdG8gdHJhY2sgaXRcbiAgICBjb25zdCBtb2RpZmllclByZXNzZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHByZXNzZWQga2V5cyBpbiBvcmRlciB0byBzdXBwb3J0IGNvbWJpbmF0aW9uc1xuICAgIGNvbnN0IHByZXNzZWRLZXlzID0gdXNlUmVmKG5ldyBTZXQoW10pKTtcbiAgICAvLyBrZXlDb2RlcyA9IGFycmF5IHdpdGggc2luZ2xlIGtleXMgW1snYSddXSBvciBrZXkgY29tYmluYXRpb25zIFtbJ2EnLCAncyddXVxuICAgIC8vIGtleXNUb1dhdGNoID0gYXJyYXkgd2l0aCBhbGwga2V5cyBmbGF0dGVuZWQgWydhJywgJ2QnLCAnU2hpZnRMZWZ0J11cbiAgICAvLyB1c2VkIHRvIGNoZWNrIGlmIHdlIHN0b3JlIGV2ZW50LmNvZGUgb3IgZXZlbnQua2V5LiBXaGVuIHRoZSBjb2RlIGlzIGluIHRoZSBsaXN0IG9mIGtleXNUb1dhdGNoXG4gICAgLy8gd2UgdXNlIHRoZSBjb2RlIG90aGVyd2lzZSB0aGUga2V5LiBFeHBsYWluZXI6IFdoZW4geW91IHByZXNzIHRoZSBsZWZ0IFwiY29tbWFuZFwiIGtleSwgdGhlIGNvZGUgaXMgXCJNZXRhTGVmdFwiXG4gICAgLy8gYW5kIHRoZSBrZXkgaXMgXCJNZXRhXCIuIFdlIHdhbnQgdXNlcnMgdG8gYmUgYWJsZSB0byBwYXNzIGtleXMgYW5kIGNvZGVzIHNvIHdlIGFzc3VtZSB0aGF0IHRoZSBrZXkgaXMgbWVhbnQgd2hlblxuICAgIC8vIHdlIGNhbid0IGZpbmQgaXQgaW4gdGhlIGxpc3Qgb2Yga2V5c1RvV2F0Y2guXG4gICAgY29uc3QgW2tleUNvZGVzLCBrZXlzVG9XYXRjaF0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGtleUNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleUNvZGVBcnIgPSBBcnJheS5pc0FycmF5KGtleUNvZGUpID8ga2V5Q29kZSA6IFtrZXlDb2RlXTtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBrZXlDb2RlQXJyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoa2MpID0+IHR5cGVvZiBrYyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgLy8gd2UgZmlyc3QgcmVwbGFjZSBhbGwgJysnIHdpdGggJ1xcbicgIHdoaWNoIHdlIHdpbGwgdXNlIHRvIHNwbGl0IHRoZSBrZXlzIG9uXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSByZXBsYWNlICdcXG5cXG4nIHdpdGggJ1xcbisnLCB0aGlzIHdheSB3ZSBjYW4gYWxzbyBzdXBwb3J0IHRoZSBjb21iaW5hdGlvbiAna2V5KysnXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIGVuZCB3ZSBzaW1wbHkgc3BsaXQgb24gJ1xcbicgdG8gZ2V0IHRoZSBrZXkgYXJyYXlcbiAgICAgICAgICAgICAgICAubWFwKChrYykgPT4ga2MucmVwbGFjZSgnKycsICdcXG4nKS5yZXBsYWNlKCdcXG5cXG4nLCAnXFxuKycpLnNwbGl0KCdcXG4nKSk7XG4gICAgICAgICAgICBjb25zdCBrZXlzRmxhdCA9IGtleXMucmVkdWNlKChyZXMsIGl0ZW0pID0+IHJlcy5jb25jYXQoLi4uaXRlbSksIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBba2V5cywga2V5c0ZsYXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbW10sIFtdXTtcbiAgICB9LCBba2V5Q29kZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnM/LnRhcmdldCB8fCBkZWZhdWx0RG9jO1xuICAgICAgICBpZiAoa2V5Q29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZG93bkhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBtb2RpZmllclByZXNzZWQuY3VycmVudCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ZW50QWN0aW9uID0gKCFtb2RpZmllclByZXNzZWQuY3VycmVudCB8fCAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgJiYgIW9wdGlvbnMuYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXIpKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0lucHV0RE9NTm9kZShldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZlbnRBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBrZXlPckNvZGUgPSB1c2VLZXlPckNvZGUoZXZlbnQuY29kZSwga2V5c1RvV2F0Y2gpO1xuICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuYWRkKGV2ZW50W2tleU9yQ29kZV0pO1xuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cy5jdXJyZW50LCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdXBIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmVudEFjdGlvbiA9ICghbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgfHwgKG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ICYmICFvcHRpb25zLmFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNJbnB1dERPTU5vZGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50QWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5T3JDb2RlID0gdXNlS2V5T3JDb2RlKGV2ZW50LmNvZGUsIGtleXNUb1dhdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMuY3VycmVudCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuZGVsZXRlKGV2ZW50W2tleU9yQ29kZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaXggZm9yIE1hYzogd2hlbiBjbWQga2V5IGlzIHByZXNzZWQsIGtleXVwIGlzIG5vdCB0cmlnZ2VyZWQgZm9yIGFueSBvdGhlciBrZXksIHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjczODAwMTgvd2hlbi1jbWQta2V5LWlzLWtlcHQtcHJlc3NlZC1rZXl1cC1pcy1ub3QtdHJpZ2dlcmVkLWZvci1hbnktb3RoZXIta2V5XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ01ldGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNldEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHNldEtleVByZXNzZWQoZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhcmdldD8uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIHRhcmdldD8uYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcmVzZXRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHRhcmdldD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgcmVzZXRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtrZXlDb2RlLCBzZXRLZXlQcmVzc2VkXSk7XG4gICAgcmV0dXJuIGtleVByZXNzZWQ7XG59XG4vLyB1dGlsc1xuZnVuY3Rpb24gaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMsIGlzVXApIHtcbiAgICByZXR1cm4gKGtleUNvZGVzXG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byBjb21wYXJlIHNhbWUgc2l6ZXMgb2Yga2V5Q29kZSBkZWZpbml0aW9uc1xuICAgICAgICAvLyBhbmQgcHJlc3NlZCBrZXlzLiBXaGVuIHRoZSB1c2VyIHNwZWNpZmllZCAnTWV0YScgYXMgYSBrZXkgc29tZXdoZXJlXG4gICAgICAgIC8vIHRoaXMgd291bGQgYWxzbyBiZSB0cnV0aHkgd2l0aG91dCB0aGlzIGZpbHRlciB3aGVuIHVzZXIgcHJlc3NlcyAnTWV0YScgKyAncidcbiAgICAgICAgLmZpbHRlcigoa2V5cykgPT4gaXNVcCB8fCBrZXlzLmxlbmd0aCA9PT0gcHJlc3NlZEtleXMuc2l6ZSlcbiAgICAgICAgLy8gc2luY2Ugd2Ugd2FudCB0byBzdXBwb3J0IG11bHRpcGxlIHBvc3NpYmlsaXRpZXMgb25seSBvbmUgb2YgdGhlXG4gICAgICAgIC8vIGNvbWJpbmF0aW9ucyBuZWVkIHRvIGJlIHBhcnQgb2YgdGhlIHByZXNzZWQga2V5c1xuICAgICAgICAuc29tZSgoa2V5cykgPT4ga2V5cy5ldmVyeSgoaykgPT4gcHJlc3NlZEtleXMuaGFzKGspKSkpO1xufVxuZnVuY3Rpb24gdXNlS2V5T3JDb2RlKGV2ZW50Q29kZSwga2V5c1RvV2F0Y2gpIHtcbiAgICByZXR1cm4ga2V5c1RvV2F0Y2guaW5jbHVkZXMoZXZlbnRDb2RlKSA/ICdjb2RlJyA6ICdrZXknO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdmlld3BvcnQgaGVscGVyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIHZpZXdwb3J0IGhlbHBlciBmdW5jdGlvbnNcbiAqL1xuY29uc3QgdXNlVmlld3BvcnRIZWxwZXIgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHpvb21JbjogKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhblpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhblpvb20gPyBwYW5ab29tLnNjYWxlQnkoMS4yLCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KSA6IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgem9vbU91dDogKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhblpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhblpvb20gPyBwYW5ab29tLnNjYWxlQnkoMSAvIDEuMiwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSkgOiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpvb21UbzogKHpvb21MZXZlbCwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFuWm9vbSA/IHBhblpvb20uc2NhbGVUbyh6b29tTGV2ZWwsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pIDogUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRab29tOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgICAgIHNldFZpZXdwb3J0OiBhc3luYyAodmlld3BvcnQsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybTogW3RYLCB0WSwgdFpvb21dLCBwYW5ab29tLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICB4OiB2aWV3cG9ydC54ID8/IHRYLFxuICAgICAgICAgICAgICAgICAgICB5OiB2aWV3cG9ydC55ID8/IHRZLFxuICAgICAgICAgICAgICAgICAgICB6b29tOiB2aWV3cG9ydC56b29tID8/IHRab29tLFxuICAgICAgICAgICAgICAgIH0sIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Vmlld3BvcnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbeCwgeSwgem9vbV0gPSBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5LCB6b29tIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml0VmlldzogKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIG1pblpvb20sIG1heFpvb20sIHBhblpvb20sIGRvbU5vZGUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tIHx8ICFkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaXRWaWV3Tm9kZXMgPSBnZXRGaXRWaWV3Tm9kZXMobm9kZUxvb2t1cCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBnZXREaW1lbnNpb25zKGRvbU5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXRWaWV3KHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXM6IGZpdFZpZXdOb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgICAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgICAgICAgICAgICAgcGFuWm9vbSxcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRDZW50ZXI6IGFzeW5jICh4LCB5LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBtYXhab29tLCBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRab29tID0gdHlwZW9mIG9wdGlvbnM/Lnpvb20gIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy56b29tIDogbWF4Wm9vbTtcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJYID0gd2lkdGggLyAyIC0geCAqIG5leHRab29tO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlclkgPSBoZWlnaHQgLyAyIC0geSAqIG5leHRab29tO1xuICAgICAgICAgICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgICAgICAgICAgICAgIHpvb206IG5leHRab29tLFxuICAgICAgICAgICAgICAgIH0sIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml0Qm91bmRzOiBhc3luYyAoYm91bmRzLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBvcHRpb25zPy5wYWRkaW5nID8/IDAuMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHZpZXdwb3J0LCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjcmVlblRvRmxvd1Bvc2l0aW9uOiAoY2xpZW50UG9zaXRpb24sIG9wdGlvbnMgPSB7IHNuYXBUb0dyaWQ6IHRydWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IGRvbVgsIHk6IGRvbVkgfSA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ycmVjdGVkUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGNsaWVudFBvc2l0aW9uLnggLSBkb21YLFxuICAgICAgICAgICAgICAgICAgICB5OiBjbGllbnRQb3NpdGlvbi55IC0gZG9tWSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludFRvUmVuZGVyZXJQb2ludChjb3JyZWN0ZWRQb3NpdGlvbiwgdHJhbnNmb3JtLCBvcHRpb25zLnNuYXBUb0dyaWQsIHNuYXBHcmlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmbG93VG9TY3JlZW5Qb3NpdGlvbjogKGZsb3dQb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvd1Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IGRvbVgsIHk6IGRvbVkgfSA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXJQb3NpdGlvbiA9IHJlbmRlcmVyUG9pbnRUb1BvaW50KGZsb3dQb3NpdGlvbiwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiByZW5kZXJlclBvc2l0aW9uLnggKyBkb21YLFxuICAgICAgICAgICAgICAgICAgICB5OiByZW5kZXJlclBvc2l0aW9uLnkgKyBkb21ZLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbn07XG5cbi8vIFRoaXMgZnVuY3Rpb24gYXBwbGllcyBjaGFuZ2VzIHRvIG5vZGVzIG9yIGVkZ2VzIHRoYXQgYXJlIHRyaWdnZXJlZCBieSBSZWFjdCBGbG93IGludGVybmFsbHkuXG4vLyBXaGVuIHlvdSBkcmFnIGEgbm9kZSBmb3IgZXhhbXBsZSwgUmVhY3QgRmxvdyB3aWxsIHNlbmQgYSBwb3NpdGlvbiBjaGFuZ2UgdXBkYXRlLlxuLy8gVGhpcyBmdW5jdGlvbiB0aGVuIGFwcGxpZXMgdGhlIGNoYW5nZXMgYW5kIHJldHVybnMgdGhlIHVwZGF0ZWQgZWxlbWVudHMuXG5mdW5jdGlvbiBhcHBseUNoYW5nZXMoY2hhbmdlcywgZWxlbWVudHMpIHtcbiAgICBjb25zdCB1cGRhdGVkRWxlbWVudHMgPSBbXTtcbiAgICAvLyBCeSBzdG9yaW5nIGEgbWFwIG9mIGNoYW5nZXMgZm9yIGVhY2ggZWxlbWVudCwgd2UgY2FuIGEgcXVpY2sgbG9va3VwIGFzIHdlXG4gICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBlbGVtZW50cyBhcnJheSFcbiAgICBjb25zdCBjaGFuZ2VzTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFkZEl0ZW1DaGFuZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlLnR5cGUgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICBhZGRJdGVtQ2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gJ3JlbW92ZScgfHwgY2hhbmdlLnR5cGUgPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgLy8gRm9yIGEgJ3JlbW92ZScgY2hhbmdlIHdlIGNhbiBzYWZlbHkgaWdub3JlIGFueSBvdGhlciBjaGFuZ2VzIHF1ZXVlZCBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIGVsZW1lbnQsIGl0J3MgZ29pbmcgdG8gYmUgcmVtb3ZlZCBhbnl3YXkhXG4gICAgICAgICAgICBjaGFuZ2VzTWFwLnNldChjaGFuZ2UuaWQsIFtjaGFuZ2VdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRDaGFuZ2VzID0gY2hhbmdlc01hcC5nZXQoY2hhbmdlLmlkKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgc29tZSBjaGFuZ2VzIHF1ZXVlZCBhbHJlYWR5LCB3ZSBjYW4gZG8gYSBtdXRhYmxlIHVwZGF0ZSBvZlxuICAgICAgICAgICAgICAgIC8vIHRoYXQgYXJyYXkgYW5kIHNhdmUgb3Vyc2VsdmVzIHNvbWUgY29weWluZy5cbiAgICAgICAgICAgICAgICBlbGVtZW50Q2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzTWFwLnNldChjaGFuZ2UuaWQsIFtjaGFuZ2VdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGNoYW5nZXNNYXAuZ2V0KGVsZW1lbnQuaWQpO1xuICAgICAgICAvLyBXaGVuIHRoZXJlIGFyZSBubyBjaGFuZ2VzIGZvciBhbiBlbGVtZW50IHdlIGNhbiBqdXN0IHB1c2ggaXQgdW5tb2RpZmllZCxcbiAgICAgICAgLy8gbm8gbmVlZCB0byBjb3B5IGl0LlxuICAgICAgICBpZiAoIWNoYW5nZXMpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhICdyZW1vdmUnIGNoYW5nZSBxdWV1ZWQsIGl0J2xsIGJlIHRoZSBvbmx5IGNoYW5nZSBpbiB0aGUgYXJyYXlcbiAgICAgICAgaWYgKGNoYW5nZXNbMF0udHlwZSA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWzBdLnR5cGUgPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goeyAuLi5jaGFuZ2VzWzBdLml0ZW0gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3Igb3RoZXIgdHlwZXMgb2YgY2hhbmdlcywgd2Ugd2FudCB0byBzdGFydCB3aXRoIGEgc2hhbGxvdyBjb3B5IG9mIHRoZVxuICAgICAgICAvLyBvYmplY3Qgc28gUmVhY3Qga25vd3MgdGhpcyBlbGVtZW50IGhhcyBjaGFuZ2VkLiBTZXF1ZW50aWFsIGNoYW5nZXMgd2lsbFxuICAgICAgICAvLy8gZWFjaCBfbXV0YXRlXyB0aGlzIG9iamVjdCwgc28gdGhlcmUncyBvbmx5IGV2ZXIgb25lIGNvcHkuXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRFbGVtZW50ID0geyAuLi5lbGVtZW50IH07XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGFwcGx5Q2hhbmdlKGNoYW5nZSwgdXBkYXRlZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKHVwZGF0ZWRFbGVtZW50KTtcbiAgICB9XG4gICAgLy8gd2UgbmVlZCB0byB3YWl0IGZvciBhbGwgY2hhbmdlcyB0byBiZSBhcHBsaWVkIGJlZm9yZSBhZGRpbmcgbmV3IGl0ZW1zXG4gICAgLy8gdG8gYmUgYWJsZSB0byBhZGQgdGhlbSBhdCB0aGUgY29ycmVjdCBpbmRleFxuICAgIGlmIChhZGRJdGVtQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgYWRkSXRlbUNoYW5nZXMuZm9yRWFjaCgoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkRWxlbWVudHMuc3BsaWNlKGNoYW5nZS5pbmRleCwgMCwgeyAuLi5jaGFuZ2UuaXRlbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKHsgLi4uY2hhbmdlLml0ZW0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlZEVsZW1lbnRzO1xufVxuLy8gQXBwbGllcyBhIHNpbmdsZSBjaGFuZ2UgdG8gYW4gZWxlbWVudC4gVGhpcyBpcyBhICptdXRhYmxlKiB1cGRhdGUuXG5mdW5jdGlvbiBhcHBseUNoYW5nZShjaGFuZ2UsIGVsZW1lbnQpIHtcbiAgICBzd2l0Y2ggKGNoYW5nZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6IHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2VsZWN0ZWQgPSBjaGFuZ2Uuc2VsZWN0ZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwb3NpdGlvbic6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLnBvc2l0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucG9zaXRpb24gPSBjaGFuZ2UucG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZS5kcmFnZ2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmRyYWdnaW5nID0gY2hhbmdlLmRyYWdnaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGltZW5zaW9ucyc6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLmRpbWVuc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tZWFzdXJlZCA/Pz0ge307XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tZWFzdXJlZC53aWR0aCA9IGNoYW5nZS5kaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubWVhc3VyZWQuaGVpZ2h0ID0gY2hhbmdlLmRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2V0QXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LndpZHRoID0gY2hhbmdlLmRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaGVpZ2h0ID0gY2hhbmdlLmRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLnJlc2l6aW5nID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6aW5nID0gY2hhbmdlLnJlc2l6aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIERyb3AgaW4gZnVuY3Rpb24gdGhhdCBhcHBsaWVzIG5vZGUgY2hhbmdlcyB0byBhbiBhcnJheSBvZiBub2Rlcy5cbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIFZhcmlvdXMgZXZlbnRzIG9uIHRoZSA8UmVhY3RGbG93IC8+IGNvbXBvbmVudCBjYW4gcHJvZHVjZSBhbiB7QGxpbmsgTm9kZUNoYW5nZX0gdGhhdCBkZXNjcmliZXMgaG93IHRvIHVwZGF0ZSB0aGUgZWRnZXMgb2YgeW91ciBmbG93IGluIHNvbWUgd2F5LlxuIElmIHlvdSBkb24ndCBuZWVkIGFueSBjdXN0b20gYmVoYXZpb3VyLCB0aGlzIHV0aWwgY2FuIGJlIHVzZWQgdG8gdGFrZSBhbiBhcnJheSBvZiB0aGVzZSBjaGFuZ2VzIGFuZCBhcHBseSB0aGVtIHRvIHlvdXIgZWRnZXMuXG4gKiBAcGFyYW0gY2hhbmdlcyAtIEFycmF5IG9mIGNoYW5nZXMgdG8gYXBwbHlcbiAqIEBwYXJhbSBub2RlcyAtIEFycmF5IG9mIG5vZGVzIHRvIGFwcGx5IHRoZSBjaGFuZ2VzIHRvXG4gKiBAcmV0dXJucyBBcnJheSBvZiB1cGRhdGVkIG5vZGVzXG4gKiBAZXhhbXBsZVxuICogIGNvbnN0IG9uTm9kZXNDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAgIChjaGFuZ2VzKSA9PiB7XG4gICAgICAgIHNldE5vZGVzKChvbGROb2RlcykgPT4gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBvbGROb2RlcykpO1xuICAgICAgfSxcbiAgICAgIFtzZXROb2Rlc10sXG4gICAgKTtcbiAgXG4gICAgcmV0dXJuIChcbiAgICAgIDxSZWFjdEZMb3cgbm9kZXM9e25vZGVzfSBlZGdlcz17ZWRnZXN9IG9uTm9kZXNDaGFuZ2U9e29uTm9kZXNDaGFuZ2V9IC8+XG4gICAgKTtcbiAqL1xuZnVuY3Rpb24gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBub2Rlcykge1xuICAgIHJldHVybiBhcHBseUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpO1xufVxuLyoqXG4gKiBEcm9wIGluIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBlZGdlIGNoYW5nZXMgdG8gYW4gYXJyYXkgb2YgZWRnZXMuXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBWYXJpb3VzIGV2ZW50cyBvbiB0aGUgPFJlYWN0RmxvdyAvPiBjb21wb25lbnQgY2FuIHByb2R1Y2UgYW4ge0BsaW5rIEVkZ2VDaGFuZ2V9IHRoYXQgZGVzY3JpYmVzIGhvdyB0byB1cGRhdGUgdGhlIGVkZ2VzIG9mIHlvdXIgZmxvdyBpbiBzb21lIHdheS5cbiBJZiB5b3UgZG9uJ3QgbmVlZCBhbnkgY3VzdG9tIGJlaGF2aW91ciwgdGhpcyB1dGlsIGNhbiBiZSB1c2VkIHRvIHRha2UgYW4gYXJyYXkgb2YgdGhlc2UgY2hhbmdlcyBhbmQgYXBwbHkgdGhlbSB0byB5b3VyIGVkZ2VzLlxuICogQHBhcmFtIGNoYW5nZXMgLSBBcnJheSBvZiBjaGFuZ2VzIHRvIGFwcGx5XG4gKiBAcGFyYW0gZWRnZXMgLSBBcnJheSBvZiBlZGdlIHRvIGFwcGx5IHRoZSBjaGFuZ2VzIHRvXG4gKiBAcmV0dXJucyBBcnJheSBvZiB1cGRhdGVkIGVkZ2VzXG4gKiBAZXhhbXBsZVxuICogIGNvbnN0IG9uRWRnZXNDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAgIChjaGFuZ2VzKSA9PiB7XG4gICAgICAgIHNldEVkZ2VzKChvbGRFZGdlcykgPT4gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBvbGRFZGdlcykpO1xuICAgICAgfSxcbiAgICAgIFtzZXRFZGdlc10sXG4gICAgKTtcbiAgXG4gICAgcmV0dXJuIChcbiAgICAgIDxSZWFjdEZsb3cgbm9kZXM9e25vZGVzfSBlZGdlcz17ZWRnZXN9IG9uRWRnZXNDaGFuZ2U9e29uRWRnZXNDaGFuZ2V9IC8+XG4gICAgKTtcbiAqL1xuZnVuY3Rpb24gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBlZGdlcykge1xuICAgIHJldHVybiBhcHBseUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGlkLCBzZWxlY3RlZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkLFxuICAgICAgICB0eXBlOiAnc2VsZWN0JyxcbiAgICAgICAgc2VsZWN0ZWQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkNoYW5nZXMoaXRlbXMsIHNlbGVjdGVkSWRzID0gbmV3IFNldCgpLCBtdXRhdGVJdGVtID0gZmFsc2UpIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBbaWQsIGl0ZW1dIG9mIGl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHdpbGxCZVNlbGVjdGVkID0gc2VsZWN0ZWRJZHMuaGFzKGlkKTtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBzZXQgYWxsIGl0ZW1zIHRvIHNlbGVjdGVkPWZhbHNlIG9uIHRoZSBmaXJzdCBzZWxlY3Rpb25cbiAgICAgICAgaWYgKCEoaXRlbS5zZWxlY3RlZCA9PT0gdW5kZWZpbmVkICYmICF3aWxsQmVTZWxlY3RlZCkgJiYgaXRlbS5zZWxlY3RlZCAhPT0gd2lsbEJlU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChtdXRhdGVJdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBoYWNrIGlzIG5lZWRlZCBmb3Igbm9kZXMuIFdoZW4gdGhlIHVzZXIgZHJhZ2dlZCBhIG5vZGUsIGl0J3Mgc2VsZWN0ZWQuXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBhbm90aGVyIG5vZGUgZ2V0cyBkcmFnZ2VkLCB3ZSBuZWVkIHRvIGRlc2VsZWN0IHRoZSBwcmV2aW91cyBvbmUsXG4gICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgdG8gaGF2ZSBvbmx5IG9uZSBzZWxlY3RlZCBub2RlIGF0IGEgdGltZSAtIHRoZSBvbk5vZGVzQ2hhbmdlIGNhbGxiYWNrIGNvbWVzIHRvbyBsYXRlIGhlcmUgOi9cbiAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gd2lsbEJlU2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGl0ZW0uaWQsIHdpbGxCZVNlbGVjdGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZXM7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50c0RpZmZDaGFuZ2VzKHsgaXRlbXMgPSBbXSwgbG9va3VwLCB9KSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGl0ZW1zTG9va3VwID0gbmV3IE1hcChpdGVtcy5tYXAoKGl0ZW0pID0+IFtpdGVtLmlkLCBpdGVtXSkpO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCBpdGVtXSBvZiBpdGVtcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgbG9va3VwSXRlbSA9IGxvb2t1cC5nZXQoaXRlbS5pZCk7XG4gICAgICAgIGNvbnN0IHN0b3JlSXRlbSA9IGxvb2t1cEl0ZW0/LmludGVybmFscz8udXNlck5vZGUgPz8gbG9va3VwSXRlbTtcbiAgICAgICAgaWYgKHN0b3JlSXRlbSAhPT0gdW5kZWZpbmVkICYmIHN0b3JlSXRlbSAhPT0gaXRlbSkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgaWQ6IGl0ZW0uaWQsIGl0ZW06IGl0ZW0sIHR5cGU6ICdyZXBsYWNlJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcmVJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGl0ZW06IGl0ZW0sIHR5cGU6ICdhZGQnLCBpbmRleCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZF0gb2YgbG9va3VwKSB7XG4gICAgICAgIGNvbnN0IG5leHROb2RlID0gaXRlbXNMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgaWYgKG5leHROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGlkLCB0eXBlOiAncmVtb3ZlJyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGVsZW1lbnRUb1JlbW92ZUNoYW5nZShpdGVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgIH07XG59XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2VhYmxlIGFzIGEgTm9kZVxuICogQHB1YmxpY1xuICogQHJlbWFya3MgSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvIE5vZGUgaWYgaXQgcmV0dXJucyB0cnVlXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHRlc3RcbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYW4gTm9kZVxuICovXG5jb25zdCBpc05vZGUgPSAoZWxlbWVudCkgPT4gaXNOb2RlQmFzZShlbGVtZW50KTtcbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2VhYmxlIGFzIGFuIEVkZ2VcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBFZGdlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFuIEVkZ2VcbiAqL1xuY29uc3QgaXNFZGdlID0gKGVsZW1lbnQpID0+IGlzRWRnZUJhc2UoZWxlbWVudCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZnVuY3Rpb24gZml4ZWRGb3J3YXJkUmVmKHJlbmRlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIGZvcndhcmRSZWYocmVuZGVyKTtcbn1cblxuLy8gd2UgbmVlZCB0aGlzIGhvb2sgdG8gcHJldmVudCBhIHdhcm5pbmcgd2hlbiB1c2luZyByZWFjdC1mbG93IGluIFNTUlxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGEgcXVldWUgdGhhdCBjYW4gYmUgdXNlZCB0byBiYXRjaCB1cGRhdGVzLlxuICpcbiAqIEBwYXJhbSBydW5RdWV1ZSAtIGEgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBxdWV1ZSBpcyBmbHVzaGVkXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAcmV0dXJucyBhIFF1ZXVlIG9iamVjdFxuICovXG5mdW5jdGlvbiB1c2VRdWV1ZShydW5RdWV1ZSkge1xuICAgIC8vIEJlY2F1c2Ugd2UncmUgdXNpbmcgYSByZWYgYWJvdmUsIHdlIG5lZWQgc29tZSB3YXkgdG8gbGV0IFJlYWN0IGtub3cgd2hlbiB0b1xuICAgIC8vIGFjdHVhbGx5IHByb2Nlc3MgdGhlIHF1ZXVlLiBXZSBpbmNyZW1lbnQgdGhpcyBudW1iZXIgYW55IHRpbWUgd2UgbXV0YXRlIHRoZVxuICAgIC8vIHF1ZXVlLCBjcmVhdGluZyBhIG5ldyBzdGF0ZSB0byB0cmlnZ2VyIHRoZSBsYXlvdXQgZWZmZWN0IGJlbG93LlxuICAgIC8vIFVzaW5nIGEgYm9vbGVhbiBkaXJ0eSBmbGFnIGhlcmUgaW5zdGVhZCB3b3VsZCBsZWFkIHRvIGlzc3VlcyByZWxhdGVkIHRvXG4gICAgLy8gYXV0b21hdGljIGJhdGNoaW5nLiAoaHR0cHM6Ly9naXRodWIuY29tL3h5Zmxvdy94eWZsb3cvaXNzdWVzLzQ3NzkpXG4gICAgY29uc3QgW3NlcmlhbCwgc2V0U2VyaWFsXSA9IHVzZVN0YXRlKEJpZ0ludCgwKSk7XG4gICAgLy8gQSByZWZlcmVuY2Ugb2YgYWxsIHRoZSBiYXRjaGVkIHVwZGF0ZXMgdG8gcHJvY2VzcyBiZWZvcmUgdGhlIG5leHQgcmVuZGVyLiBXZVxuICAgIC8vIHdhbnQgYSByZWZlcmVuY2UgaGVyZSBzbyBtdWx0aXBsZSBzeW5jaHJvbm91cyBjYWxscyB0byBgc2V0Tm9kZXNgIGV0YyBjYW4gYmVcbiAgICAvLyBiYXRjaGVkIHRvZ2V0aGVyLlxuICAgIGNvbnN0IFtxdWV1ZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVRdWV1ZSgoKSA9PiBzZXRTZXJpYWwobiA9PiBuICsgQmlnSW50KDEpKSkpO1xuICAgIC8vIExheW91dCBlZmZlY3RzIGFyZSBndWFyYW50ZWVkIHRvIHJ1biBiZWZvcmUgdGhlIG5leHQgcmVuZGVyIHdoaWNoIG1lYW5zIHdlXG4gICAgLy8gc2hvdWxkbid0IHJ1biBpbnRvIGFueSBpc3N1ZXMgd2l0aCBzdGFsZSBzdGF0ZSBvciB3ZWlyZCBpc3N1ZXMgdGhhdCBjb21lIGZyb21cbiAgICAvLyByZW5kZXJpbmcgdGhpbmdzIG9uZSBmcmFtZSBsYXRlciB0aGFuIGV4cGVjdGVkICh3ZSB1c2VkIHRvIHVzZSBgc2V0VGltZW91dGApLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBxdWV1ZUl0ZW1zID0gcXVldWUuZ2V0KCk7XG4gICAgICAgIGlmIChxdWV1ZUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcnVuUXVldWUocXVldWVJdGVtcyk7XG4gICAgICAgICAgICBxdWV1ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfSwgW3NlcmlhbF0pO1xuICAgIHJldHVybiBxdWV1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVF1ZXVlKGNiKSB7XG4gICAgbGV0IHF1ZXVlID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiAoKSA9PiBxdWV1ZSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIHB1c2g6IChpdGVtKSA9PiB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5jb25zdCBCYXRjaENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXG4gKiBUaGlzIGlzIGEgY29udGV4dCBwcm92aWRlciB0aGF0IGhvbGRzIGFuZCBwcm9jZXNzZXMgdGhlIG5vZGUgYW5kIGVkZ2UgdXBkYXRlIHF1ZXVlc1xuICogdGhhdCBhcmUgbmVlZGVkIHRvIGhhbmRsZSBzZXROb2RlcywgYWRkTm9kZXMsIHNldEVkZ2VzIGFuZCBhZGRFZGdlcy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gQmF0Y2hQcm92aWRlcih7IGNoaWxkcmVuLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG5vZGVRdWV1ZUhhbmRsZXIgPSB1c2VDYWxsYmFjaygocXVldWVJdGVtcykgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVzID0gW10sIHNldE5vZGVzLCBoYXNEZWZhdWx0Tm9kZXMsIG9uTm9kZXNDaGFuZ2UsIG5vZGVMb29rdXAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIC8vIFRoaXMgaXMgZXNzZW50aWFsbHkgYW4gYEFycmF5LnJlZHVjZWAgaW4gaW1wZXJhdGl2ZSBjbG90aGluZy4gUHJvY2Vzc2luZ1xuICAgICAgICAvLyB0aGlzIHF1ZXVlIGlzIGEgcmVsYXRpdmVseSBob3QgcGF0aCBzbyB3ZSdkIGxpa2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkIG9mXG4gICAgICAgIC8vIGFycmF5IG1ldGhvZHMgd2hlcmUgd2UgY2FuLlxuICAgICAgICBsZXQgbmV4dCA9IG5vZGVzO1xuICAgICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2YgcXVldWVJdGVtcykge1xuICAgICAgICAgICAgbmV4dCA9IHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nID8gcGF5bG9hZChuZXh0KSA6IHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgc2V0Tm9kZXMobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob25Ob2Rlc0NoYW5nZSkge1xuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZShnZXRFbGVtZW50c0RpZmZDaGFuZ2VzKHtcbiAgICAgICAgICAgICAgICBpdGVtczogbmV4dCxcbiAgICAgICAgICAgICAgICBsb29rdXA6IG5vZGVMb29rdXAsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgbm9kZVF1ZXVlID0gdXNlUXVldWUobm9kZVF1ZXVlSGFuZGxlcik7XG4gICAgY29uc3QgZWRnZVF1ZXVlSGFuZGxlciA9IHVzZUNhbGxiYWNrKChxdWV1ZUl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSwgc2V0RWRnZXMsIGhhc0RlZmF1bHRFZGdlcywgb25FZGdlc0NoYW5nZSwgZWRnZUxvb2t1cCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgbGV0IG5leHQgPSBlZGdlcztcbiAgICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIHF1ZXVlSXRlbXMpIHtcbiAgICAgICAgICAgIG5leHQgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJyA/IHBheWxvYWQobmV4dCkgOiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldEVkZ2VzKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9uRWRnZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgIG9uRWRnZXNDaGFuZ2UoZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyh7XG4gICAgICAgICAgICAgICAgaXRlbXM6IG5leHQsXG4gICAgICAgICAgICAgICAgbG9va3VwOiBlZGdlTG9va3VwLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGVkZ2VRdWV1ZSA9IHVzZVF1ZXVlKGVkZ2VRdWV1ZUhhbmRsZXIpO1xuICAgIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiAoeyBub2RlUXVldWUsIGVkZ2VRdWV1ZSB9KSwgW10pO1xuICAgIHJldHVybiBqc3goQmF0Y2hDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xufVxuZnVuY3Rpb24gdXNlQmF0Y2hDb250ZXh0KCkge1xuICAgIGNvbnN0IGJhdGNoQ29udGV4dCA9IHVzZUNvbnRleHQoQmF0Y2hDb250ZXh0KTtcbiAgICBpZiAoIWJhdGNoQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUJhdGNoQ29udGV4dCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgQmF0Y2hQcm92aWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gYmF0Y2hDb250ZXh0O1xufVxuXG5jb25zdCBzZWxlY3RvciRrID0gKHMpID0+ICEhcy5wYW5ab29tO1xuLyoqXG4gKiBIb29rIGZvciBhY2Nlc3NpbmcgdGhlIFJlYWN0RmxvdyBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBSZWFjdEZsb3dJbnN0YW5jZVxuICovXG5mdW5jdGlvbiB1c2VSZWFjdEZsb3coKSB7XG4gICAgY29uc3Qgdmlld3BvcnRIZWxwZXIgPSB1c2VWaWV3cG9ydEhlbHBlcigpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBiYXRjaENvbnRleHQgPSB1c2VCYXRjaENvbnRleHQoKTtcbiAgICBjb25zdCB2aWV3cG9ydEluaXRpYWxpemVkID0gdXNlU3RvcmUoc2VsZWN0b3Ikayk7XG4gICAgY29uc3QgZ2VuZXJhbEhlbHBlciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBnZXRJbnRlcm5hbE5vZGUgPSAoaWQpID0+IHN0b3JlLmdldFN0YXRlKCkubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBzZXROb2RlcyA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBiYXRjaENvbnRleHQubm9kZVF1ZXVlLnB1c2gocGF5bG9hZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNldEVkZ2VzID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGJhdGNoQ29udGV4dC5lZGdlUXVldWUucHVzaChwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZ2V0Tm9kZVJlY3QgPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVRvVXNlID0gaXNOb2RlKG5vZGUpID8gbm9kZSA6IG5vZGVMb29rdXAuZ2V0KG5vZGUuaWQpO1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBub2RlVG9Vc2UucGFyZW50SWRcbiAgICAgICAgICAgICAgICA/IGV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbihub2RlVG9Vc2UucG9zaXRpb24sIG5vZGVUb1VzZS5tZWFzdXJlZCwgbm9kZVRvVXNlLnBhcmVudElkLCBub2RlTG9va3VwLCBub2RlT3JpZ2luKVxuICAgICAgICAgICAgICAgIDogbm9kZVRvVXNlLnBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVdpdGhQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlVG9Vc2UsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgd2lkdGg6IG5vZGVUb1VzZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZVRvVXNlLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbm9kZVRvVXNlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZVRvVXNlLmhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbm9kZVRvUmVjdChub2RlV2l0aFBvc2l0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXBkYXRlTm9kZSA9IChpZCwgbm9kZVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgc2V0Tm9kZXMoKHByZXZOb2RlcykgPT4gcHJldk5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IHR5cGVvZiBub2RlVXBkYXRlID09PSAnZnVuY3Rpb24nID8gbm9kZVVwZGF0ZShub2RlKSA6IG5vZGVVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgJiYgaXNOb2RlKG5leHROb2RlKSA/IG5leHROb2RlIDogeyAuLi5ub2RlLCAuLi5uZXh0Tm9kZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXBkYXRlRWRnZSA9IChpZCwgZWRnZVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgc2V0RWRnZXMoKHByZXZFZGdlcykgPT4gcHJldkVkZ2VzLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlZGdlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RWRnZSA9IHR5cGVvZiBlZGdlVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZWRnZVVwZGF0ZShlZGdlKSA6IGVkZ2VVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgJiYgaXNFZGdlKG5leHRFZGdlKSA/IG5leHRFZGdlIDogeyAuLi5lZGdlLCAuLi5uZXh0RWRnZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWRnZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldE5vZGVzOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVzLm1hcCgobikgPT4gKHsgLi4ubiB9KSksXG4gICAgICAgICAgICBnZXROb2RlOiAoaWQpID0+IGdldEludGVybmFsTm9kZShpZCk/LmludGVybmFscy51c2VyTm9kZSxcbiAgICAgICAgICAgIGdldEludGVybmFsTm9kZSxcbiAgICAgICAgICAgIGdldEVkZ2VzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlZGdlcyA9IFtdIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEVkZ2U6IChpZCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5lZGdlTG9va3VwLmdldChpZCksXG4gICAgICAgICAgICBzZXROb2RlcyxcbiAgICAgICAgICAgIHNldEVkZ2VzLFxuICAgICAgICAgICAgYWRkTm9kZXM6IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZXMgPSBBcnJheS5pc0FycmF5KHBheWxvYWQpID8gcGF5bG9hZCA6IFtwYXlsb2FkXTtcbiAgICAgICAgICAgICAgICBiYXRjaENvbnRleHQubm9kZVF1ZXVlLnB1c2goKG5vZGVzKSA9PiBbLi4ubm9kZXMsIC4uLm5ld05vZGVzXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkRWRnZXM6IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RWRnZXMgPSBBcnJheS5pc0FycmF5KHBheWxvYWQpID8gcGF5bG9hZCA6IFtwYXlsb2FkXTtcbiAgICAgICAgICAgICAgICBiYXRjaENvbnRleHQuZWRnZVF1ZXVlLnB1c2goKGVkZ2VzKSA9PiBbLi4uZWRnZXMsIC4uLm5ld0VkZ2VzXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9PYmplY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVzID0gW10sIGVkZ2VzID0gW10sIHRyYW5zZm9ybSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbeCwgeSwgem9vbV0gPSB0cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXM6IG5vZGVzLm1hcCgobikgPT4gKHsgLi4ubiB9KSksXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzOiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpLFxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgICAgICB6b29tLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsZXRlRWxlbWVudHM6IGFzeW5jICh7IG5vZGVzOiBub2Rlc1RvUmVtb3ZlID0gW10sIGVkZ2VzOiBlZGdlc1RvUmVtb3ZlID0gW10gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMsIGVkZ2VzLCBvbk5vZGVzRGVsZXRlLCBvbkVkZ2VzRGVsZXRlLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcywgb25EZWxldGUsIG9uQmVmb3JlRGVsZXRlLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVzOiBtYXRjaGluZ05vZGVzLCBlZGdlczogbWF0Y2hpbmdFZGdlcyB9ID0gYXdhaXQgZ2V0RWxlbWVudHNUb1JlbW92ZSh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzVG9SZW1vdmUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVEZWxldGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTWF0Y2hpbmdFZGdlcyA9IG1hdGNoaW5nRWRnZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNNYXRjaGluZ05vZGVzID0gbWF0Y2hpbmdOb2Rlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGlmIChoYXNNYXRjaGluZ0VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gbWF0Y2hpbmdFZGdlcy5tYXAoZWxlbWVudFRvUmVtb3ZlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgb25FZGdlc0RlbGV0ZT8uKG1hdGNoaW5nRWRnZXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZWRnZUNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWF0Y2hpbmdOb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG1hdGNoaW5nTm9kZXMubWFwKGVsZW1lbnRUb1JlbW92ZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIG9uTm9kZXNEZWxldGU/LihtYXRjaGluZ05vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc01hdGNoaW5nTm9kZXMgfHwgaGFzTWF0Y2hpbmdFZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZT8uKHsgbm9kZXM6IG1hdGNoaW5nTm9kZXMsIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkZWxldGVkTm9kZXM6IG1hdGNoaW5nTm9kZXMsIGRlbGV0ZWRFZGdlczogbWF0Y2hpbmdFZGdlcyB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEludGVyc2VjdGluZ05vZGVzOiAobm9kZU9yUmVjdCwgcGFydGlhbGx5ID0gdHJ1ZSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlY3QgPSBpc1JlY3RPYmplY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlY3QgPSBpc1JlY3QgPyBub2RlT3JSZWN0IDogZ2V0Tm9kZVJlY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTm9kZXNPcHRpb24gPSBub2RlcyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZVJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKG5vZGVzIHx8IHN0b3JlLmdldFN0YXRlKCkubm9kZXMpLmZpbHRlcigobikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVMb29rdXAuZ2V0KG4uaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxOb2RlICYmICFpc1JlY3QgJiYgKG4uaWQgPT09IG5vZGVPclJlY3QuaWQgfHwgIWludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyTm9kZVJlY3QgPSBub2RlVG9SZWN0KGhhc05vZGVzT3B0aW9uID8gbiA6IGludGVybmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQXJlYSA9IGdldE92ZXJsYXBwaW5nQXJlYShjdXJyTm9kZVJlY3QsIG5vZGVSZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gbm9kZVJlY3Qud2lkdGggKiBub2RlUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNOb2RlSW50ZXJzZWN0aW5nOiAobm9kZU9yUmVjdCwgYXJlYSwgcGFydGlhbGx5ID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVjdCA9IGlzUmVjdE9iamVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUmVjdCA9IGlzUmVjdCA/IG5vZGVPclJlY3QgOiBnZXROb2RlUmVjdChub2RlT3JSZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gZ2V0T3ZlcmxhcHBpbmdBcmVhKG5vZGVSZWN0LCBhcmVhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRpYWxseVZpc2libGUgfHwgb3ZlcmxhcHBpbmdBcmVhID49IG5vZGVSZWN0LndpZHRoICogbm9kZVJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZU5vZGUsXG4gICAgICAgICAgICB1cGRhdGVOb2RlRGF0YTogKGlkLCBkYXRhVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlTm9kZShpZCwgKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dERhdGEgPSB0eXBlb2YgZGF0YVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IGRhdGFVcGRhdGUobm9kZSkgOiBkYXRhVXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZXBsYWNlID8geyAuLi5ub2RlLCBkYXRhOiBuZXh0RGF0YSB9IDogeyAuLi5ub2RlLCBkYXRhOiB7IC4uLm5vZGUuZGF0YSwgLi4ubmV4dERhdGEgfSB9O1xuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZUVkZ2UsXG4gICAgICAgICAgICB1cGRhdGVFZGdlRGF0YTogKGlkLCBkYXRhVXBkYXRlLCBvcHRpb25zID0geyByZXBsYWNlOiBmYWxzZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRWRnZShpZCwgKGVkZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dERhdGEgPSB0eXBlb2YgZGF0YVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IGRhdGFVcGRhdGUoZWRnZSkgOiBkYXRhVXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZXBsYWNlID8geyAuLi5lZGdlLCBkYXRhOiBuZXh0RGF0YSB9IDogeyAuLi5lZGdlLCBkYXRhOiB7IC4uLmVkZ2UuZGF0YSwgLi4ubmV4dERhdGEgfSB9O1xuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE5vZGVzQm91bmRzOiAobm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIG5vZGVPcmlnaW4gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE5vZGVzQm91bmRzKG5vZGVzLCB7IG5vZGVMb29rdXAsIG5vZGVPcmlnaW4gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SGFuZGxlQ29ubmVjdGlvbnM6ICh7IHR5cGUsIGlkLCBub2RlSWQgfSkgPT4gQXJyYXkuZnJvbShzdG9yZVxuICAgICAgICAgICAgICAgIC5nZXRTdGF0ZSgpXG4gICAgICAgICAgICAgICAgLmNvbm5lY3Rpb25Mb29rdXAuZ2V0KGAke25vZGVJZH0tJHt0eXBlfSR7aWQgPyBgLSR7aWR9YCA6ICcnfWApXG4gICAgICAgICAgICAgICAgPy52YWx1ZXMoKSA/PyBbXSksXG4gICAgICAgICAgICBnZXROb2RlQ29ubmVjdGlvbnM6ICh7IHR5cGUsIGhhbmRsZUlkLCBub2RlSWQgfSkgPT4gQXJyYXkuZnJvbShzdG9yZVxuICAgICAgICAgICAgICAgIC5nZXRTdGF0ZSgpXG4gICAgICAgICAgICAgICAgLmNvbm5lY3Rpb25Mb29rdXAuZ2V0KGAke25vZGVJZH0ke3R5cGUgPyAoaGFuZGxlSWQgPyBgLSR7dHlwZX0tJHtoYW5kbGVJZH1gIDogYC0ke3R5cGV9YCkgOiAnJ31gKVxuICAgICAgICAgICAgICAgID8udmFsdWVzKCkgPz8gW10pLFxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5nZW5lcmFsSGVscGVyLFxuICAgICAgICAgICAgLi4udmlld3BvcnRIZWxwZXIsXG4gICAgICAgICAgICB2aWV3cG9ydEluaXRpYWxpemVkLFxuICAgICAgICB9O1xuICAgIH0sIFt2aWV3cG9ydEluaXRpYWxpemVkXSk7XG59XG5cbmNvbnN0IHNlbGVjdGVkID0gKGl0ZW0pID0+IGl0ZW0uc2VsZWN0ZWQ7XG5jb25zdCBkZWxldGVLZXlPcHRpb25zID0geyBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcjogZmFsc2UgfTtcbmNvbnN0IHdpbiQxID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4vKipcbiAqIEhvb2sgZm9yIGhhbmRsaW5nIGdsb2JhbCBrZXkgZXZlbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VHbG9iYWxLZXlIYW5kbGVyKHsgZGVsZXRlS2V5Q29kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgZGVsZXRlRWxlbWVudHMgfSA9IHVzZVJlYWN0RmxvdygpO1xuICAgIGNvbnN0IGRlbGV0ZUtleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhkZWxldGVLZXlDb2RlLCBkZWxldGVLZXlPcHRpb25zKTtcbiAgICBjb25zdCBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhtdWx0aVNlbGVjdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4kMSB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGVsZXRlS2V5UHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgbm9kZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBkZWxldGVFbGVtZW50cyh7IG5vZGVzOiBub2Rlcy5maWx0ZXIoc2VsZWN0ZWQpLCBlZGdlczogZWRnZXMuZmlsdGVyKHNlbGVjdGVkKSB9KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2RlbGV0ZUtleVByZXNzZWRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG11bHRpU2VsZWN0aW9uQWN0aXZlOiBtdWx0aVNlbGVjdGlvbktleVByZXNzZWQgfSk7XG4gICAgfSwgW211bHRpU2VsZWN0aW9uS2V5UHJlc3NlZF0pO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGhhbmRsaW5nIHJlc2l6ZSBldmVudHMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZVJlc2l6ZUhhbmRsZXIoZG9tTm9kZSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkb21Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZ2V0RGltZW5zaW9ucyhkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKHNpemUuaGVpZ2h0ID09PSAwIHx8IHNpemUud2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDA0JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDQnXSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgd2lkdGg6IHNpemUud2lkdGggfHwgNTAwLCBoZWlnaHQ6IHNpemUuaGVpZ2h0IHx8IDUwMCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRvbU5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdXBkYXRlRGltZW5zaW9ucygpKTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNpemVPYnNlcnZlciAmJiBkb21Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbn1cblxuY29uc3QgY29udGFpbmVyU3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbn07XG5cbmNvbnN0IHNlbGVjdG9yJGogPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgbGliOiBzLmxpYixcbn0pO1xuZnVuY3Rpb24gWm9vbVBhbmUoeyBvblBhbmVDb250ZXh0TWVudSwgem9vbU9uU2Nyb2xsID0gdHJ1ZSwgem9vbU9uUGluY2ggPSB0cnVlLCBwYW5PblNjcm9sbCA9IGZhbHNlLCBwYW5PblNjcm9sbFNwZWVkID0gMC41LCBwYW5PblNjcm9sbE1vZGUgPSBQYW5PblNjcm9sbE1vZGUuRnJlZSwgem9vbU9uRG91YmxlQ2xpY2sgPSB0cnVlLCBwYW5PbkRyYWcgPSB0cnVlLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBwcmV2ZW50U2Nyb2xsaW5nID0gdHJ1ZSwgY2hpbGRyZW4sIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgcGFuZUNsaWNrRGlzdGFuY2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgem9vbVBhbmUgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCBsaWIgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGosIHNoYWxsb3cpO1xuICAgIGNvbnN0IHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCA9IHVzZUtleVByZXNzKHpvb21BY3RpdmF0aW9uS2V5Q29kZSk7XG4gICAgY29uc3QgcGFuWm9vbSA9IHVzZVJlZigpO1xuICAgIHVzZVJlc2l6ZUhhbmRsZXIoem9vbVBhbmUpO1xuICAgIGNvbnN0IG9uVHJhbnNmb3JtQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHRyYW5zZm9ybSkgPT4ge1xuICAgICAgICBvblZpZXdwb3J0Q2hhbmdlPy4oeyB4OiB0cmFuc2Zvcm1bMF0sIHk6IHRyYW5zZm9ybVsxXSwgem9vbTogdHJhbnNmb3JtWzJdIH0pO1xuICAgICAgICBpZiAoIWlzQ29udHJvbGxlZFZpZXdwb3J0KSB7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHRyYW5zZm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh6b29tUGFuZS5jdXJyZW50KSB7XG4gICAgICAgICAgICBwYW5ab29tLmN1cnJlbnQgPSBYWVBhblpvb20oe1xuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHpvb21QYW5lLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgICAgICBtYXhab29tLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgICAgICAgICB2aWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0LFxuICAgICAgICAgICAgICAgIHBhbmVDbGlja0Rpc3RhbmNlLFxuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2U6IChwYW5lRHJhZ2dpbmcpID0+IHN0b3JlLnNldFN0YXRlKHsgcGFuZURyYWdnaW5nIH0pLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0OiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZVN0YXJ0LCBvbk1vdmVTdGFydCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgb25Nb3ZlU3RhcnQ/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlU3RhcnQ/Lih2cCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblBhblpvb206IChldmVudCwgdnApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlLCBvbk1vdmUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZT8uKGV2ZW50LCB2cCk7XG4gICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2U/Lih2cCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQ6IChldmVudCwgdnApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlRW5kLCBvbk1vdmVFbmQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZUVuZD8uKGV2ZW50LCB2cCk7XG4gICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2VFbmQ/Lih2cCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSBwYW5ab29tLmN1cnJlbnQuZ2V0Vmlld3BvcnQoKTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBwYW5ab29tOiBwYW5ab29tLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBbeCwgeSwgem9vbV0sXG4gICAgICAgICAgICAgICAgZG9tTm9kZTogem9vbVBhbmUuY3VycmVudC5jbG9zZXN0KCcucmVhY3QtZmxvdycpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHBhblpvb20uY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBwYW5ab29tLmN1cnJlbnQ/LnVwZGF0ZSh7XG4gICAgICAgICAgICBvblBhbmVDb250ZXh0TWVudSxcbiAgICAgICAgICAgIHpvb21PblNjcm9sbCxcbiAgICAgICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgICAgICBwYW5PblNjcm9sbFNwZWVkLFxuICAgICAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICAgICAgem9vbU9uRG91YmxlQ2xpY2ssXG4gICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsaW5nLFxuICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlLFxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIG9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgcGFuT25TY3JvbGxTcGVlZCxcbiAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICB6b29tT25Eb3VibGVDbGljayxcbiAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgIHByZXZlbnRTY3JvbGxpbmcsXG4gICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICBsaWIsXG4gICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlLFxuICAgIF0pO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3JlbmRlcmVyXCIsIHJlZjogem9vbVBhbmUsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkaSA9IChzKSA9PiAoe1xuICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICB1c2VyU2VsZWN0aW9uUmVjdDogcy51c2VyU2VsZWN0aW9uUmVjdCxcbn0pO1xuZnVuY3Rpb24gVXNlclNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB7IHVzZXJTZWxlY3Rpb25BY3RpdmUsIHVzZXJTZWxlY3Rpb25SZWN0IH0gPSB1c2VTdG9yZShzZWxlY3RvciRpLCBzaGFsbG93KTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHVzZXJTZWxlY3Rpb25BY3RpdmUgJiYgdXNlclNlbGVjdGlvblJlY3Q7XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fc2VsZWN0aW9uIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IHVzZXJTZWxlY3Rpb25SZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB1c2VyU2VsZWN0aW9uUmVjdC5oZWlnaHQsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt1c2VyU2VsZWN0aW9uUmVjdC54fXB4LCAke3VzZXJTZWxlY3Rpb25SZWN0Lnl9cHgpYCxcbiAgICAgICAgfSB9KSk7XG59XG5cbmNvbnN0IHdyYXBIYW5kbGVyID0gKGhhbmRsZXIsIGNvbnRhaW5lclJlZikgPT4ge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyPy4oZXZlbnQpO1xuICAgIH07XG59O1xuY29uc3Qgc2VsZWN0b3IkaCA9IChzKSA9PiAoe1xuICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIGRyYWdnaW5nOiBzLnBhbmVEcmFnZ2luZyxcbn0pO1xuZnVuY3Rpb24gUGFuZSh7IGlzU2VsZWN0aW5nLCBzZWxlY3Rpb25LZXlQcmVzc2VkLCBzZWxlY3Rpb25Nb2RlID0gU2VsZWN0aW9uTW9kZS5GdWxsLCBwYW5PbkRyYWcsIHNlbGVjdGlvbk9uRHJhZywgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIG9uUGFuZUNsaWNrLCBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIGNoaWxkcmVuLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBkcmFnZ2luZyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkaCwgc2hhbGxvdyk7XG4gICAgY29uc3QgaGFzQWN0aXZlU2VsZWN0aW9uID0gZWxlbWVudHNTZWxlY3RhYmxlICYmIChpc1NlbGVjdGluZyB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29udGFpbmVyQm91bmRzID0gdXNlUmVmKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlSWRzID0gdXNlUmVmKG5ldyBTZXQoKSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRFZGdlSWRzID0gdXNlUmVmKG5ldyBTZXQoKSk7XG4gICAgLy8gVXNlZCB0byBwcmV2ZW50IGNsaWNrIGV2ZW50cyB3aGVuIHRoZSB1c2VyIGxldHMgZ28gb2YgdGhlIHNlbGVjdGlvbktleSBkdXJpbmcgYSBzZWxlY3Rpb25cbiAgICBjb25zdCBzZWxlY3Rpb25JblByb2dyZXNzID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBzZWxlY3Rpb25TdGFydGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBvbkNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIFdlIHByZXZlbnQgY2xpY2sgZXZlbnRzIHdoZW4gdGhlIHVzZXIgbGV0IGdvIG9mIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIGEgc2VsZWN0aW9uXG4gICAgICAgIGlmIChzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uUGFuZUNsaWNrPy4oZXZlbnQpO1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLnJlc2V0U2VsZWN0ZWRFbGVtZW50cygpO1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ29udGV4dE1lbnUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWc/LmluY2x1ZGVzKDIpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uUGFuZUNvbnRleHRNZW51Py4oZXZlbnQpO1xuICAgIH07XG4gICAgY29uc3Qgb25XaGVlbCA9IG9uUGFuZVNjcm9sbCA/IChldmVudCkgPT4gb25QYW5lU2Nyb2xsKGV2ZW50KSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvblBvaW50ZXJEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVzZXRTZWxlY3RlZEVsZW1lbnRzLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb250YWluZXJCb3VuZHMuY3VycmVudCA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzU2VsZWN0YWJsZSB8fFxuICAgICAgICAgICAgIWlzU2VsZWN0aW5nIHx8XG4gICAgICAgICAgICBldmVudC5idXR0b24gIT09IDAgfHxcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCAhPT0gY29udGFpbmVyLmN1cnJlbnQgfHxcbiAgICAgICAgICAgICFjb250YWluZXJCb3VuZHMuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldD8uc2V0UG9pbnRlckNhcHR1cmU/LihldmVudC5wb2ludGVySWQpO1xuICAgICAgICBzZWxlY3Rpb25TdGFydGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50Lm5hdGl2ZUV2ZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgIHJlc2V0U2VsZWN0ZWRFbGVtZW50cygpO1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uUmVjdDoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICBzdGFydFg6IHgsXG4gICAgICAgICAgICAgICAgc3RhcnRZOiB5LFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBvblNlbGVjdGlvblN0YXJ0Py4oZXZlbnQpO1xuICAgIH07XG4gICAgY29uc3Qgb25Qb2ludGVyTW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHVzZXJTZWxlY3Rpb25SZWN0LCB0cmFuc2Zvcm0sIG5vZGVMb29rdXAsIGVkZ2VMb29rdXAsIGNvbm5lY3Rpb25Mb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzLCBkZWZhdWx0RWRnZU9wdGlvbnMsIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lckJvdW5kcy5jdXJyZW50IHx8ICF1c2VyU2VsZWN0aW9uUmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgeDogbW91c2VYLCB5OiBtb3VzZVkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQubmF0aXZlRXZlbnQsIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50KTtcbiAgICAgICAgY29uc3QgeyBzdGFydFgsIHN0YXJ0WSB9ID0gdXNlclNlbGVjdGlvblJlY3Q7XG4gICAgICAgIGNvbnN0IG5leHRVc2VyU2VsZWN0UmVjdCA9IHtcbiAgICAgICAgICAgIHN0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WSxcbiAgICAgICAgICAgIHg6IG1vdXNlWCA8IHN0YXJ0WCA/IG1vdXNlWCA6IHN0YXJ0WCxcbiAgICAgICAgICAgIHk6IG1vdXNlWSA8IHN0YXJ0WSA/IG1vdXNlWSA6IHN0YXJ0WSxcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLmFicyhtb3VzZVggLSBzdGFydFgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLmFicyhtb3VzZVkgLSBzdGFydFkpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0ZWROb2RlSWRzID0gc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3RlZEVkZ2VJZHMgPSBzZWxlY3RlZEVkZ2VJZHMuY3VycmVudDtcbiAgICAgICAgc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQgPSBuZXcgU2V0KGdldE5vZGVzSW5zaWRlKG5vZGVMb29rdXAsIG5leHRVc2VyU2VsZWN0UmVjdCwgdHJhbnNmb3JtLCBzZWxlY3Rpb25Nb2RlID09PSBTZWxlY3Rpb25Nb2RlLlBhcnRpYWwsIHRydWUpLm1hcCgobm9kZSkgPT4gbm9kZS5pZCkpO1xuICAgICAgICBzZWxlY3RlZEVkZ2VJZHMuY3VycmVudCA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgZWRnZXNTZWxlY3RhYmxlID0gZGVmYXVsdEVkZ2VPcHRpb25zPy5zZWxlY3RhYmxlID8/IHRydWU7XG4gICAgICAgIC8vIFdlIGxvb2sgZm9yIGFsbCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIHNlbGVjdGVkIG5vZGVzXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZUlkIG9mIHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25Mb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb25zKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IGVkZ2VJZCB9IG9mIGNvbm5lY3Rpb25zLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRnZSA9IGVkZ2VMb29rdXAuZ2V0KGVkZ2VJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2UgJiYgKGVkZ2Uuc2VsZWN0YWJsZSA/PyBlZGdlc1NlbGVjdGFibGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50LmFkZChlZGdlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZVNldHNFcXVhbChwcmV2U2VsZWN0ZWROb2RlSWRzLCBzZWxlY3RlZE5vZGVJZHMuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRTZWxlY3Rpb25DaGFuZ2VzKG5vZGVMb29rdXAsIHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50LCB0cnVlKTtcbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZVNldHNFcXVhbChwcmV2U2VsZWN0ZWRFZGdlSWRzLCBzZWxlY3RlZEVkZ2VJZHMuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRTZWxlY3Rpb25DaGFuZ2VzKGVkZ2VMb29rdXAsIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50KTtcbiAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uUmVjdDogbmV4dFVzZXJTZWxlY3RSZWN0LFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJVcCA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8ICFzZWxlY3Rpb25TdGFydGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC50YXJnZXQ/LnJlbGVhc2VQb2ludGVyQ2FwdHVyZT8uKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB0cmlnZ2VyIGNsaWNrIGZ1bmN0aW9ucyB3aGVuIGluIHNlbGVjdGlvbiBtb2RlIGlmXG4gICAgICAgIC8vIHRoZSB1c2VyIGRpZCBub3QgbW92ZSB0aGUgbW91c2UuXG4gICAgICAgIGlmICghdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdCAmJiBldmVudC50YXJnZXQgPT09IGNvbnRhaW5lci5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbkNsaWNrPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG51bGwsXG4gICAgICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQuc2l6ZSA+IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBvblNlbGVjdGlvbkVuZD8uKGV2ZW50KTtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIga2VwdCBob2xkaW5nIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIHRoZSBzZWxlY3Rpb24sXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHNlbGVjdGlvbkluUHJvZ3Jlc3MsIHNvIHRoZSBuZXh0IGNsaWNrIGV2ZW50IGlzIG5vdCBwcmV2ZW50ZWRcbiAgICAgICAgaWYgKHNlbGVjdGlvbktleVByZXNzZWQgfHwgc2VsZWN0aW9uT25EcmFnKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25TdGFydGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGRyYWdnYWJsZSA9IHBhbk9uRHJhZyA9PT0gdHJ1ZSB8fCAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZy5pbmNsdWRlcygwKSk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX3BhbmUnLCB7IGRyYWdnYWJsZSwgZHJhZ2dpbmcsIHNlbGVjdGlvbjogaXNTZWxlY3RpbmcgfV0pLCBvbkNsaWNrOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyB1bmRlZmluZWQgOiB3cmFwSGFuZGxlcihvbkNsaWNrLCBjb250YWluZXIpLCBvbkNvbnRleHRNZW51OiB3cmFwSGFuZGxlcihvbkNvbnRleHRNZW51LCBjb250YWluZXIpLCBvbldoZWVsOiB3cmFwSGFuZGxlcihvbldoZWVsLCBjb250YWluZXIpLCBvblBvaW50ZXJFbnRlcjogaGFzQWN0aXZlU2VsZWN0aW9uID8gdW5kZWZpbmVkIDogb25QYW5lTW91c2VFbnRlciwgb25Qb2ludGVyRG93bjogaGFzQWN0aXZlU2VsZWN0aW9uID8gb25Qb2ludGVyRG93biA6IG9uUGFuZU1vdXNlTW92ZSwgb25Qb2ludGVyTW92ZTogaGFzQWN0aXZlU2VsZWN0aW9uID8gb25Qb2ludGVyTW92ZSA6IG9uUGFuZU1vdXNlTW92ZSwgb25Qb2ludGVyVXA6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlclVwIDogdW5kZWZpbmVkLCBvblBvaW50ZXJMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgcmVmOiBjb250YWluZXIsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IFtjaGlsZHJlbiwganN4KFVzZXJTZWxlY3Rpb24sIHt9KV0gfSkpO1xufVxuXG4vLyB0aGlzIGhhbmRsZXIgaXMgY2FsbGVkIGJ5XG4vLyAxLiB0aGUgY2xpY2sgaGFuZGxlciB3aGVuIG5vZGUgaXMgbm90IGRyYWdnYWJsZSBvciBzZWxlY3ROb2Rlc09uRHJhZyA9IGZhbHNlXG4vLyBvclxuLy8gMi4gdGhlIG9uIGRyYWcgc3RhcnQgaGFuZGxlciB3aGVuIG5vZGUgaXMgZHJhZ2dhYmxlIGFuZCBzZWxlY3ROb2Rlc09uRHJhZyA9IHRydWVcbmZ1bmN0aW9uIGhhbmRsZU5vZGVDbGljayh7IGlkLCBzdG9yZSwgdW5zZWxlY3QgPSBmYWxzZSwgbm9kZVJlZiwgfSkge1xuICAgIGNvbnN0IHsgYWRkU2VsZWN0ZWROb2RlcywgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgbm9kZUxvb2t1cCwgb25FcnJvciB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICBvbkVycm9yPy4oJzAxMicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDEyJ10oaWQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICBpZiAoIW5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgYWRkU2VsZWN0ZWROb2RlcyhbaWRdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5zZWxlY3QgfHwgKG5vZGUuc2VsZWN0ZWQgJiYgbXVsdGlTZWxlY3Rpb25BY3RpdmUpKSB7XG4gICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcyh7IG5vZGVzOiBbbm9kZV0sIGVkZ2VzOiBbXSB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IG5vZGVSZWY/LmN1cnJlbnQ/LmJsdXIoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhvb2sgZm9yIGNhbGxpbmcgWFlEcmFnIGhlbHBlciBmcm9tIEB4eWZsb3cvc3lzdGVtLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEcmFnKHsgbm9kZVJlZiwgZGlzYWJsZWQgPSBmYWxzZSwgbm9EcmFnQ2xhc3NOYW1lLCBoYW5kbGVTZWxlY3Rvciwgbm9kZUlkLCBpc1NlbGVjdGFibGUsIG5vZGVDbGlja0Rpc3RhbmNlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IFtkcmFnZ2luZywgc2V0RHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHh5RHJhZyA9IHVzZVJlZigpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHh5RHJhZy5jdXJyZW50ID0gWFlEcmFnKHtcbiAgICAgICAgICAgIGdldFN0b3JlSXRlbXM6ICgpID0+IHN0b3JlLmdldFN0YXRlKCksXG4gICAgICAgICAgICBvbk5vZGVNb3VzZURvd246IChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRyYWdTdGFydDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldERyYWdnaW5nKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRHJhZ1N0b3A6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXREcmFnZ2luZyhmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICB4eURyYWcuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgeHlEcmFnLmN1cnJlbnQ/LnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgbm9EcmFnQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGhhbmRsZVNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IG5vZGVSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIG5vZGVDbGlja0Rpc3RhbmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHh5RHJhZy5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW25vRHJhZ0NsYXNzTmFtZSwgaGFuZGxlU2VsZWN0b3IsIGRpc2FibGVkLCBpc1NlbGVjdGFibGUsIG5vZGVSZWYsIG5vZGVJZF0pO1xuICAgIHJldHVybiBkcmFnZ2luZztcbn1cblxuY29uc3Qgc2VsZWN0ZWRBbmREcmFnZ2FibGUgPSAobm9kZXNEcmFnZ2FibGUpID0+IChuKSA9PiBuLnNlbGVjdGVkICYmIChuLmRyYWdnYWJsZSB8fCAobm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG4uZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpO1xuLyoqXG4gKiBIb29rIGZvciB1cGRhdGluZyBub2RlIHBvc2l0aW9ucyBieSBwYXNzaW5nIGEgZGlyZWN0aW9uIGFuZCBmYWN0b3JcbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIGZvciB1cGRhdGluZyBub2RlIHBvc2l0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VNb3ZlU2VsZWN0ZWROb2RlcygpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgbW92ZVNlbGVjdGVkTm9kZXMgPSB1c2VDYWxsYmFjaygocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUV4dGVudCwgc25hcFRvR3JpZCwgc25hcEdyaWQsIG5vZGVzRHJhZ2dhYmxlLCBvbkVycm9yLCB1cGRhdGVOb2RlUG9zaXRpb25zLCBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBub2RlVXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHNlbGVjdGVkQW5kRHJhZ2dhYmxlKG5vZGVzRHJhZ2dhYmxlKTtcbiAgICAgICAgLy8gYnkgZGVmYXVsdCBhIG5vZGUgbW92ZXMgNXB4IG9uIGVhY2gga2V5IHByZXNzXG4gICAgICAgIC8vIGlmIHNuYXAgZ3JpZCBpcyBlbmFibGVkLCB3ZSB1c2UgdGhhdCBmb3IgdGhlIHZlbG9jaXR5XG4gICAgICAgIGNvbnN0IHhWZWxvID0gc25hcFRvR3JpZCA/IHNuYXBHcmlkWzBdIDogNTtcbiAgICAgICAgY29uc3QgeVZlbG8gPSBzbmFwVG9HcmlkID8gc25hcEdyaWRbMV0gOiA1O1xuICAgICAgICBjb25zdCB4RGlmZiA9IHBhcmFtcy5kaXJlY3Rpb24ueCAqIHhWZWxvICogcGFyYW1zLmZhY3RvcjtcbiAgICAgICAgY29uc3QgeURpZmYgPSBwYXJhbXMuZGlyZWN0aW9uLnkgKiB5VmVsbyAqIHBhcmFtcy5mYWN0b3I7XG4gICAgICAgIGZvciAoY29uc3QgWywgbm9kZV0gb2Ygbm9kZUxvb2t1cCkge1xuICAgICAgICAgICAgaWYgKCFpc1NlbGVjdGVkKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCArIHhEaWZmLFxuICAgICAgICAgICAgICAgIHk6IG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSArIHlEaWZmLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzbmFwVG9HcmlkKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gc25hcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgc25hcEdyaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBwb3NpdGlvbiwgcG9zaXRpb25BYnNvbHV0ZSB9ID0gY2FsY3VsYXRlTm9kZVBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICBub2RlSWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgbm9kZUV4dGVudCxcbiAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgPSBwb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgbm9kZVVwZGF0ZXMuc2V0KG5vZGUuaWQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMobm9kZVVwZGF0ZXMpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gbW92ZVNlbGVjdGVkTm9kZXM7XG59XG5cbmNvbnN0IE5vZGVJZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgUHJvdmlkZXIgPSBOb2RlSWRDb250ZXh0LlByb3ZpZGVyO1xuTm9kZUlkQ29udGV4dC5Db25zdW1lcjtcbmNvbnN0IHVzZU5vZGVJZCA9ICgpID0+IHtcbiAgICBjb25zdCBub2RlSWQgPSB1c2VDb250ZXh0KE5vZGVJZENvbnRleHQpO1xuICAgIHJldHVybiBub2RlSWQ7XG59O1xuXG5jb25zdCBzZWxlY3RvciRnID0gKHMpID0+ICh7XG4gICAgY29ubmVjdE9uQ2xpY2s6IHMuY29ubmVjdE9uQ2xpY2ssXG4gICAgbm9QYW5DbGFzc05hbWU6IHMubm9QYW5DbGFzc05hbWUsXG4gICAgcmZJZDogcy5yZklkLFxufSk7XG5jb25zdCBjb25uZWN0aW5nU2VsZWN0b3IgPSAobm9kZUlkLCBoYW5kbGVJZCwgdHlwZSkgPT4gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogY2xpY2tIYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICBjb25zdCB7IGZyb21IYW5kbGUsIHRvSGFuZGxlLCBpc1ZhbGlkIH0gPSBjb25uZWN0aW9uO1xuICAgIGNvbnN0IGNvbm5lY3RpbmdUbyA9IHRvSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiB0b0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIHRvSGFuZGxlPy50eXBlID09PSB0eXBlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbm5lY3RpbmdGcm9tOiBmcm9tSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBmcm9tSGFuZGxlPy5pZCA9PT0gaGFuZGxlSWQgJiYgZnJvbUhhbmRsZT8udHlwZSA9PT0gdHlwZSxcbiAgICAgICAgY29ubmVjdGluZ1RvLFxuICAgICAgICBjbGlja0Nvbm5lY3Rpbmc6IGNsaWNrSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBjbGlja0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIGNsaWNrSGFuZGxlPy50eXBlID09PSB0eXBlLFxuICAgICAgICBpc1Bvc3NpYmxlRW5kSGFuZGxlOiBjb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuU3RyaWN0XG4gICAgICAgICAgICA/IGZyb21IYW5kbGU/LnR5cGUgIT09IHR5cGVcbiAgICAgICAgICAgIDogbm9kZUlkICE9PSBmcm9tSGFuZGxlPy5ub2RlSWQgfHwgaGFuZGxlSWQgIT09IGZyb21IYW5kbGU/LmlkLFxuICAgICAgICBjb25uZWN0aW9uSW5Qcm9jZXNzOiAhIWZyb21IYW5kbGUsXG4gICAgICAgIHZhbGlkOiBjb25uZWN0aW5nVG8gJiYgaXNWYWxpZCxcbiAgICB9O1xufTtcbmZ1bmN0aW9uIEhhbmRsZUNvbXBvbmVudCh7IHR5cGUgPSAnc291cmNlJywgcG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGlzVmFsaWRDb25uZWN0aW9uLCBpc0Nvbm5lY3RhYmxlID0gdHJ1ZSwgaXNDb25uZWN0YWJsZVN0YXJ0ID0gdHJ1ZSwgaXNDb25uZWN0YWJsZUVuZCA9IHRydWUsIGlkLCBvbkNvbm5lY3QsIGNoaWxkcmVuLCBjbGFzc05hbWUsIG9uTW91c2VEb3duLCBvblRvdWNoU3RhcnQsIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgY29uc3QgaGFuZGxlSWQgPSBpZCB8fCBudWxsO1xuICAgIGNvbnN0IGlzVGFyZ2V0ID0gdHlwZSA9PT0gJ3RhcmdldCc7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IHsgY29ubmVjdE9uQ2xpY2ssIG5vUGFuQ2xhc3NOYW1lLCByZklkIH0gPSB1c2VTdG9yZShzZWxlY3RvciRnLCBzaGFsbG93KTtcbiAgICBjb25zdCB7IGNvbm5lY3RpbmdGcm9tLCBjb25uZWN0aW5nVG8sIGNsaWNrQ29ubmVjdGluZywgaXNQb3NzaWJsZUVuZEhhbmRsZSwgY29ubmVjdGlvbkluUHJvY2VzcywgdmFsaWQgfSA9IHVzZVN0b3JlKGNvbm5lY3RpbmdTZWxlY3Rvcihub2RlSWQsIGhhbmRsZUlkLCB0eXBlKSwgc2hhbGxvdyk7XG4gICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAxMCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDEwJ10oKSk7XG4gICAgfVxuICAgIGNvbnN0IG9uQ29ubmVjdEV4dGVuZGVkID0gKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRFZGdlT3B0aW9ucywgb25Db25uZWN0OiBvbkNvbm5lY3RBY3Rpb24sIGhhc0RlZmF1bHRFZGdlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgZWRnZVBhcmFtcyA9IHtcbiAgICAgICAgICAgIC4uLmRlZmF1bHRFZGdlT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhhc0RlZmF1bHRFZGdlcykge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgc2V0RWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBzZXRFZGdlcyhhZGRFZGdlKGVkZ2VQYXJhbXMsIGVkZ2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgb25Db25uZWN0QWN0aW9uPy4oZWRnZVBhcmFtcyk7XG4gICAgICAgIG9uQ29ubmVjdD8uKGVkZ2VQYXJhbXMpO1xuICAgIH07XG4gICAgY29uc3Qgb25Qb2ludGVyRG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzTW91c2VUcmlnZ2VyZWQgPSBpc01vdXNlRXZlbnQoZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgICAgICBpZiAoaXNDb25uZWN0YWJsZVN0YXJ0ICYmXG4gICAgICAgICAgICAoKGlzTW91c2VUcmlnZ2VyZWQgJiYgZXZlbnQuYnV0dG9uID09PSAwKSB8fCAhaXNNb3VzZVRyaWdnZXJlZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdG9yZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBYWUhhbmRsZS5vblBvaW50ZXJEb3duKGV2ZW50Lm5hdGl2ZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgYXV0b1Bhbk9uQ29ubmVjdDogY3VycmVudFN0b3JlLmF1dG9QYW5PbkNvbm5lY3QsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk1vZGU6IGN1cnJlbnRTdG9yZS5jb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uUmFkaXVzOiBjdXJyZW50U3RvcmUuY29ubmVjdGlvblJhZGl1cyxcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBjdXJyZW50U3RvcmUuZG9tTm9kZSxcbiAgICAgICAgICAgICAgICBub2RlTG9va3VwOiBjdXJyZW50U3RvcmUubm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICBsaWI6IGN1cnJlbnRTdG9yZS5saWIsXG4gICAgICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIGZsb3dJZDogY3VycmVudFN0b3JlLnJmSWQsXG4gICAgICAgICAgICAgICAgcGFuQnk6IGN1cnJlbnRTdG9yZS5wYW5CeSxcbiAgICAgICAgICAgICAgICBjYW5jZWxDb25uZWN0aW9uOiBjdXJyZW50U3RvcmUuY2FuY2VsQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3RTdGFydDogY3VycmVudFN0b3JlLm9uQ29ubmVjdFN0YXJ0LFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdEVuZDogY3VycmVudFN0b3JlLm9uQ29ubmVjdEVuZCxcbiAgICAgICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uOiBjdXJyZW50U3RvcmUudXBkYXRlQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3Q6IG9uQ29ubmVjdEV4dGVuZGVkLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiB8fCBjdXJyZW50U3RvcmUuaXNWYWxpZENvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgZ2V0VHJhbnNmb3JtOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBnZXRGcm9tSGFuZGxlOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmNvbm5lY3Rpb24uZnJvbUhhbmRsZSxcbiAgICAgICAgICAgICAgICBhdXRvUGFuU3BlZWQ6IGN1cnJlbnRTdG9yZS5hdXRvUGFuU3BlZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNNb3VzZVRyaWdnZXJlZCkge1xuICAgICAgICAgICAgb25Nb3VzZURvd24/LihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvblRvdWNoU3RhcnQ/LihldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZCwgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb25TdG9yZSwgbGliLCByZklkOiBmbG93SWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb246IGNvbm5lY3Rpb25TdGF0ZSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghbm9kZUlkIHx8ICghY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUgJiYgIWlzQ29ubmVjdGFibGVTdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlKSB7XG4gICAgICAgICAgICBvbkNsaWNrQ29ubmVjdFN0YXJ0Py4oZXZlbnQubmF0aXZlRXZlbnQsIHsgbm9kZUlkLCBoYW5kbGVJZCwgaGFuZGxlVHlwZTogdHlwZSB9KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IHsgbm9kZUlkLCB0eXBlLCBpZDogaGFuZGxlSWQgfSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb2MgPSBnZXRIb3N0Rm9yRWxlbWVudChldmVudC50YXJnZXQpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkQ29ubmVjdGlvbkhhbmRsZXIgPSBpc1ZhbGlkQ29ubmVjdGlvbiB8fCBpc1ZhbGlkQ29ubmVjdGlvblN0b3JlO1xuICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb24sIGlzVmFsaWQgfSA9IFhZSGFuZGxlLmlzVmFsaWQoZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgIGhhbmRsZToge1xuICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICBpZDogaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGZyb21Ob2RlSWQ6IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLm5vZGVJZCxcbiAgICAgICAgICAgIGZyb21IYW5kbGVJZDogY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUuaWQgfHwgbnVsbCxcbiAgICAgICAgICAgIGZyb21UeXBlOiBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZS50eXBlLFxuICAgICAgICAgICAgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uSGFuZGxlcixcbiAgICAgICAgICAgIGZsb3dJZCxcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNWYWxpZCAmJiBjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBvbkNvbm5lY3RFeHRlbmRlZChjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0aW9uQ2xvbmUgPSBzdHJ1Y3R1cmVkQ2xvbmUoY29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgZGVsZXRlIGNvbm5lY3Rpb25DbG9uZS5pblByb2dyZXNzO1xuICAgICAgICBjb25uZWN0aW9uQ2xvbmUudG9Qb3NpdGlvbiA9IGNvbm5lY3Rpb25DbG9uZS50b0hhbmRsZSA/IGNvbm5lY3Rpb25DbG9uZS50b0hhbmRsZS5wb3NpdGlvbiA6IG51bGw7XG4gICAgICAgIG9uQ2xpY2tDb25uZWN0RW5kPy4oZXZlbnQsIGNvbm5lY3Rpb25DbG9uZSk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IG51bGwgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IFwiZGF0YS1oYW5kbGVpZFwiOiBoYW5kbGVJZCwgXCJkYXRhLW5vZGVpZFwiOiBub2RlSWQsIFwiZGF0YS1oYW5kbGVwb3NcIjogcG9zaXRpb24sIFwiZGF0YS1pZFwiOiBgJHtyZklkfS0ke25vZGVJZH0tJHtoYW5kbGVJZH0tJHt0eXBlfWAsIGNsYXNzTmFtZTogY2MoW1xuICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX2hhbmRsZScsXG4gICAgICAgICAgICBgcmVhY3QtZmxvd19faGFuZGxlLSR7cG9zaXRpb259YCxcbiAgICAgICAgICAgICdub2RyYWcnLFxuICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc291cmNlOiAhaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBpc1RhcmdldCxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZXN0YXJ0OiBpc0Nvbm5lY3RhYmxlU3RhcnQsXG4gICAgICAgICAgICAgICAgY29ubmVjdGFibGVlbmQ6IGlzQ29ubmVjdGFibGVFbmQsXG4gICAgICAgICAgICAgICAgY2xpY2tjb25uZWN0aW5nOiBjbGlja0Nvbm5lY3RpbmcsXG4gICAgICAgICAgICAgICAgY29ubmVjdGluZ2Zyb206IGNvbm5lY3RpbmdGcm9tLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpbmd0bzogY29ubmVjdGluZ1RvLFxuICAgICAgICAgICAgICAgIHZhbGlkLFxuICAgICAgICAgICAgICAgIC8vIHNob3dzIHdoZXJlIHlvdSBjYW4gc3RhcnQgYSBjb25uZWN0aW9uIGZyb21cbiAgICAgICAgICAgICAgICAvLyBhbmQgd2hlcmUgeW91IGNhbiBlbmQgaXQgd2hpbGUgY29ubmVjdGluZ1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25pbmRpY2F0b3I6IGlzQ29ubmVjdGFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFjb25uZWN0aW9uSW5Qcm9jZXNzIHx8IGlzUG9zc2libGVFbmRIYW5kbGUpICYmXG4gICAgICAgICAgICAgICAgICAgIChjb25uZWN0aW9uSW5Qcm9jZXNzID8gaXNDb25uZWN0YWJsZUVuZCA6IGlzQ29ubmVjdGFibGVTdGFydCksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKSwgb25Nb3VzZURvd246IG9uUG9pbnRlckRvd24sIG9uVG91Y2hTdGFydDogb25Qb2ludGVyRG93biwgb25DbGljazogY29ubmVjdE9uQ2xpY2sgPyBvbkNsaWNrIDogdW5kZWZpbmVkLCByZWY6IHJlZiwgLi4ucmVzdCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cbi8qKlxuICogVGhlIEhhbmRsZSBjb21wb25lbnQgaXMgYSBVSSBlbGVtZW50IHRoYXQgaXMgdXNlZCB0byBjb25uZWN0IG5vZGVzLlxuICovXG5jb25zdCBIYW5kbGUgPSBtZW1vKGZpeGVkRm9yd2FyZFJlZihIYW5kbGVDb21wb25lbnQpKTtcblxuZnVuY3Rpb24gSW5wdXROb2RlKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20gfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2RhdGE/LmxhYmVsLCBqc3goSGFuZGxlLCB7IHR5cGU6IFwic291cmNlXCIsIHBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KV0gfSkpO1xufVxuXG5mdW5jdGlvbiBEZWZhdWx0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChIYW5kbGUsIHsgdHlwZTogXCJ0YXJnZXRcIiwgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pLCBkYXRhPy5sYWJlbCwganN4KEhhbmRsZSwgeyB0eXBlOiBcInNvdXJjZVwiLCBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSldIH0pKTtcbn1cblxuZnVuY3Rpb24gR3JvdXBOb2RlKCkge1xuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBPdXRwdXROb2RlKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChIYW5kbGUsIHsgdHlwZTogXCJ0YXJnZXRcIiwgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pLCBkYXRhPy5sYWJlbF0gfSkpO1xufVxuXG5jb25zdCBhcnJvd0tleURpZmZzID0ge1xuICAgIEFycm93VXA6IHsgeDogMCwgeTogLTEgfSxcbiAgICBBcnJvd0Rvd246IHsgeDogMCwgeTogMSB9LFxuICAgIEFycm93TGVmdDogeyB4OiAtMSwgeTogMCB9LFxuICAgIEFycm93UmlnaHQ6IHsgeDogMSwgeTogMCB9LFxufTtcbmNvbnN0IGJ1aWx0aW5Ob2RlVHlwZXMgPSB7XG4gICAgaW5wdXQ6IElucHV0Tm9kZSxcbiAgICBkZWZhdWx0OiBEZWZhdWx0Tm9kZSxcbiAgICBvdXRwdXQ6IE91dHB1dE5vZGUsXG4gICAgZ3JvdXA6IEdyb3VwTm9kZSxcbn07XG5mdW5jdGlvbiBnZXROb2RlSW5saW5lU3R5bGVEaW1lbnNpb25zKG5vZGUpIHtcbiAgICBpZiAobm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IG5vZGUuc3R5bGU/LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gbm9kZS5zdHlsZT8uaGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogbm9kZS53aWR0aCA/PyBub2RlLnN0eWxlPy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCA/PyBub2RlLnN0eWxlPy5oZWlnaHQsXG4gICAgfTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkZiA9IChzKSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4LCB5IH0gPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKHMubm9kZUxvb2t1cCwge1xuICAgICAgICBmaWx0ZXI6IChub2RlKSA9PiAhIW5vZGUuc2VsZWN0ZWQsXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGlzTnVtZXJpYyh3aWR0aCkgPyB3aWR0aCA6IG51bGwsXG4gICAgICAgIGhlaWdodDogaXNOdW1lcmljKGhlaWdodCkgPyBoZWlnaHQgOiBudWxsLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgICAgIHRyYW5zZm9ybVN0cmluZzogYHRyYW5zbGF0ZSgke3MudHJhbnNmb3JtWzBdfXB4LCR7cy50cmFuc2Zvcm1bMV19cHgpIHNjYWxlKCR7cy50cmFuc2Zvcm1bMl19KSB0cmFuc2xhdGUoJHt4fXB4LCR7eX1weClgLFxuICAgIH07XG59O1xuZnVuY3Rpb24gTm9kZXNTZWxlY3Rpb24oeyBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHRyYW5zZm9ybVN0cmluZywgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkZiwgc2hhbGxvdyk7XG4gICAgY29uc3QgbW92ZVNlbGVjdGVkTm9kZXMgPSB1c2VNb3ZlU2VsZWN0ZWROb2RlcygpO1xuICAgIGNvbnN0IG5vZGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFkaXNhYmxlS2V5Ym9hcmRBMTF5KSB7XG4gICAgICAgICAgICBub2RlUmVmLmN1cnJlbnQ/LmZvY3VzKHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZGlzYWJsZUtleWJvYXJkQTExeV0pO1xuICAgIHVzZURyYWcoe1xuICAgICAgICBub2RlUmVmLFxuICAgIH0pO1xuICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbkNvbnRleHRNZW51ID0gb25TZWxlY3Rpb25Db250ZXh0TWVudVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHN0b3JlLmdldFN0YXRlKCkubm9kZXMuZmlsdGVyKChuKSA9PiBuLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUoZXZlbnQsIHNlbGVjdGVkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycm93S2V5RGlmZnMsIGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBtb3ZlU2VsZWN0ZWROb2Rlcyh7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0sXG4gICAgICAgICAgICAgICAgZmFjdG9yOiBldmVudC5zaGlmdEtleSA/IDQgOiAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX25vZGVzc2VsZWN0aW9uJywgJ3JlYWN0LWZsb3dfX2NvbnRhaW5lcicsIG5vUGFuQ2xhc3NOYW1lXSksIHN0eWxlOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVN0cmluZyxcbiAgICAgICAgfSwgY2hpbGRyZW46IGpzeChcImRpdlwiLCB7IHJlZjogbm9kZVJlZiwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX25vZGVzc2VsZWN0aW9uLXJlY3RcIiwgb25Db250ZXh0TWVudTogb25Db250ZXh0TWVudSwgdGFiSW5kZXg6IGRpc2FibGVLZXlib2FyZEExMXkgPyB1bmRlZmluZWQgOiAtMSwgb25LZXlEb3duOiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogb25LZXlEb3duLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIH0gfSkgfSkpO1xufVxuXG5jb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbmNvbnN0IHNlbGVjdG9yJGUgPSAocykgPT4ge1xuICAgIHJldHVybiB7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBzLm5vZGVzU2VsZWN0aW9uQWN0aXZlLCB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUgfTtcbn07XG5mdW5jdGlvbiBGbG93UmVuZGVyZXJDb21wb25lbnQoeyBjaGlsZHJlbiwgb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbCwgcGFuZUNsaWNrRGlzdGFuY2UsIGRlbGV0ZUtleUNvZGUsIHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZywgc2VsZWN0aW9uTW9kZSwgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoLCBwYW5PblNjcm9sbDogX3Bhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGUsIHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PbkRyYWc6IF9wYW5PbkRyYWcsIGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tLCBtYXhab29tLCBwcmV2ZW50U2Nyb2xsaW5nLCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQsIH0pIHtcbiAgICBjb25zdCB7IG5vZGVzU2VsZWN0aW9uQWN0aXZlLCB1c2VyU2VsZWN0aW9uQWN0aXZlIH0gPSB1c2VTdG9yZShzZWxlY3RvciRlKTtcbiAgICBjb25zdCBzZWxlY3Rpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3Moc2VsZWN0aW9uS2V5Q29kZSwgeyB0YXJnZXQ6IHdpbiB9KTtcbiAgICBjb25zdCBwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCA9IHVzZUtleVByZXNzKHBhbkFjdGl2YXRpb25LZXlDb2RlLCB7IHRhcmdldDogd2luIH0pO1xuICAgIGNvbnN0IHBhbk9uRHJhZyA9IHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkIHx8IF9wYW5PbkRyYWc7XG4gICAgY29uc3QgcGFuT25TY3JvbGwgPSBwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCBfcGFuT25TY3JvbGw7XG4gICAgY29uc3QgX3NlbGVjdGlvbk9uRHJhZyA9IHNlbGVjdGlvbk9uRHJhZyAmJiBwYW5PbkRyYWcgIT09IHRydWU7XG4gICAgY29uc3QgaXNTZWxlY3RpbmcgPSBzZWxlY3Rpb25LZXlQcmVzc2VkIHx8IHVzZXJTZWxlY3Rpb25BY3RpdmUgfHwgX3NlbGVjdGlvbk9uRHJhZztcbiAgICB1c2VHbG9iYWxLZXlIYW5kbGVyKHsgZGVsZXRlS2V5Q29kZSwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlIH0pO1xuICAgIHJldHVybiAoanN4KFpvb21QYW5lLCB7IG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIHpvb21PblNjcm9sbDogem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaDogem9vbU9uUGluY2gsIHBhbk9uU2Nyb2xsOiBwYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZDogcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlOiBwYW5PblNjcm9sbE1vZGUsIHpvb21PbkRvdWJsZUNsaWNrOiB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnOiAhc2VsZWN0aW9uS2V5UHJlc3NlZCAmJiBwYW5PbkRyYWcsIGRlZmF1bHRWaWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgem9vbUFjdGl2YXRpb25LZXlDb2RlOiB6b29tQWN0aXZhdGlvbktleUNvZGUsIHByZXZlbnRTY3JvbGxpbmc6IHByZXZlbnRTY3JvbGxpbmcsIG5vV2hlZWxDbGFzc05hbWU6IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgb25WaWV3cG9ydENoYW5nZTogb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQ6IGlzQ29udHJvbGxlZFZpZXdwb3J0LCBwYW5lQ2xpY2tEaXN0YW5jZTogcGFuZUNsaWNrRGlzdGFuY2UsIGNoaWxkcmVuOiBqc3hzKFBhbmUsIHsgb25TZWxlY3Rpb25TdGFydDogb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQ6IG9uU2VsZWN0aW9uRW5kLCBvblBhbmVDbGljazogb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXI6IG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZTogb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlOiBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbDogb25QYW5lU2Nyb2xsLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgaXNTZWxlY3Rpbmc6ICEhaXNTZWxlY3RpbmcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIHNlbGVjdGlvbktleVByZXNzZWQ6IHNlbGVjdGlvbktleVByZXNzZWQsIHNlbGVjdGlvbk9uRHJhZzogX3NlbGVjdGlvbk9uRHJhZywgY2hpbGRyZW46IFtjaGlsZHJlbiwgbm9kZXNTZWxlY3Rpb25BY3RpdmUgJiYgKGpzeChOb2Rlc1NlbGVjdGlvbiwgeyBvblNlbGVjdGlvbkNvbnRleHRNZW51OiBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXkgfSkpXSB9KSB9KSk7XG59XG5GbG93UmVuZGVyZXJDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnRmxvd1JlbmRlcmVyJztcbmNvbnN0IEZsb3dSZW5kZXJlciA9IG1lbW8oRmxvd1JlbmRlcmVyQ29tcG9uZW50KTtcblxuY29uc3Qgc2VsZWN0b3IkZCA9IChvbmx5UmVuZGVyVmlzaWJsZSkgPT4gKHMpID0+IHtcbiAgICByZXR1cm4gb25seVJlbmRlclZpc2libGVcbiAgICAgICAgPyBnZXROb2Rlc0luc2lkZShzLm5vZGVMb29rdXAsIHsgeDogMCwgeTogMCwgd2lkdGg6IHMud2lkdGgsIGhlaWdodDogcy5oZWlnaHQgfSwgcy50cmFuc2Zvcm0sIHRydWUpLm1hcCgobm9kZSkgPT4gbm9kZS5pZClcbiAgICAgICAgOiBBcnJheS5mcm9tKHMubm9kZUxvb2t1cC5rZXlzKCkpO1xufTtcbi8qKlxuICogSG9vayBmb3IgZ2V0dGluZyB0aGUgdmlzaWJsZSBub2RlIGlkcyBmcm9tIHRoZSBzdG9yZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBvbmx5UmVuZGVyVmlzaWJsZVxuICogQHJldHVybnMgYXJyYXkgd2l0aCB2aXNpYmxlIG5vZGUgaWRzXG4gKi9cbmZ1bmN0aW9uIHVzZVZpc2libGVOb2RlSWRzKG9ubHlSZW5kZXJWaXNpYmxlKSB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKHNlbGVjdG9yJGQob25seVJlbmRlclZpc2libGUpLCBbb25seVJlbmRlclZpc2libGVdKSwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIG5vZGVJZHM7XG59XG5cbmNvbnN0IHNlbGVjdG9yJGMgPSAocykgPT4gcy51cGRhdGVOb2RlSW50ZXJuYWxzO1xuZnVuY3Rpb24gdXNlUmVzaXplT2JzZXJ2ZXIoKSB7XG4gICAgY29uc3QgdXBkYXRlTm9kZUludGVybmFscyA9IHVzZVN0b3JlKHNlbGVjdG9yJGMpO1xuICAgIGNvbnN0IFtyZXNpemVPYnNlcnZlcl0gPSB1c2VTdGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gZW50cnkudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZXMuc2V0KGlkLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBub2RlRWxlbWVudDogZW50cnkudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBmb3JjZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXBkYXRlTm9kZUludGVybmFscyh1cGRhdGVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgfSwgW3Jlc2l6ZU9ic2VydmVyXSk7XG4gICAgcmV0dXJuIHJlc2l6ZU9ic2VydmVyO1xufVxuXG4vKipcbiAqIEhvb2sgdG8gaGFuZGxlIHRoZSByZXNpemUgb2JzZXJ2YXRpb24gKyBpbnRlcm5hbCB1cGRhdGVzIGZvciB0aGUgcGFzc2VkIG5vZGUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyBub2RlUmVmIC0gcmVmZXJlbmNlIHRvIHRoZSBub2RlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZU9ic2VydmVyKHsgbm9kZSwgbm9kZVR5cGUsIGhhc0RpbWVuc2lvbnMsIHJlc2l6ZU9ic2VydmVyLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG5vZGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3Qgb2JzZXJ2ZWROb2RlID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHByZXZTb3VyY2VQb3NpdGlvbiA9IHVzZVJlZihub2RlLnNvdXJjZVBvc2l0aW9uKTtcbiAgICBjb25zdCBwcmV2VGFyZ2V0UG9zaXRpb24gPSB1c2VSZWYobm9kZS50YXJnZXRQb3NpdGlvbik7XG4gICAgY29uc3QgcHJldlR5cGUgPSB1c2VSZWYobm9kZVR5cGUpO1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6ZWQgPSBoYXNEaW1lbnNpb25zICYmICEhbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQgJiYgIW5vZGUuaGlkZGVuICYmICghaXNJbml0aWFsaXplZCB8fCBvYnNlcnZlZE5vZGUuY3VycmVudCAhPT0gbm9kZVJlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgaWYgKG9ic2VydmVkTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/LnVub2JzZXJ2ZShvYnNlcnZlZE5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlcj8ub2JzZXJ2ZShub2RlUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgb2JzZXJ2ZWROb2RlLmN1cnJlbnQgPSBub2RlUmVmLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9LCBbaXNJbml0aWFsaXplZCwgbm9kZS5oaWRkZW5dKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9ic2VydmVkTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/LnVub2JzZXJ2ZShvYnNlcnZlZE5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZWROb2RlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobm9kZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyB3aGVuIHRoZSB1c2VyIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlcyB0aGUgc291cmNlIG9yIGhhbmRsZSBwb3NpdGlvbiwgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGludGVybmFsc1xuICAgICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIHRoZSBlZGdlcyBhcmUgdXBkYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgIGNvbnN0IHR5cGVDaGFuZ2VkID0gcHJldlR5cGUuY3VycmVudCAhPT0gbm9kZVR5cGU7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQb3NDaGFuZ2VkID0gcHJldlNvdXJjZVBvc2l0aW9uLmN1cnJlbnQgIT09IG5vZGUuc291cmNlUG9zaXRpb247XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQb3NDaGFuZ2VkID0gcHJldlRhcmdldFBvc2l0aW9uLmN1cnJlbnQgIT09IG5vZGUudGFyZ2V0UG9zaXRpb247XG4gICAgICAgICAgICBpZiAodHlwZUNoYW5nZWQgfHwgc291cmNlUG9zQ2hhbmdlZCB8fCB0YXJnZXRQb3NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcHJldlR5cGUuY3VycmVudCA9IG5vZGVUeXBlO1xuICAgICAgICAgICAgICAgIHByZXZTb3VyY2VQb3NpdGlvbi5jdXJyZW50ID0gbm9kZS5zb3VyY2VQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBwcmV2VGFyZ2V0UG9zaXRpb24uY3VycmVudCA9IG5vZGUudGFyZ2V0UG9zaXRpb247XG4gICAgICAgICAgICAgICAgc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZU5vZGVJbnRlcm5hbHMobmV3IE1hcChbW25vZGUuaWQsIHsgaWQ6IG5vZGUuaWQsIG5vZGVFbGVtZW50OiBub2RlUmVmLmN1cnJlbnQsIGZvcmNlOiB0cnVlIH1dXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW25vZGUuaWQsIG5vZGVUeXBlLCBub2RlLnNvdXJjZVBvc2l0aW9uLCBub2RlLnRhcmdldFBvc2l0aW9uXSk7XG4gICAgcmV0dXJuIG5vZGVSZWY7XG59XG5cbmZ1bmN0aW9uIE5vZGVXcmFwcGVyKHsgaWQsIG9uQ2xpY2ssIG9uTW91c2VFbnRlciwgb25Nb3VzZU1vdmUsIG9uTW91c2VMZWF2ZSwgb25Db250ZXh0TWVudSwgb25Eb3VibGVDbGljaywgbm9kZXNEcmFnZ2FibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGUsIHJlc2l6ZU9ic2VydmVyLCBub0RyYWdDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCByZklkLCBub2RlVHlwZXMsIG5vZGVFeHRlbnQsIG5vZGVDbGlja0Rpc3RhbmNlLCBvbkVycm9yLCB9KSB7XG4gICAgY29uc3QgeyBub2RlLCBpbnRlcm5hbHMsIGlzUGFyZW50IH0gPSB1c2VTdG9yZSgocykgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gcy5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgIGNvbnN0IGlzUGFyZW50ID0gcy5wYXJlbnRMb29rdXAuaGFzKGlkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBpbnRlcm5hbHM6IG5vZGUuaW50ZXJuYWxzLFxuICAgICAgICAgICAgaXNQYXJlbnQsXG4gICAgICAgIH07XG4gICAgfSwgc2hhbGxvdyk7XG4gICAgbGV0IG5vZGVUeXBlID0gbm9kZS50eXBlIHx8ICdkZWZhdWx0JztcbiAgICBsZXQgTm9kZUNvbXBvbmVudCA9IG5vZGVUeXBlcz8uW25vZGVUeXBlXSB8fCBidWlsdGluTm9kZVR5cGVzW25vZGVUeXBlXTtcbiAgICBpZiAoTm9kZUNvbXBvbmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9uRXJyb3I/LignMDAzJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDMnXShub2RlVHlwZSkpO1xuICAgICAgICBub2RlVHlwZSA9ICdkZWZhdWx0JztcbiAgICAgICAgTm9kZUNvbXBvbmVudCA9IGJ1aWx0aW5Ob2RlVHlwZXMuZGVmYXVsdDtcbiAgICB9XG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIShub2RlLmRyYWdnYWJsZSB8fCAobm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG5vZGUuZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzU2VsZWN0YWJsZSA9ICEhKG5vZGUuc2VsZWN0YWJsZSB8fCAoZWxlbWVudHNTZWxlY3RhYmxlICYmIHR5cGVvZiBub2RlLnNlbGVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNDb25uZWN0YWJsZSA9ICEhKG5vZGUuY29ubmVjdGFibGUgfHwgKG5vZGVzQ29ubmVjdGFibGUgJiYgdHlwZW9mIG5vZGUuY29ubmVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNGb2N1c2FibGUgPSAhIShub2RlLmZvY3VzYWJsZSB8fCAobm9kZXNGb2N1c2FibGUgJiYgdHlwZW9mIG5vZGUuZm9jdXNhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBoYXNEaW1lbnNpb25zID0gbm9kZUhhc0RpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3Qgbm9kZVJlZiA9IHVzZU5vZGVPYnNlcnZlcih7IG5vZGUsIG5vZGVUeXBlLCBoYXNEaW1lbnNpb25zLCByZXNpemVPYnNlcnZlciB9KTtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHVzZURyYWcoe1xuICAgICAgICBub2RlUmVmLFxuICAgICAgICBkaXNhYmxlZDogbm9kZS5oaWRkZW4gfHwgIWlzRHJhZ2dhYmxlLFxuICAgICAgICBub0RyYWdDbGFzc05hbWUsXG4gICAgICAgIGhhbmRsZVNlbGVjdG9yOiBub2RlLmRyYWdIYW5kbGUsXG4gICAgICAgIG5vZGVJZDogaWQsXG4gICAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgICAgbm9kZUNsaWNrRGlzdGFuY2UsXG4gICAgfSk7XG4gICAgY29uc3QgbW92ZVNlbGVjdGVkTm9kZXMgPSB1c2VNb3ZlU2VsZWN0ZWROb2RlcygpO1xuICAgIGlmIChub2RlLmhpZGRlbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZURpbWVuc2lvbnMgPSBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBpbmxpbmVEaW1lbnNpb25zID0gZ2V0Tm9kZUlubGluZVN0eWxlRGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBoYXNQb2ludGVyRXZlbnRzID0gaXNTZWxlY3RhYmxlIHx8IGlzRHJhZ2dhYmxlIHx8IG9uQ2xpY2sgfHwgb25Nb3VzZUVudGVyIHx8IG9uTW91c2VNb3ZlIHx8IG9uTW91c2VMZWF2ZTtcbiAgICBjb25zdCBvbk1vdXNlRW50ZXJIYW5kbGVyID0gb25Nb3VzZUVudGVyXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbk1vdXNlRW50ZXIoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlSGFuZGxlciA9IG9uTW91c2VNb3ZlXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbk1vdXNlTW92ZShldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlSGFuZGxlciA9IG9uTW91c2VMZWF2ZVxuICAgICAgICA/IChldmVudCkgPT4gb25Nb3VzZUxlYXZlKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkNvbnRleHRNZW51SGFuZGxlciA9IG9uQ29udGV4dE1lbnVcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uQ29udGV4dE1lbnUoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uRG91YmxlQ2xpY2tIYW5kbGVyID0gb25Eb3VibGVDbGlja1xuICAgICAgICA/IChldmVudCkgPT4gb25Eb3VibGVDbGljayhldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25TZWxlY3ROb2RlSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNlbGVjdE5vZGVzT25EcmFnLCBub2RlRHJhZ1RocmVzaG9sZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKGlzU2VsZWN0YWJsZSAmJiAoIXNlbGVjdE5vZGVzT25EcmFnIHx8ICFpc0RyYWdnYWJsZSB8fCBub2RlRHJhZ1RocmVzaG9sZCA+IDApKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGhhbmRsZXIgZ2V0cyBjYWxsZWQgYnkgWFlEcmFnIG9uIGRyYWcgc3RhcnQgd2hlbiBzZWxlY3ROb2Rlc09uRHJhZz10cnVlXG4gICAgICAgICAgICAvLyBoZXJlIHdlIG9ubHkgbmVlZCB0byBjYWxsIGl0IHdoZW4gc2VsZWN0Tm9kZXNPbkRyYWc9ZmFsc2VcbiAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChpc0lucHV0RE9NTm9kZShldmVudC5uYXRpdmVFdmVudCkgfHwgZGlzYWJsZUtleWJvYXJkQTExeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50U2VsZWN0aW9uS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgY29uc3QgdW5zZWxlY3QgPSBldmVudC5rZXkgPT09ICdFc2NhcGUnO1xuICAgICAgICAgICAgaGFuZGxlTm9kZUNsaWNrKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICB1bnNlbGVjdCxcbiAgICAgICAgICAgICAgICBub2RlUmVmLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEcmFnZ2FibGUgJiYgbm9kZS5zZWxlY3RlZCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJyb3dLZXlEaWZmcywgZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgLy8gcHJldmVudCBkZWZhdWx0IHNjcm9sbGluZyBiZWhhdmlvciBvbiBhcnJvdyBrZXkgcHJlc3Mgd2hlbiBub2RlIGlzIG1vdmVkXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZTogYE1vdmVkIHNlbGVjdGVkIG5vZGUgJHtldmVudC5rZXlcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ0Fycm93JywgJycpXG4gICAgICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpfS4gTmV3IHBvc2l0aW9uLCB4OiAke35+aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueH0sIHk6ICR7fn5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55fWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vdmVTZWxlY3RlZE5vZGVzKHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGFycm93S2V5RGlmZnNbZXZlbnQua2V5XSxcbiAgICAgICAgICAgICAgICBmYWN0b3I6IGV2ZW50LnNoaWZ0S2V5ID8gNCA6IDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFtcbiAgICAgICAgICAgICdyZWFjdC1mbG93X19ub2RlJyxcbiAgICAgICAgICAgIGByZWFjdC1mbG93X19ub2RlLSR7bm9kZVR5cGV9YCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG92ZXJ3cml0YWJsZSBieSBwYXNzaW5nIGBub3BhbmAgYXMgYSBjbGFzcyBuYW1lXG4gICAgICAgICAgICAgICAgW25vUGFuQ2xhc3NOYW1lXTogaXNEcmFnZ2FibGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IG5vZGUuc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIHBhcmVudDogaXNQYXJlbnQsXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pLCByZWY6IG5vZGVSZWYsIHN0eWxlOiB7XG4gICAgICAgICAgICB6SW5kZXg6IGludGVybmFscy56LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueH1weCwke2ludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnl9cHgpYCxcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IGhhc1BvaW50ZXJFdmVudHMgPyAnYWxsJyA6ICdub25lJyxcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IGhhc0RpbWVuc2lvbnMgPyAndmlzaWJsZScgOiAnaGlkZGVuJyxcbiAgICAgICAgICAgIC4uLm5vZGUuc3R5bGUsXG4gICAgICAgICAgICAuLi5pbmxpbmVEaW1lbnNpb25zLFxuICAgICAgICB9LCBcImRhdGEtaWRcIjogaWQsIFwiZGF0YS10ZXN0aWRcIjogYHJmX19ub2RlLSR7aWR9YCwgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXJIYW5kbGVyLCBvbk1vdXNlTW92ZTogb25Nb3VzZU1vdmVIYW5kbGVyLCBvbk1vdXNlTGVhdmU6IG9uTW91c2VMZWF2ZUhhbmRsZXIsIG9uQ29udGV4dE1lbnU6IG9uQ29udGV4dE1lbnVIYW5kbGVyLCBvbkNsaWNrOiBvblNlbGVjdE5vZGVIYW5kbGVyLCBvbkRvdWJsZUNsaWNrOiBvbkRvdWJsZUNsaWNrSGFuZGxlciwgb25LZXlEb3duOiBpc0ZvY3VzYWJsZSA/IG9uS2V5RG93biA6IHVuZGVmaW5lZCwgdGFiSW5kZXg6IGlzRm9jdXNhYmxlID8gMCA6IHVuZGVmaW5lZCwgcm9sZTogaXNGb2N1c2FibGUgPyAnYnV0dG9uJyA6IHVuZGVmaW5lZCwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGRpc2FibGVLZXlib2FyZEExMXkgPyB1bmRlZmluZWQgOiBgJHtBUklBX05PREVfREVTQ19LRVl9LSR7cmZJZH1gLCBcImFyaWEtbGFiZWxcIjogbm9kZS5hcmlhTGFiZWwsIGNoaWxkcmVuOiBqc3goUHJvdmlkZXIsIHsgdmFsdWU6IGlkLCBjaGlsZHJlbjoganN4KE5vZGVDb21wb25lbnQsIHsgaWQ6IGlkLCBkYXRhOiBub2RlLmRhdGEsIHR5cGU6IG5vZGVUeXBlLCBwb3NpdGlvbkFic29sdXRlWDogaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCwgcG9zaXRpb25BYnNvbHV0ZVk6IGludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnksIHNlbGVjdGVkOiBub2RlLnNlbGVjdGVkID8/IGZhbHNlLCBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsIGRyYWdnYWJsZTogaXNEcmFnZ2FibGUsIGRlbGV0YWJsZTogbm9kZS5kZWxldGFibGUgPz8gdHJ1ZSwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSwgc291cmNlUG9zaXRpb246IG5vZGUuc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiBub2RlLnRhcmdldFBvc2l0aW9uLCBkcmFnZ2luZzogZHJhZ2dpbmcsIGRyYWdIYW5kbGU6IG5vZGUuZHJhZ0hhbmRsZSwgekluZGV4OiBpbnRlcm5hbHMueiwgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsIC4uLm5vZGVEaW1lbnNpb25zIH0pIH0pIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkYiA9IChzKSA9PiAoe1xuICAgIG5vZGVzRHJhZ2dhYmxlOiBzLm5vZGVzRHJhZ2dhYmxlLFxuICAgIG5vZGVzQ29ubmVjdGFibGU6IHMubm9kZXNDb25uZWN0YWJsZSxcbiAgICBub2Rlc0ZvY3VzYWJsZTogcy5ub2Rlc0ZvY3VzYWJsZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIG9uRXJyb3I6IHMub25FcnJvcixcbn0pO1xuZnVuY3Rpb24gTm9kZVJlbmRlcmVyQ29tcG9uZW50KHByb3BzKSB7XG4gICAgY29uc3QgeyBub2Rlc0RyYWdnYWJsZSwgbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgb25FcnJvciB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkYiwgc2hhbGxvdyk7XG4gICAgY29uc3Qgbm9kZUlkcyA9IHVzZVZpc2libGVOb2RlSWRzKHByb3BzLm9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMpO1xuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gdXNlUmVzaXplT2JzZXJ2ZXIoKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19ub2Rlc1wiLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBub2RlSWRzLm1hcCgobm9kZUlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gVGhlIHNwbGl0IG9mIHJlc3BvbnNpYmlsaXRpZXMgYmV0d2VlbiBOb2RlUmVuZGVyZXIgYW5kXG4gICAgICAgICAgICAvLyBOb2RlQ29tcG9uZW50V3JhcHBlciBtYXkgYXBwZWFyIHdlaXJkLiBIb3dldmVyLCBpdOKAmXMgZGVzaWduZWQgdG9cbiAgICAgICAgICAgIC8vIG1pbmltaXplIHRoZSBjb3N0IG9mIHVwZGF0ZXMgd2hlbiBpbmRpdmlkdWFsIG5vZGVzIGNoYW5nZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgd2hlbiB5b3XigJlyZSBkcmFnZ2luZyBhIHNpbmdsZSBub2RlLCB0aGF0IG5vZGUgZ2V0c1xuICAgICAgICAgICAgLy8gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBwZXIgc2Vjb25kLiBJZiBgTm9kZVJlbmRlcmVyYCB3ZXJlIHRvIHVwZGF0ZVxuICAgICAgICAgICAgLy8gZXZlcnkgdGltZSwgaXQgd291bGQgaGF2ZSB0byByZS1ydW4gdGhlIGBub2Rlcy5tYXAoKWAgbG9vcCBldmVyeVxuICAgICAgICAgICAgLy8gdGltZS4gVGhpcyBnZXRzIHByaWNleSB3aXRoIGh1bmRyZWRzIG9mIG5vZGVzLCBlc3BlY2lhbGx5IGlmIGV2ZXJ5XG4gICAgICAgICAgICAvLyBsb29wIGN5Y2xlIGRvZXMgbW9yZSB0aGFuIGp1c3QgcmVuZGVyaW5nIGEgSlNYIGVsZW1lbnQhXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQXMgYSByZXN1bHQgb2YgdGhpcyBjaG9pY2UsIHdlIHRvb2sgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgLy8gZGVjaXNpb25zOlxuICAgICAgICAgICAgLy8gLSBOb2RlUmVuZGVyZXIgc3Vic2NyaWJlcyAqb25seSogdG8gbm9kZSBJRHMg4oCTIGFuZCB0aGVyZWZvcmVcbiAgICAgICAgICAgIC8vICAgcmVyZW5kZXIgKm9ubHkqIHdoZW4gdmlzaWJsZSBub2RlcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZC5cbiAgICAgICAgICAgIC8vIC0gTm9kZVJlbmRlcmVyIHBlcmZvcm1zIGFsbCBvcGVyYXRpb25zIHRoZSByZXN1bHQgb2Ygd2hpY2ggY2FuIGJlXG4gICAgICAgICAgICAvLyAgIHNoYXJlZCBiZXR3ZWVuIG5vZGVzIChzdWNoIGFzIGNyZWF0aW5nIHRoZSBgUmVzaXplT2JzZXJ2ZXJgXG4gICAgICAgICAgICAvLyAgIGluc3RhbmNlLCBvciBzdWJzY3JpYmluZyB0byBgc2VsZWN0b3JgKS4gVGhpcyBtZWFucyBleHRyYSBwcm9wXG4gICAgICAgICAgICAvLyAgIGRyaWxsaW5nIGludG8gYE5vZGVDb21wb25lbnRXcmFwcGVyYCwgYnV0IGl0IG1lYW5zIHdlIG5lZWQgdG8gcnVuXG4gICAgICAgICAgICAvLyAgIHRoZXNlIG9wZXJhdGlvbnMgb25seSBvbmNlIOKAkyBpbnN0ZWFkIG9mIG9uY2UgcGVyIG5vZGUuXG4gICAgICAgICAgICAvLyAtIEFueSBvcGVyYXRpb25zIHRoYXQgeW914oCZZCBub3JtYWxseSB3cml0ZSBpbnNpZGUgYG5vZGVzLm1hcGAgYXJlXG4gICAgICAgICAgICAvLyAgIG1vdmVkIGludG8gYE5vZGVDb21wb25lbnRXcmFwcGVyYC4gVGhpcyBlbnN1cmVzIHRoZXkgYXJlXG4gICAgICAgICAgICAvLyAgIG1lbW9yaXplZCDigJMgc28gaWYgYE5vZGVSZW5kZXJlcmAgKmhhcyogdG8gcmVyZW5kZXIsIGl0IG9ubHlcbiAgICAgICAgICAgIC8vICAgbmVlZHMgdG8gcmVnZW5lcmF0ZSB0aGUgbGlzdCBvZiBub2Rlcywgbm90aGluZyBlbHNlLlxuICAgICAgICAgICAganN4KE5vZGVXcmFwcGVyLCB7IGlkOiBub2RlSWQsIG5vZGVUeXBlczogcHJvcHMubm9kZVR5cGVzLCBub2RlRXh0ZW50OiBwcm9wcy5ub2RlRXh0ZW50LCBvbkNsaWNrOiBwcm9wcy5vbk5vZGVDbGljaywgb25Nb3VzZUVudGVyOiBwcm9wcy5vbk5vZGVNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogcHJvcHMub25Ob2RlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IHByb3BzLm9uTm9kZU1vdXNlTGVhdmUsIG9uQ29udGV4dE1lbnU6IHByb3BzLm9uTm9kZUNvbnRleHRNZW51LCBvbkRvdWJsZUNsaWNrOiBwcm9wcy5vbk5vZGVEb3VibGVDbGljaywgbm9EcmFnQ2xhc3NOYW1lOiBwcm9wcy5ub0RyYWdDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBwcm9wcy5ub1BhbkNsYXNzTmFtZSwgcmZJZDogcHJvcHMucmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeTogcHJvcHMuZGlzYWJsZUtleWJvYXJkQTExeSwgcmVzaXplT2JzZXJ2ZXI6IHJlc2l6ZU9ic2VydmVyLCBub2Rlc0RyYWdnYWJsZTogbm9kZXNEcmFnZ2FibGUsIG5vZGVzQ29ubmVjdGFibGU6IG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlOiBub2Rlc0ZvY3VzYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIG5vZGVDbGlja0Rpc3RhbmNlOiBwcm9wcy5ub2RlQ2xpY2tEaXN0YW5jZSwgb25FcnJvcjogb25FcnJvciB9LCBub2RlSWQpKTtcbiAgICAgICAgfSkgfSkpO1xufVxuTm9kZVJlbmRlcmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ05vZGVSZW5kZXJlcic7XG5jb25zdCBOb2RlUmVuZGVyZXIgPSBtZW1vKE5vZGVSZW5kZXJlckNvbXBvbmVudCk7XG5cbi8qKlxuICogSG9vayBmb3IgZ2V0dGluZyB0aGUgdmlzaWJsZSBlZGdlIGlkcyBmcm9tIHRoZSBzdG9yZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBvbmx5UmVuZGVyVmlzaWJsZVxuICogQHJldHVybnMgYXJyYXkgd2l0aCB2aXNpYmxlIGVkZ2UgaWRzXG4gKi9cbmZ1bmN0aW9uIHVzZVZpc2libGVFZGdlSWRzKG9ubHlSZW5kZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgZWRnZUlkcyA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiB7XG4gICAgICAgIGlmICghb25seVJlbmRlclZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzLmVkZ2VzLm1hcCgoZWRnZSkgPT4gZWRnZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlzaWJsZUVkZ2VJZHMgPSBbXTtcbiAgICAgICAgaWYgKHMud2lkdGggJiYgcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWRnZSBvZiBzLmVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IHMubm9kZUxvb2t1cC5nZXQoZWRnZS5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIGlzRWRnZVZpc2libGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHMudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlRWRnZUlkcy5wdXNoKGVkZ2UuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlzaWJsZUVkZ2VJZHM7XG4gICAgfSwgW29ubHlSZW5kZXJWaXNpYmxlXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBlZGdlSWRzO1xufVxuXG5jb25zdCBBcnJvd1N5bWJvbCA9ICh7IGNvbG9yID0gJ25vbmUnLCBzdHJva2VXaWR0aCA9IDEgfSkgPT4ge1xuICAgIHJldHVybiAoanN4KFwicG9seWxpbmVcIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiBjb2xvcixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB9LCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIGZpbGw6IFwibm9uZVwiLCBwb2ludHM6IFwiLTUsLTQgMCwwIC01LDRcIiB9KSk7XG59O1xuY29uc3QgQXJyb3dDbG9zZWRTeW1ib2wgPSAoeyBjb2xvciA9ICdub25lJywgc3Ryb2tlV2lkdGggPSAxIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChcInBvbHlsaW5lXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogY29sb3IsXG4gICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB9LCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIHBvaW50czogXCItNSwtNCAwLDAgLTUsNCAtNSwtNFwiIH0pKTtcbn07XG5jb25zdCBNYXJrZXJTeW1ib2xzID0ge1xuICAgIFtNYXJrZXJUeXBlLkFycm93XTogQXJyb3dTeW1ib2wsXG4gICAgW01hcmtlclR5cGUuQXJyb3dDbG9zZWRdOiBBcnJvd0Nsb3NlZFN5bWJvbCxcbn07XG5mdW5jdGlvbiB1c2VNYXJrZXJTeW1ib2wodHlwZSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBzeW1ib2wgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3ltYm9sRXhpc3RzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE1hcmtlclN5bWJvbHMsIHR5cGUpO1xuICAgICAgICBpZiAoIXN5bWJvbEV4aXN0cykge1xuICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwOScsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA5J10odHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hcmtlclN5bWJvbHNbdHlwZV07XG4gICAgfSwgW3R5cGVdKTtcbiAgICByZXR1cm4gc3ltYm9sO1xufVxuXG5jb25zdCBNYXJrZXIgPSAoeyBpZCwgdHlwZSwgY29sb3IsIHdpZHRoID0gMTIuNSwgaGVpZ2h0ID0gMTIuNSwgbWFya2VyVW5pdHMgPSAnc3Ryb2tlV2lkdGgnLCBzdHJva2VXaWR0aCwgb3JpZW50ID0gJ2F1dG8tc3RhcnQtcmV2ZXJzZScsIH0pID0+IHtcbiAgICBjb25zdCBTeW1ib2wgPSB1c2VNYXJrZXJTeW1ib2wodHlwZSk7XG4gICAgaWYgKCFTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwibWFya2VyXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2Fycm93aGVhZFwiLCBpZDogaWQsIG1hcmtlcldpZHRoOiBgJHt3aWR0aH1gLCBtYXJrZXJIZWlnaHQ6IGAke2hlaWdodH1gLCB2aWV3Qm94OiBcIi0xMCAtMTAgMjAgMjBcIiwgbWFya2VyVW5pdHM6IG1hcmtlclVuaXRzLCBvcmllbnQ6IG9yaWVudCwgcmVmWDogXCIwXCIsIHJlZlk6IFwiMFwiLCBjaGlsZHJlbjoganN4KFN5bWJvbCwgeyBjb2xvcjogY29sb3IsIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCB9KSB9KSk7XG59O1xuLy8gd2hlbiB5b3UgaGF2ZSBtdWx0aXBsZSBmbG93cyBvbiBhIHBhZ2UgYW5kIHlvdSBoaWRlIHRoZSBmaXJzdCBvbmUsIHRoZSBvdGhlciBvbmVzIGhhdmUgbm8gbWFya2VycyBhbnltb3JlXG4vLyB3aGVuIHRoZXkgZG8gaGF2ZSBtYXJrZXJzIHdpdGggdGhlIHNhbWUgaWRzLiBUbyBwcmV2ZW50IHRoaXMgdGhlIHVzZXIgY2FuIHBhc3MgYSB1bmlxdWUgaWQgdG8gdGhlIHJlYWN0IGZsb3cgd3JhcHBlclxuLy8gdGhhdCB3ZSBjYW4gdGhlbiB1c2UgZm9yIGNyZWF0aW5nIG91ciB1bmlxdWUgbWFya2VyIGlkc1xuY29uc3QgTWFya2VyRGVmaW5pdGlvbnMgPSAoeyBkZWZhdWx0Q29sb3IsIHJmSWQgfSkgPT4ge1xuICAgIGNvbnN0IGVkZ2VzID0gdXNlU3RvcmUoKHMpID0+IHMuZWRnZXMpO1xuICAgIGNvbnN0IGRlZmF1bHRFZGdlT3B0aW9ucyA9IHVzZVN0b3JlKChzKSA9PiBzLmRlZmF1bHRFZGdlT3B0aW9ucyk7XG4gICAgY29uc3QgbWFya2VycyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBtYXJrZXJzID0gY3JlYXRlTWFya2VySWRzKGVkZ2VzLCB7XG4gICAgICAgICAgICBpZDogcmZJZCxcbiAgICAgICAgICAgIGRlZmF1bHRDb2xvcixcbiAgICAgICAgICAgIGRlZmF1bHRNYXJrZXJTdGFydDogZGVmYXVsdEVkZ2VPcHRpb25zPy5tYXJrZXJTdGFydCxcbiAgICAgICAgICAgIGRlZmF1bHRNYXJrZXJFbmQ6IGRlZmF1bHRFZGdlT3B0aW9ucz8ubWFya2VyRW5kLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfSwgW2VkZ2VzLCBkZWZhdWx0RWRnZU9wdGlvbnMsIHJmSWQsIGRlZmF1bHRDb2xvcl0pO1xuICAgIGlmICghbWFya2Vycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX21hcmtlclwiLCBjaGlsZHJlbjoganN4KFwiZGVmc1wiLCB7IGNoaWxkcmVuOiBtYXJrZXJzLm1hcCgobWFya2VyKSA9PiAoanN4KE1hcmtlciwgeyBpZDogbWFya2VyLmlkLCB0eXBlOiBtYXJrZXIudHlwZSwgY29sb3I6IG1hcmtlci5jb2xvciwgd2lkdGg6IG1hcmtlci53aWR0aCwgaGVpZ2h0OiBtYXJrZXIuaGVpZ2h0LCBtYXJrZXJVbml0czogbWFya2VyLm1hcmtlclVuaXRzLCBzdHJva2VXaWR0aDogbWFya2VyLnN0cm9rZVdpZHRoLCBvcmllbnQ6IG1hcmtlci5vcmllbnQgfSwgbWFya2VyLmlkKSkpIH0pIH0pKTtcbn07XG5NYXJrZXJEZWZpbml0aW9ucy5kaXNwbGF5TmFtZSA9ICdNYXJrZXJEZWZpbml0aW9ucyc7XG52YXIgTWFya2VyRGVmaW5pdGlvbnMkMSA9IG1lbW8oTWFya2VyRGVmaW5pdGlvbnMpO1xuXG5mdW5jdGlvbiBFZGdlVGV4dENvbXBvbmVudCh7IHgsIHksIGxhYmVsLCBsYWJlbFN0eWxlID0ge30sIGxhYmVsU2hvd0JnID0gdHJ1ZSwgbGFiZWxCZ1N0eWxlID0ge30sIGxhYmVsQmdQYWRkaW5nID0gWzIsIDRdLCBsYWJlbEJnQm9yZGVyUmFkaXVzID0gMiwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgW2VkZ2VUZXh0QmJveCwgc2V0RWRnZVRleHRCYm94XSA9IHVzZVN0YXRlKHsgeDogMSwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbiAgICBjb25zdCBlZGdlVGV4dENsYXNzZXMgPSBjYyhbJ3JlYWN0LWZsb3dfX2VkZ2UtdGV4dHdyYXBwZXInLCBjbGFzc05hbWVdKTtcbiAgICBjb25zdCBlZGdlVGV4dFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWRnZVRleHRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dEJib3ggPSBlZGdlVGV4dFJlZi5jdXJyZW50LmdldEJCb3goKTtcbiAgICAgICAgICAgIHNldEVkZ2VUZXh0QmJveCh7XG4gICAgICAgICAgICAgICAgeDogdGV4dEJib3gueCxcbiAgICAgICAgICAgICAgICB5OiB0ZXh0QmJveC55LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0ZXh0QmJveC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRleHRCYm94LmhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2xhYmVsXSk7XG4gICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWxhYmVsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeHMoXCJnXCIsIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7eCAtIGVkZ2VUZXh0QmJveC53aWR0aCAvIDJ9ICR7eSAtIGVkZ2VUZXh0QmJveC5oZWlnaHQgLyAyfSlgLCBjbGFzc05hbWU6IGVkZ2VUZXh0Q2xhc3NlcywgdmlzaWJpbGl0eTogZWRnZVRleHRCYm94LndpZHRoID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsIC4uLnJlc3QsIGNoaWxkcmVuOiBbbGFiZWxTaG93QmcgJiYgKGpzeChcInJlY3RcIiwgeyB3aWR0aDogZWRnZVRleHRCYm94LndpZHRoICsgMiAqIGxhYmVsQmdQYWRkaW5nWzBdLCB4OiAtbGFiZWxCZ1BhZGRpbmdbMF0sIHk6IC1sYWJlbEJnUGFkZGluZ1sxXSwgaGVpZ2h0OiBlZGdlVGV4dEJib3guaGVpZ2h0ICsgMiAqIGxhYmVsQmdQYWRkaW5nWzFdLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZS10ZXh0YmdcIiwgc3R5bGU6IGxhYmVsQmdTdHlsZSwgcng6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHJ5OiBsYWJlbEJnQm9yZGVyUmFkaXVzIH0pKSwganN4KFwidGV4dFwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLXRleHRcIiwgeTogZWRnZVRleHRCYm94LmhlaWdodCAvIDIsIGR5OiBcIjAuM2VtXCIsIHJlZjogZWRnZVRleHRSZWYsIHN0eWxlOiBsYWJlbFN0eWxlLCBjaGlsZHJlbjogbGFiZWwgfSksIGNoaWxkcmVuXSB9KSk7XG59XG5FZGdlVGV4dENvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdFZGdlVGV4dCc7XG5jb25zdCBFZGdlVGV4dCA9IG1lbW8oRWRnZVRleHRDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBCYXNlRWRnZSh7IHBhdGgsIGxhYmVsWCwgbGFiZWxZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIGludGVyYWN0aW9uV2lkdGggPSAyMCwgLi4ucHJvcHMgfSkge1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwgeyAuLi5wcm9wcywgZDogcGF0aCwgZmlsbDogXCJub25lXCIsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19lZGdlLXBhdGgnLCBwcm9wcy5jbGFzc05hbWVdKSB9KSwgaW50ZXJhY3Rpb25XaWR0aCAmJiAoanN4KFwicGF0aFwiLCB7IGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBzdHJva2VPcGFjaXR5OiAwLCBzdHJva2VXaWR0aDogaW50ZXJhY3Rpb25XaWR0aCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtaW50ZXJhY3Rpb25cIiB9KSksIGxhYmVsICYmIGlzTnVtZXJpYyhsYWJlbFgpICYmIGlzTnVtZXJpYyhsYWJlbFkpID8gKGpzeChFZGdlVGV4dCwgeyB4OiBsYWJlbFgsIHk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMgfSkpIDogbnVsbF0gfSkpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250cm9sKHsgcG9zLCB4MSwgeTEsIHgyLCB5MiB9KSB7XG4gICAgaWYgKHBvcyA9PT0gUG9zaXRpb24uTGVmdCB8fCBwb3MgPT09IFBvc2l0aW9uLlJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBbMC41ICogKHgxICsgeDIpLCB5MV07XG4gICAgfVxuICAgIHJldHVybiBbeDEsIDAuNSAqICh5MSArIHkyKV07XG59XG5mdW5jdGlvbiBnZXRTaW1wbGVCZXppZXJQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCB9KSB7XG4gICAgY29uc3QgW3NvdXJjZUNvbnRyb2xYLCBzb3VyY2VDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgeDE6IHNvdXJjZVgsXG4gICAgICAgIHkxOiBzb3VyY2VZLFxuICAgICAgICB4MjogdGFyZ2V0WCxcbiAgICAgICAgeTI6IHRhcmdldFksXG4gICAgfSk7XG4gICAgY29uc3QgW3RhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWV0gPSBnZXRDb250cm9sKHtcbiAgICAgICAgcG9zOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgeDE6IHRhcmdldFgsXG4gICAgICAgIHkxOiB0YXJnZXRZLFxuICAgICAgICB4Mjogc291cmNlWCxcbiAgICAgICAgeTI6IHNvdXJjZVksXG4gICAgfSk7XG4gICAgY29uc3QgW2xhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEJlemllckVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgICAgICBzb3VyY2VDb250cm9sWCxcbiAgICAgICAgc291cmNlQ29udHJvbFksXG4gICAgICAgIHRhcmdldENvbnRyb2xYLFxuICAgICAgICB0YXJnZXRDb250cm9sWSxcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBgTSR7c291cmNlWH0sJHtzb3VyY2VZfSBDJHtzb3VyY2VDb250cm9sWH0sJHtzb3VyY2VDb250cm9sWX0gJHt0YXJnZXRDb250cm9sWH0sJHt0YXJnZXRDb250cm9sWX0gJHt0YXJnZXRYfSwke3RhcmdldFl9YCxcbiAgICAgICAgbGFiZWxYLFxuICAgICAgICBsYWJlbFksXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNpbXBsZUJlemllckVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFNpbXBsZUJlemllclBhdGgoe1xuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldFgsXG4gICAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuY29uc3QgU2ltcGxlQmV6aWVyRWRnZSA9IGNyZWF0ZVNpbXBsZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbmNvbnN0IFNpbXBsZUJlemllckVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVNpbXBsZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuU2ltcGxlQmV6aWVyRWRnZS5kaXNwbGF5TmFtZSA9ICdTaW1wbGVCZXppZXJFZGdlJztcblNpbXBsZUJlemllckVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVTbW9vdGhTdGVwRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgcGF0aE9wdGlvbnMsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAgICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgICAgICB0YXJnZXRYLFxuICAgICAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBwYXRoT3B0aW9ucz8uYm9yZGVyUmFkaXVzLFxuICAgICAgICAgICAgb2Zmc2V0OiBwYXRoT3B0aW9ucz8ub2Zmc2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goQmFzZUVkZ2UsIHsgaWQ6IF9pZCwgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICB9KTtcbn1cbmNvbnN0IFNtb290aFN0ZXBFZGdlID0gY3JlYXRlU21vb3RoU3RlcEVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbmNvbnN0IFNtb290aFN0ZXBFZGdlSW50ZXJuYWwgPSBjcmVhdGVTbW9vdGhTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TbW9vdGhTdGVwRWRnZS5kaXNwbGF5TmFtZSA9ICdTbW9vdGhTdGVwRWRnZSc7XG5TbW9vdGhTdGVwRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1Ntb290aFN0ZXBFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVTdGVwRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIC4uLnByb3BzIH0pID0+IHtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goU21vb3RoU3RlcEVkZ2UsIHsgLi4ucHJvcHMsIGlkOiBfaWQsIHBhdGhPcHRpb25zOiB1c2VNZW1vKCgpID0+ICh7IGJvcmRlclJhZGl1czogMCwgb2Zmc2V0OiBwcm9wcy5wYXRoT3B0aW9ucz8ub2Zmc2V0IH0pLCBbcHJvcHMucGF0aE9wdGlvbnM/Lm9mZnNldF0pIH0pKTtcbiAgICB9KTtcbn1cbmNvbnN0IFN0ZXBFZGdlID0gY3JlYXRlU3RlcEVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbmNvbnN0IFN0ZXBFZGdlSW50ZXJuYWwgPSBjcmVhdGVTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TdGVwRWRnZS5kaXNwbGF5TmFtZSA9ICdTdGVwRWRnZSc7XG5TdGVwRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1N0ZXBFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVTdHJhaWdodEVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTdHJhaWdodFBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuY29uc3QgU3RyYWlnaHRFZGdlID0gY3JlYXRlU3RyYWlnaHRFZGdlKHsgaXNJbnRlcm5hbDogZmFsc2UgfSk7XG5jb25zdCBTdHJhaWdodEVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVN0cmFpZ2h0RWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TdHJhaWdodEVkZ2UuZGlzcGxheU5hbWUgPSAnU3RyYWlnaHRFZGdlJztcblN0cmFpZ2h0RWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1N0cmFpZ2h0RWRnZUludGVybmFsJztcblxuZnVuY3Rpb24gY3JlYXRlQmV6aWVyRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgcGF0aE9wdGlvbnMsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldEJlemllclBhdGgoe1xuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldFgsXG4gICAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgICAgICBjdXJ2YXR1cmU6IHBhdGhPcHRpb25zPy5jdXJ2YXR1cmUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuY29uc3QgQmV6aWVyRWRnZSA9IGNyZWF0ZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbmNvbnN0IEJlemllckVkZ2VJbnRlcm5hbCA9IGNyZWF0ZUJlemllckVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuQmV6aWVyRWRnZS5kaXNwbGF5TmFtZSA9ICdCZXppZXJFZGdlJztcbkJlemllckVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdCZXppZXJFZGdlSW50ZXJuYWwnO1xuXG5jb25zdCBidWlsdGluRWRnZVR5cGVzID0ge1xuICAgIGRlZmF1bHQ6IEJlemllckVkZ2VJbnRlcm5hbCxcbiAgICBzdHJhaWdodDogU3RyYWlnaHRFZGdlSW50ZXJuYWwsXG4gICAgc3RlcDogU3RlcEVkZ2VJbnRlcm5hbCxcbiAgICBzbW9vdGhzdGVwOiBTbW9vdGhTdGVwRWRnZUludGVybmFsLFxuICAgIHNpbXBsZWJlemllcjogU2ltcGxlQmV6aWVyRWRnZUludGVybmFsLFxufTtcbmNvbnN0IG51bGxQb3NpdGlvbiA9IHtcbiAgICBzb3VyY2VYOiBudWxsLFxuICAgIHNvdXJjZVk6IG51bGwsXG4gICAgdGFyZ2V0WDogbnVsbCxcbiAgICB0YXJnZXRZOiBudWxsLFxuICAgIHNvdXJjZVBvc2l0aW9uOiBudWxsLFxuICAgIHRhcmdldFBvc2l0aW9uOiBudWxsLFxufTtcblxuY29uc3Qgc2hpZnRYID0gKHgsIHNoaWZ0LCBwb3NpdGlvbikgPT4ge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uTGVmdClcbiAgICAgICAgcmV0dXJuIHggLSBzaGlmdDtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLlJpZ2h0KVxuICAgICAgICByZXR1cm4geCArIHNoaWZ0O1xuICAgIHJldHVybiB4O1xufTtcbmNvbnN0IHNoaWZ0WSA9ICh5LCBzaGlmdCwgcG9zaXRpb24pID0+IHtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLlRvcClcbiAgICAgICAgcmV0dXJuIHkgLSBzaGlmdDtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkJvdHRvbSlcbiAgICAgICAgcmV0dXJuIHkgKyBzaGlmdDtcbiAgICByZXR1cm4geTtcbn07XG5jb25zdCBFZGdlVXBkYXRlckNsYXNzTmFtZSA9ICdyZWFjdC1mbG93X19lZGdldXBkYXRlcic7XG5mdW5jdGlvbiBFZGdlQW5jaG9yKHsgcG9zaXRpb24sIGNlbnRlclgsIGNlbnRlclksIHJhZGl1cyA9IDEwLCBvbk1vdXNlRG93biwgb25Nb3VzZUVudGVyLCBvbk1vdXNlT3V0LCB0eXBlLCB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJjaXJjbGVcIiwgeyBvbk1vdXNlRG93bjogb25Nb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvbk1vdXNlT3V0LCBjbGFzc05hbWU6IGNjKFtFZGdlVXBkYXRlckNsYXNzTmFtZSwgYCR7RWRnZVVwZGF0ZXJDbGFzc05hbWV9LSR7dHlwZX1gXSksIGN4OiBzaGlmdFgoY2VudGVyWCwgcmFkaXVzLCBwb3NpdGlvbiksIGN5OiBzaGlmdFkoY2VudGVyWSwgcmFkaXVzLCBwb3NpdGlvbiksIHI6IHJhZGl1cywgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsIGZpbGw6IFwidHJhbnNwYXJlbnRcIiB9KSk7XG59XG5cbmZ1bmN0aW9uIEVkZ2VVcGRhdGVBbmNob3JzKHsgaXNSZWNvbm5lY3RhYmxlLCByZWNvbm5lY3RSYWRpdXMsIGVkZ2UsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBzZXRSZWNvbm5lY3RpbmcsIHNldFVwZGF0ZUhvdmVyLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGhhbmRsZUVkZ2VVcGRhdGVyID0gKGV2ZW50LCBvcHBvc2l0ZUhhbmRsZSkgPT4ge1xuICAgICAgICAvLyBhdm9pZCB0cmlnZ2VyaW5nIGVkZ2UgdXBkYXRlciBpZiBtb3VzZSBidG4gaXMgbm90IGxlZnRcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYXV0b1Bhbk9uQ29ubmVjdCwgZG9tTm9kZSwgaXNWYWxpZENvbm5lY3Rpb24sIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uUmFkaXVzLCBsaWIsIG9uQ29ubmVjdFN0YXJ0LCBvbkNvbm5lY3RFbmQsIGNhbmNlbENvbm5lY3Rpb24sIG5vZGVMb29rdXAsIHJmSWQ6IGZsb3dJZCwgcGFuQnksIHVwZGF0ZUNvbm5lY3Rpb24sIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBpc1RhcmdldCA9IG9wcG9zaXRlSGFuZGxlLnR5cGUgPT09ICd0YXJnZXQnO1xuICAgICAgICBzZXRSZWNvbm5lY3RpbmcodHJ1ZSk7XG4gICAgICAgIG9uUmVjb25uZWN0U3RhcnQ/LihldmVudCwgZWRnZSwgb3Bwb3NpdGVIYW5kbGUudHlwZSk7XG4gICAgICAgIGNvbnN0IF9vblJlY29ubmVjdEVuZCA9IChldnQsIGNvbm5lY3Rpb25TdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc2V0UmVjb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIG9uUmVjb25uZWN0RW5kPy4oZXZ0LCBlZGdlLCBvcHBvc2l0ZUhhbmRsZS50eXBlLCBjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkNvbm5lY3RFZGdlID0gKGNvbm5lY3Rpb24pID0+IG9uUmVjb25uZWN0Py4oZWRnZSwgY29ubmVjdGlvbik7XG4gICAgICAgIFhZSGFuZGxlLm9uUG9pbnRlckRvd24oZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgIGF1dG9QYW5PbkNvbm5lY3QsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25SYWRpdXMsXG4gICAgICAgICAgICBkb21Ob2RlLFxuICAgICAgICAgICAgaGFuZGxlSWQ6IG9wcG9zaXRlSGFuZGxlLmlkLFxuICAgICAgICAgICAgbm9kZUlkOiBvcHBvc2l0ZUhhbmRsZS5ub2RlSWQsXG4gICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICBlZGdlVXBkYXRlclR5cGU6IG9wcG9zaXRlSGFuZGxlLnR5cGUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBmbG93SWQsXG4gICAgICAgICAgICBjYW5jZWxDb25uZWN0aW9uLFxuICAgICAgICAgICAgcGFuQnksXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgIG9uQ29ubmVjdDogb25Db25uZWN0RWRnZSxcbiAgICAgICAgICAgIG9uQ29ubmVjdFN0YXJ0LFxuICAgICAgICAgICAgb25Db25uZWN0RW5kLFxuICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ6IF9vblJlY29ubmVjdEVuZCxcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb24sXG4gICAgICAgICAgICBnZXRUcmFuc2Zvcm06ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtLFxuICAgICAgICAgICAgZ2V0RnJvbUhhbmRsZTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5jb25uZWN0aW9uLmZyb21IYW5kbGUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24gPSAoZXZlbnQpID0+IGhhbmRsZUVkZ2VVcGRhdGVyKGV2ZW50LCB7IG5vZGVJZDogZWRnZS50YXJnZXQsIGlkOiBlZGdlLnRhcmdldEhhbmRsZSA/PyBudWxsLCB0eXBlOiAndGFyZ2V0JyB9KTtcbiAgICBjb25zdCBvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biA9IChldmVudCkgPT4gaGFuZGxlRWRnZVVwZGF0ZXIoZXZlbnQsIHsgbm9kZUlkOiBlZGdlLnNvdXJjZSwgaWQ6IGVkZ2Uuc291cmNlSGFuZGxlID8/IG51bGwsIHR5cGU6ICdzb3VyY2UnIH0pO1xuICAgIGNvbnN0IG9uUmVjb25uZWN0TW91c2VFbnRlciA9ICgpID0+IHNldFVwZGF0ZUhvdmVyKHRydWUpO1xuICAgIGNvbnN0IG9uUmVjb25uZWN0TW91c2VPdXQgPSAoKSA9PiBzZXRVcGRhdGVIb3ZlcihmYWxzZSk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbKGlzUmVjb25uZWN0YWJsZSA9PT0gdHJ1ZSB8fCBpc1JlY29ubmVjdGFibGUgPT09ICdzb3VyY2UnKSAmJiAoanN4KEVkZ2VBbmNob3IsIHsgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBjZW50ZXJYOiBzb3VyY2VYLCBjZW50ZXJZOiBzb3VyY2VZLCByYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25Nb3VzZURvd246IG9uUmVjb25uZWN0U291cmNlTW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uUmVjb25uZWN0TW91c2VFbnRlciwgb25Nb3VzZU91dDogb25SZWNvbm5lY3RNb3VzZU91dCwgdHlwZTogXCJzb3VyY2VcIiB9KSksIChpc1JlY29ubmVjdGFibGUgPT09IHRydWUgfHwgaXNSZWNvbm5lY3RhYmxlID09PSAndGFyZ2V0JykgJiYgKGpzeChFZGdlQW5jaG9yLCB7IHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgY2VudGVyWDogdGFyZ2V0WCwgY2VudGVyWTogdGFyZ2V0WSwgcmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uTW91c2VEb3duOiBvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biwgb25Nb3VzZUVudGVyOiBvblJlY29ubmVjdE1vdXNlRW50ZXIsIG9uTW91c2VPdXQ6IG9uUmVjb25uZWN0TW91c2VPdXQsIHR5cGU6IFwidGFyZ2V0XCIgfSkpXSB9KSk7XG59XG5cbmZ1bmN0aW9uIEVkZ2VXcmFwcGVyKHsgaWQsIGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgb25DbGljaywgb25Eb3VibGVDbGljaywgb25Db250ZXh0TWVudSwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXMsIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgcmZJZCwgZWRnZVR5cGVzLCBub1BhbkNsYXNzTmFtZSwgb25FcnJvciwgZGlzYWJsZUtleWJvYXJkQTExeSwgfSkge1xuICAgIGxldCBlZGdlID0gdXNlU3RvcmUoKHMpID0+IHMuZWRnZUxvb2t1cC5nZXQoaWQpKTtcbiAgICBjb25zdCBkZWZhdWx0RWRnZU9wdGlvbnMgPSB1c2VTdG9yZSgocykgPT4gcy5kZWZhdWx0RWRnZU9wdGlvbnMpO1xuICAgIGVkZ2UgPSBkZWZhdWx0RWRnZU9wdGlvbnMgPyB7IC4uLmRlZmF1bHRFZGdlT3B0aW9ucywgLi4uZWRnZSB9IDogZWRnZTtcbiAgICBsZXQgZWRnZVR5cGUgPSBlZGdlLnR5cGUgfHwgJ2RlZmF1bHQnO1xuICAgIGxldCBFZGdlQ29tcG9uZW50ID0gZWRnZVR5cGVzPy5bZWRnZVR5cGVdIHx8IGJ1aWx0aW5FZGdlVHlwZXNbZWRnZVR5cGVdO1xuICAgIGlmIChFZGdlQ29tcG9uZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTEnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMSddKGVkZ2VUeXBlKSk7XG4gICAgICAgIGVkZ2VUeXBlID0gJ2RlZmF1bHQnO1xuICAgICAgICBFZGdlQ29tcG9uZW50ID0gYnVpbHRpbkVkZ2VUeXBlcy5kZWZhdWx0O1xuICAgIH1cbiAgICBjb25zdCBpc0ZvY3VzYWJsZSA9ICEhKGVkZ2UuZm9jdXNhYmxlIHx8IChlZGdlc0ZvY3VzYWJsZSAmJiB0eXBlb2YgZWRnZS5mb2N1c2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNSZWNvbm5lY3RhYmxlID0gdHlwZW9mIG9uUmVjb25uZWN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAoZWRnZS5yZWNvbm5lY3RhYmxlIHx8IChlZGdlc1JlY29ubmVjdGFibGUgJiYgdHlwZW9mIGVkZ2UucmVjb25uZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSAhIShlZGdlLnNlbGVjdGFibGUgfHwgKGVsZW1lbnRzU2VsZWN0YWJsZSAmJiB0eXBlb2YgZWRnZS5zZWxlY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGVkZ2VSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgW3VwZGF0ZUhvdmVyLCBzZXRVcGRhdGVIb3Zlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3JlY29ubmVjdGluZywgc2V0UmVjb25uZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB6SW5kZXgsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9ID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHN0b3JlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzdG9yZS5ub2RlTG9va3VwLmdldChlZGdlLnRhcmdldCk7XG4gICAgICAgIGlmICghc291cmNlTm9kZSB8fCAhdGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6IGVkZ2UuekluZGV4LFxuICAgICAgICAgICAgICAgIC4uLm51bGxQb3NpdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWRnZVBvc2l0aW9uID0gZ2V0RWRnZVBvc2l0aW9uKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IGVkZ2Uuc291cmNlSGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IGVkZ2UudGFyZ2V0SGFuZGxlIHx8IG51bGwsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZTogc3RvcmUuY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgekluZGV4ID0gZ2V0RWxldmF0ZWRFZGdlWkluZGV4KHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgekluZGV4OiBlZGdlLnpJbmRleCxcbiAgICAgICAgICAgIHNvdXJjZU5vZGUsXG4gICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgZWxldmF0ZU9uU2VsZWN0OiBzdG9yZS5lbGV2YXRlRWRnZXNPblNlbGVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB6SW5kZXgsXG4gICAgICAgICAgICAuLi4oZWRnZVBvc2l0aW9uIHx8IG51bGxQb3NpdGlvbiksXG4gICAgICAgIH07XG4gICAgfSwgW2VkZ2Uuc291cmNlLCBlZGdlLnRhcmdldCwgZWRnZS5zb3VyY2VIYW5kbGUsIGVkZ2UudGFyZ2V0SGFuZGxlLCBlZGdlLnNlbGVjdGVkLCBlZGdlLnpJbmRleF0pLCBzaGFsbG93KTtcbiAgICBjb25zdCBtYXJrZXJTdGFydFVybCA9IHVzZU1lbW8oKCkgPT4gKGVkZ2UubWFya2VyU3RhcnQgPyBgdXJsKCcjJHtnZXRNYXJrZXJJZChlZGdlLm1hcmtlclN0YXJ0LCByZklkKX0nKWAgOiB1bmRlZmluZWQpLCBbZWRnZS5tYXJrZXJTdGFydCwgcmZJZF0pO1xuICAgIGNvbnN0IG1hcmtlckVuZFVybCA9IHVzZU1lbW8oKCkgPT4gKGVkZ2UubWFya2VyRW5kID8gYHVybCgnIyR7Z2V0TWFya2VySWQoZWRnZS5tYXJrZXJFbmQsIHJmSWQpfScpYCA6IHVuZGVmaW5lZCksIFtlZGdlLm1hcmtlckVuZCwgcmZJZF0pO1xuICAgIGlmIChlZGdlLmhpZGRlbiB8fCBzb3VyY2VYID09PSBudWxsIHx8IHNvdXJjZVkgPT09IG51bGwgfHwgdGFyZ2V0WCA9PT0gbnVsbCB8fCB0YXJnZXRZID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvbkVkZ2VDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IGFkZFNlbGVjdGVkRWRnZXMsIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgbXVsdGlTZWxlY3Rpb25BY3RpdmUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChpc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGVkZ2Uuc2VsZWN0ZWQgJiYgbXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBub2RlczogW10sIGVkZ2VzOiBbZWRnZV0gfSk7XG4gICAgICAgICAgICAgICAgZWRnZVJlZi5jdXJyZW50Py5ibHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWxlY3RlZEVkZ2VzKFtpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCBlZGdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25FZGdlRG91YmxlQ2xpY2sgPSBvbkRvdWJsZUNsaWNrXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbkRvdWJsZUNsaWNrKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlQ29udGV4dE1lbnUgPSBvbkNvbnRleHRNZW51XG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbkNvbnRleHRNZW51KGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VFbnRlciA9IG9uTW91c2VFbnRlclxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZUVudGVyKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VNb3ZlID0gb25Nb3VzZU1vdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25FZGdlTW91c2VMZWF2ZSA9IG9uTW91c2VMZWF2ZVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZUxlYXZlKGV2ZW50LCB7IC4uLmVkZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZUtleWJvYXJkQTExeSAmJiBlbGVtZW50U2VsZWN0aW9uS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpICYmIGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgY29uc3QgeyB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIGFkZFNlbGVjdGVkRWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCB1bnNlbGVjdCA9IGV2ZW50LmtleSA9PT0gJ0VzY2FwZSc7XG4gICAgICAgICAgICBpZiAodW5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBlZGdlUmVmLmN1cnJlbnQ/LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBlZGdlczogW2VkZ2VdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VsZWN0ZWRFZGdlcyhbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBzdHlsZTogeyB6SW5kZXggfSwgY2hpbGRyZW46IGpzeHMoXCJnXCIsIHsgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX2VkZ2UnLFxuICAgICAgICAgICAgICAgIGByZWFjdC1mbG93X19lZGdlLSR7ZWRnZVR5cGV9YCxcbiAgICAgICAgICAgICAgICBlZGdlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlZDogZWRnZS5hbmltYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmU6ICFpc1NlbGVjdGFibGUgJiYgIW9uQ2xpY2ssXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0aW5nOiB1cGRhdGVIb3ZlcixcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKSwgb25DbGljazogb25FZGdlQ2xpY2ssIG9uRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25Nb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIG9uS2V5RG93bjogaXNGb2N1c2FibGUgPyBvbktleURvd24gOiB1bmRlZmluZWQsIHRhYkluZGV4OiBpc0ZvY3VzYWJsZSA/IDAgOiB1bmRlZmluZWQsIHJvbGU6IGlzRm9jdXNhYmxlID8gJ2J1dHRvbicgOiAnaW1nJywgXCJkYXRhLWlkXCI6IGlkLCBcImRhdGEtdGVzdGlkXCI6IGByZl9fZWRnZS0ke2lkfWAsIFwiYXJpYS1sYWJlbFwiOiBlZGdlLmFyaWFMYWJlbCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGVkZ2UuYXJpYUxhYmVsIHx8IGBFZGdlIGZyb20gJHtlZGdlLnNvdXJjZX0gdG8gJHtlZGdlLnRhcmdldH1gLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogaXNGb2N1c2FibGUgPyBgJHtBUklBX0VER0VfREVTQ19LRVl9LSR7cmZJZH1gIDogdW5kZWZpbmVkLCByZWY6IGVkZ2VSZWYsIGNoaWxkcmVuOiBbIXJlY29ubmVjdGluZyAmJiAoanN4KEVkZ2VDb21wb25lbnQsIHsgaWQ6IGlkLCBzb3VyY2U6IGVkZ2Uuc291cmNlLCB0YXJnZXQ6IGVkZ2UudGFyZ2V0LCB0eXBlOiBlZGdlLnR5cGUsIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLCBhbmltYXRlZDogZWRnZS5hbmltYXRlZCwgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLCBkZWxldGFibGU6IGVkZ2UuZGVsZXRhYmxlID8/IHRydWUsIGxhYmVsOiBlZGdlLmxhYmVsLCBsYWJlbFN0eWxlOiBlZGdlLmxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBlZGdlLmxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGVkZ2UubGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogZWRnZS5sYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogZWRnZS5sYWJlbEJnQm9yZGVyUmFkaXVzLCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgZGF0YTogZWRnZS5kYXRhLCBzdHlsZTogZWRnZS5zdHlsZSwgc291cmNlSGFuZGxlSWQ6IGVkZ2Uuc291cmNlSGFuZGxlLCB0YXJnZXRIYW5kbGVJZDogZWRnZS50YXJnZXRIYW5kbGUsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydFVybCwgbWFya2VyRW5kOiBtYXJrZXJFbmRVcmwsIHBhdGhPcHRpb25zOiAncGF0aE9wdGlvbnMnIGluIGVkZ2UgPyBlZGdlLnBhdGhPcHRpb25zIDogdW5kZWZpbmVkLCBpbnRlcmFjdGlvbldpZHRoOiBlZGdlLmludGVyYWN0aW9uV2lkdGggfSkpLCBpc1JlY29ubmVjdGFibGUgJiYgKGpzeChFZGdlVXBkYXRlQW5jaG9ycywgeyBlZGdlOiBlZGdlLCBpc1JlY29ubmVjdGFibGU6IGlzUmVjb25uZWN0YWJsZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uUmVjb25uZWN0OiBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgc2V0VXBkYXRlSG92ZXI6IHNldFVwZGF0ZUhvdmVyLCBzZXRSZWNvbm5lY3Rpbmc6IHNldFJlY29ubmVjdGluZyB9KSldIH0pIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkYSA9IChzKSA9PiAoe1xuICAgIGVkZ2VzRm9jdXNhYmxlOiBzLmVkZ2VzRm9jdXNhYmxlLFxuICAgIGVkZ2VzUmVjb25uZWN0YWJsZTogcy5lZGdlc1JlY29ubmVjdGFibGUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBjb25uZWN0aW9uTW9kZTogcy5jb25uZWN0aW9uTW9kZSxcbiAgICBvbkVycm9yOiBzLm9uRXJyb3IsXG59KTtcbmZ1bmN0aW9uIEVkZ2VSZW5kZXJlckNvbXBvbmVudCh7IGRlZmF1bHRNYXJrZXJDb2xvciwgb25seVJlbmRlclZpc2libGVFbGVtZW50cywgcmZJZCwgZWRnZVR5cGVzLCBub1BhbkNsYXNzTmFtZSwgb25SZWNvbm5lY3QsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIG9uRWRnZUNsaWNrLCByZWNvbm5lY3RSYWRpdXMsIG9uRWRnZURvdWJsZUNsaWNrLCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgZGlzYWJsZUtleWJvYXJkQTExeSwgfSkge1xuICAgIGNvbnN0IHsgZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBvbkVycm9yIH0gPSB1c2VTdG9yZShzZWxlY3RvciRhLCBzaGFsbG93KTtcbiAgICBjb25zdCBlZGdlSWRzID0gdXNlVmlzaWJsZUVkZ2VJZHMob25seVJlbmRlclZpc2libGVFbGVtZW50cyk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2VzXCIsIGNoaWxkcmVuOiBbanN4KE1hcmtlckRlZmluaXRpb25zJDEsIHsgZGVmYXVsdENvbG9yOiBkZWZhdWx0TWFya2VyQ29sb3IsIHJmSWQ6IHJmSWQgfSksIGVkZ2VJZHMubWFwKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoanN4KEVkZ2VXcmFwcGVyLCB7IGlkOiBpZCwgZWRnZXNGb2N1c2FibGU6IGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGU6IGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvbkNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25Nb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIG9uQ2xpY2s6IG9uRWRnZUNsaWNrLCByZWNvbm5lY3RSYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25Eb3VibGVDbGljazogb25FZGdlRG91YmxlQ2xpY2ssIG9uUmVjb25uZWN0U3RhcnQ6IG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kOiBvblJlY29ubmVjdEVuZCwgcmZJZDogcmZJZCwgb25FcnJvcjogb25FcnJvciwgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXkgfSwgaWQpKTtcbiAgICAgICAgICAgIH0pXSB9KSk7XG59XG5FZGdlUmVuZGVyZXJDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnRWRnZVJlbmRlcmVyJztcbmNvbnN0IEVkZ2VSZW5kZXJlciA9IG1lbW8oRWRnZVJlbmRlcmVyQ29tcG9uZW50KTtcblxuY29uc3Qgc2VsZWN0b3IkOSA9IChzKSA9PiBgdHJhbnNsYXRlKCR7cy50cmFuc2Zvcm1bMF19cHgsJHtzLnRyYW5zZm9ybVsxXX1weCkgc2NhbGUoJHtzLnRyYW5zZm9ybVsyXX0pYDtcbmZ1bmN0aW9uIFZpZXdwb3J0KHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHVzZVN0b3JlKHNlbGVjdG9yJDkpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3ZpZXdwb3J0IHh5Zmxvd19fdmlld3BvcnQgcmVhY3QtZmxvd19fY29udGFpbmVyXCIsIHN0eWxlOiB7IHRyYW5zZm9ybSB9LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGNhbGxpbmcgb25Jbml0IGhhbmRsZXIuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU9uSW5pdEhhbmRsZXIob25Jbml0KSB7XG4gICAgY29uc3QgcmZJbnN0YW5jZSA9IHVzZVJlYWN0RmxvdygpO1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaXNJbml0aWFsaXplZC5jdXJyZW50ICYmIHJmSW5zdGFuY2Uudmlld3BvcnRJbml0aWFsaXplZCAmJiBvbkluaXQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gb25Jbml0KHJmSW5zdGFuY2UpLCAxKTtcbiAgICAgICAgICAgIGlzSW5pdGlhbGl6ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LCBbb25Jbml0LCByZkluc3RhbmNlLnZpZXdwb3J0SW5pdGlhbGl6ZWRdKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkOCA9IChzdGF0ZSkgPT4gc3RhdGUucGFuWm9vbT8uc3luY1ZpZXdwb3J0O1xuLyoqXG4gKiBIb29rIGZvciBzeW5jaW5nIHRoZSB2aWV3cG9ydCB3aXRoIHRoZSBwYW56b29tIGluc3RhbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHZpZXdwb3J0XG4gKi9cbmZ1bmN0aW9uIHVzZVZpZXdwb3J0U3luYyh2aWV3cG9ydCkge1xuICAgIGNvbnN0IHN5bmNWaWV3cG9ydCA9IHVzZVN0b3JlKHNlbGVjdG9yJDgpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgICAgICAgIHN5bmNWaWV3cG9ydD8uKHZpZXdwb3J0KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgdHJhbnNmb3JtOiBbdmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQuem9vbV0gfSk7XG4gICAgICAgIH1cbiAgICB9LCBbdmlld3BvcnQsIHN5bmNWaWV3cG9ydF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBzdG9yZVNlbGVjdG9yJDEocykge1xuICAgIHJldHVybiBzLmNvbm5lY3Rpb24uaW5Qcm9ncmVzc1xuICAgICAgICA/IHsgLi4ucy5jb25uZWN0aW9uLCB0bzogcG9pbnRUb1JlbmRlcmVyUG9pbnQocy5jb25uZWN0aW9uLnRvLCBzLnRyYW5zZm9ybSkgfVxuICAgICAgICA6IHsgLi4ucy5jb25uZWN0aW9uIH07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rvcihjb25uZWN0aW9uU2VsZWN0b3IpIHtcbiAgICBpZiAoY29ubmVjdGlvblNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkU2VsZWN0b3IgPSAocykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHN0b3JlU2VsZWN0b3IkMShzKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uU2VsZWN0b3IoY29ubmVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb21iaW5lZFNlbGVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmVTZWxlY3RvciQxO1xufVxuLyoqXG4gKiBIb29rIGZvciBhY2Nlc3NpbmcgdGhlIGNvbm5lY3Rpb24gc3RhdGUuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQ29ubmVjdGlvblN0YXRlXG4gKi9cbmZ1bmN0aW9uIHVzZUNvbm5lY3Rpb24oY29ubmVjdGlvblNlbGVjdG9yKSB7XG4gICAgY29uc3QgY29tYmluZWRTZWxlY3RvciA9IGdldFNlbGVjdG9yKGNvbm5lY3Rpb25TZWxlY3Rvcik7XG4gICAgcmV0dXJuIHVzZVN0b3JlKGNvbWJpbmVkU2VsZWN0b3IsIHNoYWxsb3cpO1xufVxuXG5jb25zdCBzZWxlY3RvciQ3ID0gKHMpID0+ICh7XG4gICAgbm9kZXNDb25uZWN0YWJsZTogcy5ub2Rlc0Nvbm5lY3RhYmxlLFxuICAgIGlzVmFsaWQ6IHMuY29ubmVjdGlvbi5pc1ZhbGlkLFxuICAgIGluUHJvZ3Jlc3M6IHMuY29ubmVjdGlvbi5pblByb2dyZXNzLFxuICAgIHdpZHRoOiBzLndpZHRoLFxuICAgIGhlaWdodDogcy5oZWlnaHQsXG59KTtcbmZ1bmN0aW9uIENvbm5lY3Rpb25MaW5lV3JhcHBlcih7IGNvbnRhaW5lclN0eWxlLCBzdHlsZSwgdHlwZSwgY29tcG9uZW50IH0pIHtcbiAgICBjb25zdCB7IG5vZGVzQ29ubmVjdGFibGUsIHdpZHRoLCBoZWlnaHQsIGlzVmFsaWQsIGluUHJvZ3Jlc3MgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDcsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHJlbmRlckNvbm5lY3Rpb24gPSAhISh3aWR0aCAmJiBub2Rlc0Nvbm5lY3RhYmxlICYmIGluUHJvZ3Jlc3MpO1xuICAgIGlmICghcmVuZGVyQ29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBzdHlsZTogY29udGFpbmVyU3R5bGUsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb25uZWN0aW9ubGluZSByZWFjdC1mbG93X19jb250YWluZXJcIiwgY2hpbGRyZW46IGpzeChcImdcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fY29ubmVjdGlvbicsIGdldENvbm5lY3Rpb25TdGF0dXMoaXNWYWxpZCldKSwgY2hpbGRyZW46IGpzeChDb25uZWN0aW9uTGluZSwgeyBzdHlsZTogc3R5bGUsIHR5cGU6IHR5cGUsIEN1c3RvbUNvbXBvbmVudDogY29tcG9uZW50LCBpc1ZhbGlkOiBpc1ZhbGlkIH0pIH0pIH0pKTtcbn1cbmNvbnN0IENvbm5lY3Rpb25MaW5lID0gKHsgc3R5bGUsIHR5cGUgPSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyLCBDdXN0b21Db21wb25lbnQsIGlzVmFsaWQgfSkgPT4ge1xuICAgIGNvbnN0IHsgaW5Qcm9ncmVzcywgZnJvbSwgZnJvbU5vZGUsIGZyb21IYW5kbGUsIGZyb21Qb3NpdGlvbiwgdG8sIHRvTm9kZSwgdG9IYW5kbGUsIHRvUG9zaXRpb24gfSA9IHVzZUNvbm5lY3Rpb24oKTtcbiAgICBpZiAoIWluUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQ3VzdG9tQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAoanN4KEN1c3RvbUNvbXBvbmVudCwgeyBjb25uZWN0aW9uTGluZVR5cGU6IHR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGU6IHN0eWxlLCBmcm9tTm9kZTogZnJvbU5vZGUsIGZyb21IYW5kbGU6IGZyb21IYW5kbGUsIGZyb21YOiBmcm9tLngsIGZyb21ZOiBmcm9tLnksIHRvWDogdG8ueCwgdG9ZOiB0by55LCBmcm9tUG9zaXRpb246IGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbjogdG9Qb3NpdGlvbiwgY29ubmVjdGlvblN0YXR1czogZ2V0Q29ubmVjdGlvblN0YXR1cyhpc1ZhbGlkKSwgdG9Ob2RlOiB0b05vZGUsIHRvSGFuZGxlOiB0b0hhbmRsZSB9KSk7XG4gICAgfVxuICAgIGxldCBwYXRoID0gJyc7XG4gICAgY29uc3QgcGF0aFBhcmFtcyA9IHtcbiAgICAgICAgc291cmNlWDogZnJvbS54LFxuICAgICAgICBzb3VyY2VZOiBmcm9tLnksXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uOiBmcm9tUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFg6IHRvLngsXG4gICAgICAgIHRhcmdldFk6IHRvLnksXG4gICAgICAgIHRhcmdldFBvc2l0aW9uOiB0b1Bvc2l0aW9uLFxuICAgIH07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLkJlemllcjpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldEJlemllclBhdGgocGF0aFBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuU2ltcGxlQmV6aWVyOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U2ltcGxlQmV6aWVyUGF0aChwYXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5TdGVwOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U21vb3RoU3RlcFBhdGgoe1xuICAgICAgICAgICAgICAgIC4uLnBhdGhQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuU21vb3RoU3RlcDpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFNtb290aFN0ZXBQYXRoKHBhdGhQYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTdHJhaWdodFBhdGgocGF0aFBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBqc3goXCJwYXRoXCIsIHsgZDogcGF0aCwgZmlsbDogXCJub25lXCIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb25uZWN0aW9uLXBhdGhcIiwgc3R5bGU6IHN0eWxlIH0pO1xufTtcbkNvbm5lY3Rpb25MaW5lLmRpc3BsYXlOYW1lID0gJ0Nvbm5lY3Rpb25MaW5lJztcblxuY29uc3QgZW1wdHlUeXBlcyA9IHt9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmcobm9kZU9yRWRnZVR5cGVzID0gZW1wdHlUeXBlcykge1xuICAgIGNvbnN0IHR5cGVzUmVmID0gdXNlUmVmKG5vZGVPckVkZ2VUeXBlcyk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc3QgdXNlZEtleXMgPSBuZXcgU2V0KFsuLi5PYmplY3Qua2V5cyh0eXBlc1JlZi5jdXJyZW50KSwgLi4uT2JqZWN0LmtleXMobm9kZU9yRWRnZVR5cGVzKV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXNlZEtleXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZXNSZWYuY3VycmVudFtrZXldICE9PSBub2RlT3JFZGdlVHlwZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDAyJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDInXSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZXNSZWYuY3VycmVudCA9IG5vZGVPckVkZ2VUeXBlcztcbiAgICAgICAgfVxuICAgIH0sIFtub2RlT3JFZGdlVHlwZXNdKTtcbn1cblxuZnVuY3Rpb24gdXNlU3R5bGVzTG9hZGVkV2FybmluZygpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgY2hlY2tlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fcGFuZScpO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lICYmICEod2luZG93LmdldENvbXB1dGVkU3R5bGUocGFuZSkuekluZGV4ID09PSAnMScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMTMnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMyddKCdyZWFjdCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hlY2tlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gR3JhcGhWaWV3Q29tcG9uZW50KHsgbm9kZVR5cGVzLCBlZGdlVHlwZXMsIG9uSW5pdCwgb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrLCBvbk5vZGVEb3VibGVDbGljaywgb25FZGdlRG91YmxlQ2xpY2ssIG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBjb25uZWN0aW9uTGluZVR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlLCBzZWxlY3Rpb25LZXlDb2RlLCBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgZGVsZXRlS2V5Q29kZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50cywgZWxlbWVudHNTZWxlY3RhYmxlLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZywgZGVmYXVsdE1hcmtlckNvbG9yLCB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoLCBwYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51LCBwYW5lQ2xpY2tEaXN0YW5jZSwgbm9kZUNsaWNrRGlzdGFuY2UsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1cywgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50LCByZklkLCB2aWV3cG9ydCwgb25WaWV3cG9ydENoYW5nZSwgfSkge1xuICAgIHVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmcobm9kZVR5cGVzKTtcbiAgICB1c2VOb2RlT3JFZGdlVHlwZXNXYXJuaW5nKGVkZ2VUeXBlcyk7XG4gICAgdXNlU3R5bGVzTG9hZGVkV2FybmluZygpO1xuICAgIHVzZU9uSW5pdEhhbmRsZXIob25Jbml0KTtcbiAgICB1c2VWaWV3cG9ydFN5bmModmlld3BvcnQpO1xuICAgIHJldHVybiAoanN4KEZsb3dSZW5kZXJlciwgeyBvblBhbmVDbGljazogb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXI6IG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZTogb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlOiBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbDogb25QYW5lU2Nyb2xsLCBwYW5lQ2xpY2tEaXN0YW5jZTogcGFuZUNsaWNrRGlzdGFuY2UsIGRlbGV0ZUtleUNvZGU6IGRlbGV0ZUtleUNvZGUsIHNlbGVjdGlvbktleUNvZGU6IHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZzogc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBvblNlbGVjdGlvblN0YXJ0OiBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZDogb25TZWxlY3Rpb25FbmQsIG11bHRpU2VsZWN0aW9uS2V5Q29kZTogbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZTogcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBvblNlbGVjdGlvbkNvbnRleHRNZW51OiBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBwcmV2ZW50U2Nyb2xsaW5nOiBwcmV2ZW50U2Nyb2xsaW5nLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBvblZpZXdwb3J0Q2hhbmdlOiBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydDogISF2aWV3cG9ydCwgY2hpbGRyZW46IGpzeHMoVmlld3BvcnQsIHsgY2hpbGRyZW46IFtqc3goRWRnZVJlbmRlcmVyLCB7IGVkZ2VUeXBlczogZWRnZVR5cGVzLCBvbkVkZ2VDbGljazogb25FZGdlQ2xpY2ssIG9uRWRnZURvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHM6IG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBkZWZhdWx0TWFya2VyQ29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCByZklkOiByZklkIH0pLCBqc3goQ29ubmVjdGlvbkxpbmVXcmFwcGVyLCB7IHN0eWxlOiBjb25uZWN0aW9uTGluZVN0eWxlLCB0eXBlOiBjb25uZWN0aW9uTGluZVR5cGUsIGNvbXBvbmVudDogY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbnRhaW5lclN0eWxlOiBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZWxhYmVsLXJlbmRlcmVyXCIgfSksIGpzeChOb2RlUmVuZGVyZXIsIHsgbm9kZVR5cGVzOiBub2RlVHlwZXMsIG9uTm9kZUNsaWNrOiBvbk5vZGVDbGljaywgb25Ob2RlRG91YmxlQ2xpY2s6IG9uTm9kZURvdWJsZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyOiBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmU6IG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZTogb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnU6IG9uTm9kZUNvbnRleHRNZW51LCBub2RlQ2xpY2tEaXN0YW5jZTogbm9kZUNsaWNrRGlzdGFuY2UsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHM6IG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXksIG5vZGVFeHRlbnQ6IG5vZGVFeHRlbnQsIHJmSWQ6IHJmSWQgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X192aWV3cG9ydC1wb3J0YWxcIiB9KV0gfSkgfSkpO1xufVxuR3JhcGhWaWV3Q29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0dyYXBoVmlldyc7XG5jb25zdCBHcmFwaFZpZXcgPSBtZW1vKEdyYXBoVmlld0NvbXBvbmVudCk7XG5cbmNvbnN0IGdldEluaXRpYWxTdGF0ZSA9ICh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIHdpZHRoLCBoZWlnaHQsIGZpdFZpZXcsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIH0gPSB7fSkgPT4ge1xuICAgIGNvbnN0IG5vZGVMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcGFyZW50TG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Mb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZWRnZUxvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBzdG9yZUVkZ2VzID0gZGVmYXVsdEVkZ2VzID8/IGVkZ2VzID8/IFtdO1xuICAgIGNvbnN0IHN0b3JlTm9kZXMgPSBkZWZhdWx0Tm9kZXMgPz8gbm9kZXMgPz8gW107XG4gICAgY29uc3Qgc3RvcmVOb2RlT3JpZ2luID0gbm9kZU9yaWdpbiA/PyBbMCwgMF07XG4gICAgY29uc3Qgc3RvcmVOb2RlRXh0ZW50ID0gbm9kZUV4dGVudCA/PyBpbmZpbml0ZUV4dGVudDtcbiAgICB1cGRhdGVDb25uZWN0aW9uTG9va3VwKGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAsIHN0b3JlRWRnZXMpO1xuICAgIGFkb3B0VXNlck5vZGVzKHN0b3JlTm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwge1xuICAgICAgICBub2RlT3JpZ2luOiBzdG9yZU5vZGVPcmlnaW4sXG4gICAgICAgIG5vZGVFeHRlbnQ6IHN0b3JlTm9kZUV4dGVudCxcbiAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IGZhbHNlLFxuICAgIH0pO1xuICAgIGxldCB0cmFuc2Zvcm0gPSBbMCwgMCwgMV07XG4gICAgaWYgKGZpdFZpZXcgJiYgd2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGdldEludGVybmFsTm9kZXNCb3VuZHMobm9kZUxvb2t1cCwge1xuICAgICAgICAgICAgZmlsdGVyOiAobm9kZSkgPT4gISEoKG5vZGUud2lkdGggfHwgbm9kZS5pbml0aWFsV2lkdGgpICYmIChub2RlLmhlaWdodCB8fCBub2RlLmluaXRpYWxIZWlnaHQpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCAwLjUsIDIsIDAuMSk7XG4gICAgICAgIHRyYW5zZm9ybSA9IFt4LCB5LCB6b29tXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmZJZDogJzEnLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIG5vZGVzOiBzdG9yZU5vZGVzLFxuICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICBwYXJlbnRMb29rdXAsXG4gICAgICAgIGVkZ2VzOiBzdG9yZUVkZ2VzLFxuICAgICAgICBlZGdlTG9va3VwLFxuICAgICAgICBjb25uZWN0aW9uTG9va3VwLFxuICAgICAgICBvbk5vZGVzQ2hhbmdlOiBudWxsLFxuICAgICAgICBvbkVkZ2VzQ2hhbmdlOiBudWxsLFxuICAgICAgICBoYXNEZWZhdWx0Tm9kZXM6IGRlZmF1bHROb2RlcyAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBoYXNEZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcyAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBwYW5ab29tOiBudWxsLFxuICAgICAgICBtaW5ab29tOiAwLjUsXG4gICAgICAgIG1heFpvb206IDIsXG4gICAgICAgIHRyYW5zbGF0ZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgICAgIG5vZGVFeHRlbnQ6IHN0b3JlTm9kZUV4dGVudCxcbiAgICAgICAgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG51bGwsXG4gICAgICAgIGNvbm5lY3Rpb25Nb2RlOiBDb25uZWN0aW9uTW9kZS5TdHJpY3QsXG4gICAgICAgIGRvbU5vZGU6IG51bGwsXG4gICAgICAgIHBhbmVEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIG5vUGFuQ2xhc3NOYW1lOiAnbm9wYW4nLFxuICAgICAgICBub2RlT3JpZ2luOiBzdG9yZU5vZGVPcmlnaW4sXG4gICAgICAgIG5vZGVEcmFnVGhyZXNob2xkOiAxLFxuICAgICAgICBzbmFwR3JpZDogWzE1LCAxNV0sXG4gICAgICAgIHNuYXBUb0dyaWQ6IGZhbHNlLFxuICAgICAgICBub2Rlc0RyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgbm9kZXNDb25uZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgbm9kZXNGb2N1c2FibGU6IHRydWUsXG4gICAgICAgIGVkZ2VzRm9jdXNhYmxlOiB0cnVlLFxuICAgICAgICBlZGdlc1JlY29ubmVjdGFibGU6IHRydWUsXG4gICAgICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IHRydWUsXG4gICAgICAgIGVsZXZhdGVFZGdlc09uU2VsZWN0OiBmYWxzZSxcbiAgICAgICAgZml0Vmlld09uSW5pdDogZmFsc2UsXG4gICAgICAgIGZpdFZpZXdEb25lOiBmYWxzZSxcbiAgICAgICAgZml0Vmlld09uSW5pdE9wdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VsZWN0Tm9kZXNPbkRyYWc6IHRydWUsXG4gICAgICAgIG11bHRpU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgY29ubmVjdGlvbjogeyAuLi5pbml0aWFsQ29ubmVjdGlvbiB9LFxuICAgICAgICBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogbnVsbCxcbiAgICAgICAgY29ubmVjdE9uQ2xpY2s6IHRydWUsXG4gICAgICAgIGFyaWFMaXZlTWVzc2FnZTogJycsXG4gICAgICAgIGF1dG9QYW5PbkNvbm5lY3Q6IHRydWUsXG4gICAgICAgIGF1dG9QYW5Pbk5vZGVEcmFnOiB0cnVlLFxuICAgICAgICBhdXRvUGFuU3BlZWQ6IDE1LFxuICAgICAgICBjb25uZWN0aW9uUmFkaXVzOiAyMCxcbiAgICAgICAgb25FcnJvcjogZGV2V2FybixcbiAgICAgICAgaXNWYWxpZENvbm5lY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVyczogW10sXG4gICAgICAgIGxpYjogJ3JlYWN0JyxcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgIH07XG59O1xuXG5jb25zdCBjcmVhdGVTdG9yZSA9ICh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIHdpZHRoLCBoZWlnaHQsIGZpdFZpZXc6IGZpdFZpZXckMSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgfSkgPT4gY3JlYXRlV2l0aEVxdWFsaXR5Rm4oKHNldCwgZ2V0KSA9PiAoe1xuICAgIC4uLmdldEluaXRpYWxTdGF0ZSh7IG5vZGVzLCBlZGdlcywgd2lkdGgsIGhlaWdodCwgZml0VmlldzogZml0VmlldyQxLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcyB9KSxcbiAgICBzZXROb2RlczogKG5vZGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luLCBlbGV2YXRlTm9kZXNPblNlbGVjdCB9ID0gZ2V0KCk7XG4gICAgICAgIC8vIHNldE5vZGVzKCkgaXMgY2FsbGVkIGV4Y2x1c2l2ZWx5IGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9uczpcbiAgICAgICAgLy8gLSBlaXRoZXIgd2hlbiB0aGUgYDxSZWFjdEZsb3cgbm9kZXM+YCBwcm9wIGlzIHVwZGF0ZWQgaW4gdGhlIGNvbnRyb2xsZWQgUmVhY3RGbG93IHNldHVwLFxuICAgICAgICAvLyAtIG9yIHdoZW4gdGhlIHVzZXIgY2FsbHMgc29tZXRoaW5nIGxpa2UgYHJlYWN0Rmxvd0luc3RhbmNlLnNldE5vZGVzKClgIGluIGFuIHVuY29udHJvbGxlZCBSZWFjdEZsb3cgc2V0dXAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdoZW4gdGhpcyBoYXBwZW5zLCB3ZSB0YWtlIHRoZSBub3RlIG9iamVjdHMgcGFzc2VkIGJ5IHRoZSB1c2VyIGFuZCBleHRlbmQgdGhlbSB3aXRoIGZpZWxkc1xuICAgICAgICAvLyByZWxldmFudCBmb3IgaW50ZXJuYWwgUmVhY3QgRmxvdyBvcGVyYXRpb25zLlxuICAgICAgICBhZG9wdFVzZXJOb2Rlcyhub2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7XG4gICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgbm9kZUV4dGVudCxcbiAgICAgICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0LFxuICAgICAgICAgICAgY2hlY2tFcXVhbGl0eTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHNldCh7IG5vZGVzIH0pO1xuICAgIH0sXG4gICAgc2V0RWRnZXM6IChlZGdlcykgPT4ge1xuICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAgfSA9IGdldCgpO1xuICAgICAgICB1cGRhdGVDb25uZWN0aW9uTG9va3VwKGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAsIGVkZ2VzKTtcbiAgICAgICAgc2V0KHsgZWRnZXMgfSk7XG4gICAgfSxcbiAgICBzZXREZWZhdWx0Tm9kZXNBbmRFZGdlczogKG5vZGVzLCBlZGdlcykgPT4ge1xuICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2V0Tm9kZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgc2V0Tm9kZXMobm9kZXMpO1xuICAgICAgICAgICAgc2V0KHsgaGFzRGVmYXVsdE5vZGVzOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZGdlcykge1xuICAgICAgICAgICAgY29uc3QgeyBzZXRFZGdlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBzZXRFZGdlcyhlZGdlcyk7XG4gICAgICAgICAgICBzZXQoeyBoYXNEZWZhdWx0RWRnZXM6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIEV2ZXJ5IG5vZGUgZ2V0cyByZWdpc3RlcmQgYXQgYSBSZXNpemVPYnNlcnZlci4gV2hlbmV2ZXIgYSBub2RlXG4gICAgLy8gY2hhbmdlcyBpdHMgZGltZW5zaW9ucywgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgdG8gbWVhc3VyZSB0aGVcbiAgICAvLyBuZXcgZGltZW5zaW9ucyBhbmQgdXBkYXRlIHRoZSBub2Rlcy5cbiAgICB1cGRhdGVOb2RlSW50ZXJuYWxzOiAodXBkYXRlcywgcGFyYW1zID0geyB0cmlnZ2VyRml0VmlldzogdHJ1ZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdHJpZ2dlck5vZGVDaGFuZ2VzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIGZpdFZpZXdPbkluaXQsIGZpdFZpZXdEb25lLCBmaXRWaWV3T25Jbml0T3B0aW9ucywgZG9tTm9kZSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgZGVidWcsIGZpdFZpZXdTeW5jLCB9ID0gZ2V0KCk7XG4gICAgICAgIGNvbnN0IHsgY2hhbmdlcywgdXBkYXRlZEludGVybmFscyB9ID0gdXBkYXRlTm9kZUludGVybmFscyh1cGRhdGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIGRvbU5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQpO1xuICAgICAgICBpZiAoIXVwZGF0ZWRJbnRlcm5hbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucyhub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHsgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCB9KTtcbiAgICAgICAgaWYgKHBhcmFtcy50cmlnZ2VyRml0Vmlldykge1xuICAgICAgICAgICAgLy8gd2UgY2FsbCBmaXRWaWV3IG9uY2UgaW5pdGlhbGx5IGFmdGVyIGFsbCBkaW1lbnNpb25zIGFyZSBzZXRcbiAgICAgICAgICAgIGxldCBuZXh0Rml0Vmlld0RvbmUgPSBmaXRWaWV3RG9uZTtcbiAgICAgICAgICAgIGlmICghZml0Vmlld0RvbmUgJiYgZml0Vmlld09uSW5pdCkge1xuICAgICAgICAgICAgICAgIG5leHRGaXRWaWV3RG9uZSA9IGZpdFZpZXdTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZml0Vmlld09uSW5pdE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzOiBmaXRWaWV3T25Jbml0T3B0aW9ucz8ubm9kZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoZXJlIHdlIGFyZSBjaXJtdW12ZW50aW5nIHRoZSBvbk5vZGVzQ2hhbmdlIGhhbmRsZXJcbiAgICAgICAgICAgIC8vIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gZGlzcGxheSBub2RlcyBldmVuIGlmIHRoZSB1c2VyXG4gICAgICAgICAgICAvLyBoYXMgbm90IHByb3ZpZGVkIGFuIG9uTm9kZXNDaGFuZ2UgaGFuZGxlci5cbiAgICAgICAgICAgIC8vIE5vZGVzIGFyZSBvbmx5IHJlbmRlcmVkIGlmIHRoZXkgaGF2ZSBhIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSB3aGljaCB0aGV5IGdldCBmcm9tIHRoaXMgaGFuZGxlci5cbiAgICAgICAgICAgIHNldCh7IGZpdFZpZXdEb25lOiBuZXh0Rml0Vmlld0RvbmUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBhbHdheXMgd2FudCB0byB0cmlnZ2VyIHVzZVN0b3JlIGNhbGxzIHdoZW5ldmVyIHVwZGF0ZU5vZGVJbnRlcm5hbHMgaXMgY2FsbGVkXG4gICAgICAgICAgICBzZXQoe30pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3QgRmxvdzogdHJpZ2dlciBub2RlIGNoYW5nZXMnLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcz8uKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGVOb2RlUG9zaXRpb25zOiAobm9kZURyYWdJdGVtcywgZHJhZ2dpbmcgPSBmYWxzZSkgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGlsZHJlbiA9IFtdO1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2lkLCBkcmFnSXRlbV0gb2Ygbm9kZURyYWdJdGVtcykge1xuICAgICAgICAgICAgY29uc3QgZXhwYW5kUGFyZW50ID0gISEoZHJhZ0l0ZW0/LmV4cGFuZFBhcmVudCAmJiBkcmFnSXRlbT8ucGFyZW50SWQgJiYgZHJhZ0l0ZW0/LnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHBhbmRQYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBNYXRoLm1heCgwLCBkcmFnSXRlbS5wb3NpdGlvbi54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IE1hdGgubWF4KDAsIGRyYWdJdGVtLnBvc2l0aW9uLnkpLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogZHJhZ0l0ZW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGV4cGFuZFBhcmVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudEV4cGFuZENoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IGRyYWdJdGVtLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kcmFnSXRlbS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkcmFnSXRlbS5tZWFzdXJlZC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZHJhZ0l0ZW0ubWVhc3VyZWQuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudEV4cGFuZENoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQocGFyZW50RXhwYW5kQ2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goLi4ucGFyZW50RXhwYW5kQ2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0KCkudHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgIH0sXG4gICAgdHJpZ2dlck5vZGVDaGFuZ2VzOiAoY2hhbmdlcykgPT4ge1xuICAgICAgICBjb25zdCB7IG9uTm9kZXNDaGFuZ2UsIHNldE5vZGVzLCBub2RlcywgaGFzRGVmYXVsdE5vZGVzLCBkZWJ1ZyB9ID0gZ2V0KCk7XG4gICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkTm9kZXMgPSBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICBzZXROb2Rlcyh1cGRhdGVkTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlYWN0IEZsb3c6IHRyaWdnZXIgbm9kZSBjaGFuZ2VzJywgY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRyaWdnZXJFZGdlQ2hhbmdlczogKGNoYW5nZXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBvbkVkZ2VzQ2hhbmdlLCBzZXRFZGdlcywgZWRnZXMsIGhhc0RlZmF1bHRFZGdlcywgZGVidWcgfSA9IGdldCgpO1xuICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEVkZ2VzID0gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBlZGdlcyk7XG4gICAgICAgICAgICAgICAgc2V0RWRnZXModXBkYXRlZEVkZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdCBGbG93OiB0cmlnZ2VyIGVkZ2UgY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25FZGdlc0NoYW5nZT8uKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhZGRTZWxlY3RlZE5vZGVzOiAoc2VsZWN0ZWROb2RlSWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VMb29rdXAsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgaWYgKG11bHRpU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IHNlbGVjdGVkTm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKG5vZGVJZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2RlTG9va3VwLCBuZXcgU2V0KFsuLi5zZWxlY3RlZE5vZGVJZHNdKSwgdHJ1ZSkpO1xuICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlTG9va3VwKSk7XG4gICAgfSxcbiAgICBhZGRTZWxlY3RlZEVkZ2VzOiAoc2VsZWN0ZWRFZGdlSWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VMb29rdXAsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgaWYgKG11bHRpU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkRWRnZXMgPSBzZWxlY3RlZEVkZ2VJZHMubWFwKChlZGdlSWQpID0+IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShlZGdlSWQsIHRydWUpKTtcbiAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhjaGFuZ2VkRWRnZXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKGVkZ2VMb29rdXAsIG5ldyBTZXQoWy4uLnNlbGVjdGVkRWRnZUlkc10pKSk7XG4gICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKG5vZGVMb29rdXAsIG5ldyBTZXQoKSwgdHJ1ZSkpO1xuICAgIH0sXG4gICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzOiAoeyBub2RlcywgZWRnZXMgfSA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXM6IHN0b3JlRWRnZXMsIG5vZGVzOiBzdG9yZU5vZGVzLCBub2RlTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcyB9ID0gZ2V0KCk7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9VbnNlbGVjdCA9IG5vZGVzID8gbm9kZXMgOiBzdG9yZU5vZGVzO1xuICAgICAgICBjb25zdCBlZGdlc1RvVW5zZWxlY3QgPSBlZGdlcyA/IGVkZ2VzIDogc3RvcmVFZGdlcztcbiAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBub2Rlc1RvVW5zZWxlY3QubWFwKChuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBub2RlTG9va3VwLmdldChuLmlkKTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHVuc2VsZWN0IHRoZSBpbnRlcm5hbCBub2RlIHRoYXQgd2FzIHNlbGVjdGVkIHByZXZpb3VzbHkgYmVmb3JlIHdlXG4gICAgICAgICAgICAgICAgLy8gc2VuZCB0aGUgY2hhbmdlIHRvIHRoZSB1c2VyIHRvIHByZXZlbnQgaXQgdG8gYmUgc2VsZWN0ZWQgd2hpbGUgZHJhZ2dpbmcgdGhlIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxOb2RlLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKG4uaWQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gZWRnZXNUb1Vuc2VsZWN0Lm1hcCgoZWRnZSkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKSk7XG4gICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhub2RlQ2hhbmdlcyk7XG4gICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhlZGdlQ2hhbmdlcyk7XG4gICAgfSxcbiAgICBzZXRNaW5ab29tOiAobWluWm9vbSkgPT4ge1xuICAgICAgICBjb25zdCB7IHBhblpvb20sIG1heFpvb20gfSA9IGdldCgpO1xuICAgICAgICBwYW5ab29tPy5zZXRTY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pO1xuICAgICAgICBzZXQoeyBtaW5ab29tIH0pO1xuICAgIH0sXG4gICAgc2V0TWF4Wm9vbTogKG1heFpvb20pID0+IHtcbiAgICAgICAgY29uc3QgeyBwYW5ab29tLCBtaW5ab29tIH0gPSBnZXQoKTtcbiAgICAgICAgcGFuWm9vbT8uc2V0U2NhbGVFeHRlbnQoW21pblpvb20sIG1heFpvb21dKTtcbiAgICAgICAgc2V0KHsgbWF4Wm9vbSB9KTtcbiAgICB9LFxuICAgIHNldFRyYW5zbGF0ZUV4dGVudDogKHRyYW5zbGF0ZUV4dGVudCkgPT4ge1xuICAgICAgICBnZXQoKS5wYW5ab29tPy5zZXRUcmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgc2V0KHsgdHJhbnNsYXRlRXh0ZW50IH0pO1xuICAgIH0sXG4gICAgc2V0UGFuZUNsaWNrRGlzdGFuY2U6IChjbGlja0Rpc3RhbmNlKSA9PiB7XG4gICAgICAgIGdldCgpLnBhblpvb20/LnNldENsaWNrRGlzdGFuY2UoY2xpY2tEaXN0YW5jZSk7XG4gICAgfSxcbiAgICByZXNldFNlbGVjdGVkRWxlbWVudHM6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBlZGdlcywgbm9kZXMsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBub2Rlcy5yZWR1Y2UoKHJlcywgbm9kZSkgPT4gKG5vZGUuc2VsZWN0ZWQgPyBbLi4ucmVzLCBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobm9kZS5pZCwgZmFsc2UpXSA6IHJlcyksIFtdKTtcbiAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBlZGdlcy5yZWR1Y2UoKHJlcywgZWRnZSkgPT4gKGVkZ2Uuc2VsZWN0ZWQgPyBbLi4ucmVzLCBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoZWRnZS5pZCwgZmFsc2UpXSA6IHJlcyksIFtdKTtcbiAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGVkZ2VDaGFuZ2VzKTtcbiAgICB9LFxuICAgIHNldE5vZGVFeHRlbnQ6IChuZXh0Tm9kZUV4dGVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4sIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBub2RlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgaWYgKG5leHROb2RlRXh0ZW50WzBdWzBdID09PSBub2RlRXh0ZW50WzBdWzBdICYmXG4gICAgICAgICAgICBuZXh0Tm9kZUV4dGVudFswXVsxXSA9PT0gbm9kZUV4dGVudFswXVsxXSAmJlxuICAgICAgICAgICAgbmV4dE5vZGVFeHRlbnRbMV1bMF0gPT09IG5vZGVFeHRlbnRbMV1bMF0gJiZcbiAgICAgICAgICAgIG5leHROb2RlRXh0ZW50WzFdWzFdID09PSBub2RlRXh0ZW50WzFdWzFdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWRvcHRVc2VyTm9kZXMobm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwge1xuICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgIG5vZGVFeHRlbnQ6IG5leHROb2RlRXh0ZW50LFxuICAgICAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3QsXG4gICAgICAgICAgICBjaGVja0VxdWFsaXR5OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHNldCh7IG5vZGVFeHRlbnQ6IG5leHROb2RlRXh0ZW50IH0pO1xuICAgIH0sXG4gICAgcGFuQnk6IChkZWx0YSkgPT4ge1xuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgd2lkdGgsIGhlaWdodCwgcGFuWm9vbSwgdHJhbnNsYXRlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgcmV0dXJuIHBhbkJ5KHsgZGVsdGEsIHBhblpvb20sIHRyYW5zZm9ybSwgdHJhbnNsYXRlRXh0ZW50LCB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgIH0sXG4gICAgZml0VmlldzogKG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgeyBwYW5ab29tLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBub2RlTG9va3VwIH0gPSBnZXQoKTtcbiAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXRWaWV3Tm9kZXMgPSBnZXRGaXRWaWV3Tm9kZXMobm9kZUxvb2t1cCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBmaXRWaWV3KHtcbiAgICAgICAgICAgIG5vZGVzOiBmaXRWaWV3Tm9kZXMsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHBhblpvb20sXG4gICAgICAgICAgICBtaW5ab29tLFxuICAgICAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICAvLyB3ZSBjYW4ndCBjYWxsIGFuIGFzbnljaHJvbm91cyBmdW5jdGlvbiBpbiB1cGRhdGVOb2RlSW50ZXJuYWxzXG4gICAgLy8gZm9yIHRoYXQgd2UgY3JlYXRlZCB0aGlzIHN5bmMgdmVyc2lvbiBvZiBmaXRWaWV3XG4gICAgZml0Vmlld1N5bmM6IChvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcGFuWm9vbSwgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgbm9kZUxvb2t1cCB9ID0gZ2V0KCk7XG4gICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpdFZpZXdOb2RlcyA9IGdldEZpdFZpZXdOb2Rlcyhub2RlTG9va3VwLCBvcHRpb25zKTtcbiAgICAgICAgZml0Vmlldyh7XG4gICAgICAgICAgICBub2RlczogZml0Vmlld05vZGVzLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBwYW5ab29tLFxuICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgIG1heFpvb20sXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gZml0Vmlld05vZGVzLnNpemUgPiAwO1xuICAgIH0sXG4gICAgY2FuY2VsQ29ubmVjdGlvbjogKCkgPT4ge1xuICAgICAgICBzZXQoe1xuICAgICAgICAgICAgY29ubmVjdGlvbjogeyAuLi5pbml0aWFsQ29ubmVjdGlvbiB9LFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvbm5lY3Rpb246IChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgIHNldCh7IGNvbm5lY3Rpb24gfSk7XG4gICAgfSxcbiAgICByZXNldDogKCkgPT4gc2V0KHsgLi4uZ2V0SW5pdGlhbFN0YXRlKCkgfSksXG59KSwgT2JqZWN0LmlzKTtcblxuZnVuY3Rpb24gUmVhY3RGbG93UHJvdmlkZXIoeyBpbml0aWFsTm9kZXM6IG5vZGVzLCBpbml0aWFsRWRnZXM6IGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgaW5pdGlhbFdpZHRoOiB3aWR0aCwgaW5pdGlhbEhlaWdodDogaGVpZ2h0LCBmaXRWaWV3LCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBjaGlsZHJlbiwgfSkge1xuICAgIGNvbnN0IFtzdG9yZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVTdG9yZSh7XG4gICAgICAgIG5vZGVzLFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgZGVmYXVsdE5vZGVzLFxuICAgICAgICBkZWZhdWx0RWRnZXMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGZpdFZpZXcsXG4gICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgIG5vZGVFeHRlbnQsXG4gICAgfSkpO1xuICAgIHJldHVybiAoanN4KFByb3ZpZGVyJDEsIHsgdmFsdWU6IHN0b3JlLCBjaGlsZHJlbjoganN4KEJhdGNoUHJvdmlkZXIsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gV3JhcHBlcih7IGNoaWxkcmVuLCBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3LCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCB9KSB7XG4gICAgY29uc3QgaXNXcmFwcGVkID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICAgIGlmIChpc1dyYXBwZWQpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIGl0IHdpdGggYSBmcmFnbWVudCBiZWNhdXNlIGl0J3Mgbm90IGFsbG93ZWQgZm9yIGNoaWxkcmVuIHRvIGJlIGEgUmVhY3ROb2RlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EZWZpbml0ZWx5VHlwZWQvRGVmaW5pdGVseVR5cGVkL2lzc3Vlcy8xODA1MVxuICAgICAgICByZXR1cm4ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goUmVhY3RGbG93UHJvdmlkZXIsIHsgaW5pdGlhbE5vZGVzOiBub2RlcywgaW5pdGlhbEVkZ2VzOiBlZGdlcywgZGVmYXVsdE5vZGVzOiBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlczogZGVmYXVsdEVkZ2VzLCBpbml0aWFsV2lkdGg6IHdpZHRoLCBpbml0aWFsSGVpZ2h0OiBoZWlnaHQsIGZpdFZpZXc6IGZpdFZpZXcsIG5vZGVPcmlnaW46IG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQ6IG5vZGVFeHRlbnQsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHdyYXBwZXJTdHlsZSA9IHtcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB6SW5kZXg6IDAsXG59O1xuZnVuY3Rpb24gUmVhY3RGbG93KHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgY2xhc3NOYW1lLCBub2RlVHlwZXMsIGVkZ2VUeXBlcywgb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrLCBvbkluaXQsIG9uTW92ZSwgb25Nb3ZlU3RhcnQsIG9uTW92ZUVuZCwgb25Db25uZWN0LCBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kLCBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZCwgb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlLCBvbk5vZGVNb3VzZUxlYXZlLCBvbk5vZGVDb250ZXh0TWVudSwgb25Ob2RlRG91YmxlQ2xpY2ssIG9uTm9kZURyYWdTdGFydCwgb25Ob2RlRHJhZywgb25Ob2RlRHJhZ1N0b3AsIG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGUsIG9uRGVsZXRlLCBvblNlbGVjdGlvbkNoYW5nZSwgb25TZWxlY3Rpb25EcmFnU3RhcnQsIG9uU2VsZWN0aW9uRHJhZywgb25TZWxlY3Rpb25EcmFnU3RvcCwgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIG9uQmVmb3JlRGVsZXRlLCBjb25uZWN0aW9uTW9kZSwgY29ubmVjdGlvbkxpbmVUeXBlID0gQ29ubmVjdGlvbkxpbmVUeXBlLkJlemllciwgY29ubmVjdGlvbkxpbmVTdHlsZSwgY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIGRlbGV0ZUtleUNvZGUgPSAnQmFja3NwYWNlJywgc2VsZWN0aW9uS2V5Q29kZSA9ICdTaGlmdCcsIHNlbGVjdGlvbk9uRHJhZyA9IGZhbHNlLCBzZWxlY3Rpb25Nb2RlID0gU2VsZWN0aW9uTW9kZS5GdWxsLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSA9ICdTcGFjZScsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSA9IGlzTWFjT3MoKSA/ICdNZXRhJyA6ICdDb250cm9sJywgem9vbUFjdGl2YXRpb25LZXlDb2RlID0gaXNNYWNPcygpID8gJ01ldGEnIDogJ0NvbnRyb2wnLCBzbmFwVG9HcmlkLCBzbmFwR3JpZCwgb25seVJlbmRlclZpc2libGVFbGVtZW50cyA9IGZhbHNlLCBzZWxlY3ROb2Rlc09uRHJhZywgbm9kZXNEcmFnZ2FibGUsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCBub2RlT3JpZ2luID0gZGVmYXVsdE5vZGVPcmlnaW4sIGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSA9IHRydWUsIGRlZmF1bHRWaWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0JDEgPSBkZWZhdWx0Vmlld3BvcnQsIG1pblpvb20gPSAwLjUsIG1heFpvb20gPSAyLCB0cmFuc2xhdGVFeHRlbnQgPSBpbmZpbml0ZUV4dGVudCwgcHJldmVudFNjcm9sbGluZyA9IHRydWUsIG5vZGVFeHRlbnQsIGRlZmF1bHRNYXJrZXJDb2xvciA9ICcjYjFiMWI3Jywgem9vbU9uU2Nyb2xsID0gdHJ1ZSwgem9vbU9uUGluY2ggPSB0cnVlLCBwYW5PblNjcm9sbCA9IGZhbHNlLCBwYW5PblNjcm9sbFNwZWVkID0gMC41LCBwYW5PblNjcm9sbE1vZGUgPSBQYW5PblNjcm9sbE1vZGUuRnJlZSwgem9vbU9uRG91YmxlQ2xpY2sgPSB0cnVlLCBwYW5PbkRyYWcgPSB0cnVlLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51LCBwYW5lQ2xpY2tEaXN0YW5jZSA9IDAsIG5vZGVDbGlja0Rpc3RhbmNlID0gMCwgY2hpbGRyZW4sIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1cyA9IDEwLCBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlLCBub0RyYWdDbGFzc05hbWUgPSAnbm9kcmFnJywgbm9XaGVlbENsYXNzTmFtZSA9ICdub3doZWVsJywgbm9QYW5DbGFzc05hbWUgPSAnbm9wYW4nLCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgY29ubmVjdE9uQ2xpY2ssIGF0dHJpYnV0aW9uUG9zaXRpb24sIHByb09wdGlvbnMsIGRlZmF1bHRFZGdlT3B0aW9ucywgZWxldmF0ZU5vZGVzT25TZWxlY3QsIGVsZXZhdGVFZGdlc09uU2VsZWN0LCBkaXNhYmxlS2V5Ym9hcmRBMTF5ID0gZmFsc2UsIGF1dG9QYW5PbkNvbm5lY3QsIGF1dG9QYW5Pbk5vZGVEcmFnLCBhdXRvUGFuU3BlZWQsIGNvbm5lY3Rpb25SYWRpdXMsIGlzVmFsaWRDb25uZWN0aW9uLCBvbkVycm9yLCBzdHlsZSwgaWQsIG5vZGVEcmFnVGhyZXNob2xkLCB2aWV3cG9ydCwgb25WaWV3cG9ydENoYW5nZSwgd2lkdGgsIGhlaWdodCwgY29sb3JNb2RlID0gJ2xpZ2h0JywgZGVidWcsIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgY29uc3QgcmZJZCA9IGlkIHx8ICcxJztcbiAgICBjb25zdCBjb2xvck1vZGVDbGFzc05hbWUgPSB1c2VDb2xvck1vZGVDbGFzcyhjb2xvck1vZGUpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgXCJkYXRhLXRlc3RpZFwiOiBcInJmX193cmFwcGVyXCIsIC4uLnJlc3QsIHN0eWxlOiB7IC4uLnN0eWxlLCAuLi53cmFwcGVyU3R5bGUgfSwgcmVmOiByZWYsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93JywgY2xhc3NOYW1lLCBjb2xvck1vZGVDbGFzc05hbWVdKSwgaWQ6IGlkLCBjaGlsZHJlbjoganN4cyhXcmFwcGVyLCB7IG5vZGVzOiBub2RlcywgZWRnZXM6IGVkZ2VzLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBmaXRWaWV3OiBmaXRWaWV3LCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBjaGlsZHJlbjogW2pzeChHcmFwaFZpZXcsIHsgb25Jbml0OiBvbkluaXQsIG9uTm9kZUNsaWNrOiBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyOiBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmU6IG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZTogb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnU6IG9uTm9kZUNvbnRleHRNZW51LCBvbk5vZGVEb3VibGVDbGljazogb25Ob2RlRG91YmxlQ2xpY2ssIG5vZGVUeXBlczogbm9kZVR5cGVzLCBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgY29ubmVjdGlvbkxpbmVUeXBlOiBjb25uZWN0aW9uTGluZVR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZTogY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIGRlbGV0ZUtleUNvZGU6IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZTogbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZTogcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCQxLCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBub2RlQ2xpY2tEaXN0YW5jZTogbm9kZUNsaWNrRGlzdGFuY2UsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCB2aWV3cG9ydDogdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UgfSksIGpzeChTdG9yZVVwZGF0ZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIGRlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcywgb25Db25uZWN0OiBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0OiBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kOiBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQ6IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kOiBvbkNsaWNrQ29ubmVjdEVuZCwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlOiBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZTogbm9kZXNGb2N1c2FibGUsIGVkZ2VzRm9jdXNhYmxlOiBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlOiBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCBlbGV2YXRlTm9kZXNPblNlbGVjdDogZWxldmF0ZU5vZGVzT25TZWxlY3QsIGVsZXZhdGVFZGdlc09uU2VsZWN0OiBlbGV2YXRlRWRnZXNPblNlbGVjdCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgb25Ob2Rlc0NoYW5nZTogb25Ob2Rlc0NoYW5nZSwgb25FZGdlc0NoYW5nZTogb25FZGdlc0NoYW5nZSwgc25hcFRvR3JpZDogc25hcFRvR3JpZCwgc25hcEdyaWQ6IHNuYXBHcmlkLCBjb25uZWN0aW9uTW9kZTogY29ubmVjdGlvbk1vZGUsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBjb25uZWN0T25DbGljazogY29ubmVjdE9uQ2xpY2ssIGRlZmF1bHRFZGdlT3B0aW9uczogZGVmYXVsdEVkZ2VPcHRpb25zLCBmaXRWaWV3OiBmaXRWaWV3LCBmaXRWaWV3T3B0aW9uczogZml0Vmlld09wdGlvbnMsIG9uTm9kZXNEZWxldGU6IG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGU6IG9uRWRnZXNEZWxldGUsIG9uRGVsZXRlOiBvbkRlbGV0ZSwgb25Ob2RlRHJhZ1N0YXJ0OiBvbk5vZGVEcmFnU3RhcnQsIG9uTm9kZURyYWc6IG9uTm9kZURyYWcsIG9uTm9kZURyYWdTdG9wOiBvbk5vZGVEcmFnU3RvcCwgb25TZWxlY3Rpb25EcmFnOiBvblNlbGVjdGlvbkRyYWcsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0OiBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RvcDogb25TZWxlY3Rpb25EcmFnU3RvcCwgb25Nb3ZlOiBvbk1vdmUsIG9uTW92ZVN0YXJ0OiBvbk1vdmVTdGFydCwgb25Nb3ZlRW5kOiBvbk1vdmVFbmQsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgbm9kZU9yaWdpbjogbm9kZU9yaWdpbiwgcmZJZDogcmZJZCwgYXV0b1Bhbk9uQ29ubmVjdDogYXV0b1Bhbk9uQ29ubmVjdCwgYXV0b1Bhbk9uTm9kZURyYWc6IGF1dG9QYW5Pbk5vZGVEcmFnLCBhdXRvUGFuU3BlZWQ6IGF1dG9QYW5TcGVlZCwgb25FcnJvcjogb25FcnJvciwgY29ubmVjdGlvblJhZGl1czogY29ubmVjdGlvblJhZGl1cywgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uLCBzZWxlY3ROb2Rlc09uRHJhZzogc2VsZWN0Tm9kZXNPbkRyYWcsIG5vZGVEcmFnVGhyZXNob2xkOiBub2RlRHJhZ1RocmVzaG9sZCwgb25CZWZvcmVEZWxldGU6IG9uQmVmb3JlRGVsZXRlLCBwYW5lQ2xpY2tEaXN0YW5jZTogcGFuZUNsaWNrRGlzdGFuY2UsIGRlYnVnOiBkZWJ1ZyB9KSwganN4KFNlbGVjdGlvbkxpc3RlbmVyLCB7IG9uU2VsZWN0aW9uQ2hhbmdlOiBvblNlbGVjdGlvbkNoYW5nZSB9KSwgY2hpbGRyZW4sIGpzeChBdHRyaWJ1dGlvbiwgeyBwcm9PcHRpb25zOiBwcm9PcHRpb25zLCBwb3NpdGlvbjogYXR0cmlidXRpb25Qb3NpdGlvbiB9KSwganN4KEExMXlEZXNjcmlwdGlvbnMsIHsgcmZJZDogcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9KV0gfSkgfSkpO1xufVxudmFyIGluZGV4ID0gZml4ZWRGb3J3YXJkUmVmKFJlYWN0Rmxvdyk7XG5cbmNvbnN0IHNlbGVjdG9yJDYgPSAocykgPT4gcy5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fZWRnZWxhYmVsLXJlbmRlcmVyJyk7XG5mdW5jdGlvbiBFZGdlTGFiZWxSZW5kZXJlcih7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCBlZGdlTGFiZWxSZW5kZXJlciA9IHVzZVN0b3JlKHNlbGVjdG9yJDYpO1xuICAgIGlmICghZWRnZUxhYmVsUmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGVkZ2VMYWJlbFJlbmRlcmVyKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkNSA9IChzKSA9PiBzLmRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X192aWV3cG9ydC1wb3J0YWwnKTtcbmZ1bmN0aW9uIFZpZXdwb3J0UG9ydGFsKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHZpZXdQb3J0YWxEaXYgPSB1c2VTdG9yZShzZWxlY3RvciQ1KTtcbiAgICBpZiAoIXZpZXdQb3J0YWxEaXYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHZpZXdQb3J0YWxEaXYpO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIHVwZGF0aW5nIG5vZGUgaW50ZXJuYWxzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIGZvciB1cGRhdGluZyBub2RlIGludGVybmFsc1xuICovXG5mdW5jdGlvbiB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgdXBkYXRlTm9kZUludGVybmFscyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlSWRzID0gQXJyYXkuaXNBcnJheShpZCkgPyBpZCA6IFtpZF07XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHVwZGF0ZUlkcy5mb3JFYWNoKCh1cGRhdGVJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUVsZW1lbnQgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKGAucmVhY3QtZmxvd19fbm9kZVtkYXRhLWlkPVwiJHt1cGRhdGVJZH1cIl1gKTtcbiAgICAgICAgICAgIGlmIChub2RlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZXMuc2V0KHVwZGF0ZUlkLCB7IGlkOiB1cGRhdGVJZCwgbm9kZUVsZW1lbnQsIGZvcmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgeyB0cmlnZ2VyRml0VmlldzogZmFsc2UgfSkpO1xuICAgIH0sIFtdKTtcbn1cblxuY29uc3Qgbm9kZXNTZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUubm9kZXM7XG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdGhlIGN1cnJlbnQgbm9kZXMgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXNcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZXMoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB1c2VTdG9yZShub2Rlc1NlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gbm9kZXM7XG59XG5cbmNvbnN0IGVkZ2VzU2VsZWN0b3IgPSAoc3RhdGUpID0+IHN0YXRlLmVkZ2VzO1xuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHRoZSBjdXJyZW50IGVkZ2VzIGZyb20gdGhlIHN0b3JlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGVkZ2VzXG4gKi9cbmZ1bmN0aW9uIHVzZUVkZ2VzKCkge1xuICAgIGNvbnN0IGVkZ2VzID0gdXNlU3RvcmUoZWRnZXNTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIGVkZ2VzO1xufVxuXG5jb25zdCB2aWV3cG9ydFNlbGVjdG9yID0gKHN0YXRlKSA9PiAoe1xuICAgIHg6IHN0YXRlLnRyYW5zZm9ybVswXSxcbiAgICB5OiBzdGF0ZS50cmFuc2Zvcm1bMV0sXG4gICAgem9vbTogc3RhdGUudHJhbnNmb3JtWzJdLFxufSk7XG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdGhlIGN1cnJlbnQgdmlld3BvcnQgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgVGhlIGN1cnJlbnQgdmlld3BvcnRcbiAqL1xuZnVuY3Rpb24gdXNlVmlld3BvcnQoKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB1c2VTdG9yZSh2aWV3cG9ydFNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gdmlld3BvcnQ7XG59XG5cbi8qKlxuICogSG9vayBmb3IgbWFuYWdpbmcgdGhlIHN0YXRlIG9mIG5vZGVzIC0gc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgcHJvdG90eXBpbmcgLyBzaW1wbGUgdXNlIGNhc2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBpbml0aWFsTm9kZXNcbiAqIEByZXR1cm5zIGFuIGFycmF5IFtub2Rlcywgc2V0Tm9kZXMsIG9uTm9kZXNDaGFuZ2VdXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVzU3RhdGUoaW5pdGlhbE5vZGVzKSB7XG4gICAgY29uc3QgW25vZGVzLCBzZXROb2Rlc10gPSB1c2VTdGF0ZShpbml0aWFsTm9kZXMpO1xuICAgIGNvbnN0IG9uTm9kZXNDaGFuZ2UgPSB1c2VDYWxsYmFjaygoY2hhbmdlcykgPT4gc2V0Tm9kZXMoKG5kcykgPT4gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBuZHMpKSwgW10pO1xuICAgIHJldHVybiBbbm9kZXMsIHNldE5vZGVzLCBvbk5vZGVzQ2hhbmdlXTtcbn1cbi8qKlxuICogSG9vayBmb3IgbWFuYWdpbmcgdGhlIHN0YXRlIG9mIGVkZ2VzIC0gc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgcHJvdG90eXBpbmcgLyBzaW1wbGUgdXNlIGNhc2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBpbml0aWFsRWRnZXNcbiAqIEByZXR1cm5zIGFuIGFycmF5IFtlZGdlcywgc2V0RWRnZXMsIG9uRWRnZXNDaGFuZ2VdXG4gKi9cbmZ1bmN0aW9uIHVzZUVkZ2VzU3RhdGUoaW5pdGlhbEVkZ2VzKSB7XG4gICAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlc10gPSB1c2VTdGF0ZShpbml0aWFsRWRnZXMpO1xuICAgIGNvbnN0IG9uRWRnZXNDaGFuZ2UgPSB1c2VDYWxsYmFjaygoY2hhbmdlcykgPT4gc2V0RWRnZXMoKGVkcykgPT4gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBlZHMpKSwgW10pO1xuICAgIHJldHVybiBbZWRnZXMsIHNldEVkZ2VzLCBvbkVkZ2VzQ2hhbmdlXTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciByZWdpc3RlcmluZyBhbiBvblZpZXdwb3J0Q2hhbmdlIGhhbmRsZXIuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHBhcmFtcy5vblN0YXJ0IC0gZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdmlld3BvcnQgc3RhcnRzIGNoYW5naW5nXG4gKiBAcGFyYW0gcGFyYW1zLm9uQ2hhbmdlIC0gZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdmlld3BvcnQgY2hhbmdlc1xuICogQHBhcmFtIHBhcmFtcy5vbkVuZCAtIGdldHMgY2FsbGVkIHdoZW4gdGhlIHZpZXdwb3J0IHN0b3BzIGNoYW5naW5nXG4gKi9cbmZ1bmN0aW9uIHVzZU9uVmlld3BvcnRDaGFuZ2UoeyBvblN0YXJ0LCBvbkNoYW5nZSwgb25FbmQgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2VTdGFydDogb25TdGFydCB9KTtcbiAgICB9LCBbb25TdGFydF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZTogb25DaGFuZ2UgfSk7XG4gICAgfSwgW29uQ2hhbmdlXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlRW5kOiBvbkVuZCB9KTtcbiAgICB9LCBbb25FbmRdKTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciByZWdpc3RlcmluZyBhbiBvblNlbGVjdGlvbkNoYW5nZSBoYW5kbGVyLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBwYXJhbXMub25DaGFuZ2UgLSBUaGUgaGFuZGxlciB0byByZWdpc3RlclxuICovXG5mdW5jdGlvbiB1c2VPblNlbGVjdGlvbkNoYW5nZSh7IG9uQ2hhbmdlIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dE9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgPSBbLi4uc3RvcmUuZ2V0U3RhdGUoKS5vblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzLCBvbkNoYW5nZV07XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVyczogbmV4dE9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0SGFuZGxlcnMgPSBzdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMuZmlsdGVyKChmbikgPT4gZm4gIT09IG9uQ2hhbmdlKTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVyczogbmV4dEhhbmRsZXJzIH0pO1xuICAgICAgICB9O1xuICAgIH0sIFtvbkNoYW5nZV0pO1xufVxuXG5jb25zdCBzZWxlY3RvciQ0ID0gKG9wdGlvbnMpID0+IChzKSA9PiB7XG4gICAgaWYgKHMubm9kZUxvb2t1cC5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbLCB7IGhpZGRlbiwgaW50ZXJuYWxzIH1dIG9mIHMubm9kZUxvb2t1cCkge1xuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlSGlkZGVuTm9kZXMgfHwgIWhpZGRlbikge1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5oYW5kbGVCb3VuZHMgPT09IHVuZGVmaW5lZCB8fCAhbm9kZUhhc0RpbWVuc2lvbnMoaW50ZXJuYWxzLnVzZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBpbmNsdWRlSGlkZGVuTm9kZXM6IGZhbHNlLFxufTtcbi8qKlxuICogSG9vayB3aGljaCByZXR1cm5zIHRydWUgd2hlbiBhbGwgbm9kZXMgYXJlIGluaXRpYWxpemVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBvcHRpb25zLmluY2x1ZGVIaWRkZW5Ob2RlcyAtIGRlZmF1bHRzIHRvIGZhbHNlXG4gKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbGwgbm9kZXMgYXJlIGluaXRpYWxpemVkXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVzSW5pdGlhbGl6ZWQob3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKSB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZWQgPSB1c2VTdG9yZShzZWxlY3RvciQ0KG9wdGlvbnMpKTtcbiAgICByZXR1cm4gaW5pdGlhbGl6ZWQ7XG59XG5cbi8qKlxuICogSG9vayB0byBjaGVjayBpZiBhIDxIYW5kbGUgLz4gaXMgY29ubmVjdGVkIHRvIGFub3RoZXIgPEhhbmRsZSAvPiBhbmQgZ2V0IHRoZSBjb25uZWN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHVzZU5vZGVDb25uZWN0aW9uc2AgaW5zdGVhZC5cbiAqIEBwYXJhbSBwYXJhbS50eXBlIC0gaGFuZGxlIHR5cGUgJ3NvdXJjZScgb3IgJ3RhcmdldCdcbiAqIEBwYXJhbSBwYXJhbS5ub2RlSWQgLSBub2RlIGlkIC0gaWYgbm90IHByb3ZpZGVkLCB0aGUgbm9kZSBpZCBmcm9tIHRoZSBOb2RlSWRDb250ZXh0IGlzIHVzZWRcbiAqIEBwYXJhbSBwYXJhbS5pZCAtIHRoZSBoYW5kbGUgaWQgKHRoaXMgaXMgb25seSBuZWVkZWQgaWYgdGhlIG5vZGUgaGFzIG11bHRpcGxlIGhhbmRsZXMgb2YgdGhlIHNhbWUgdHlwZSlcbiAqIEBwYXJhbSBwYXJhbS5vbkNvbm5lY3QgLSBnZXRzIGNhbGxlZCB3aGVuIGEgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZFxuICogQHBhcmFtIHBhcmFtLm9uRGlzY29ubmVjdCAtIGdldHMgY2FsbGVkIHdoZW4gYSBjb25uZWN0aW9uIGlzIHJlbW92ZWRcbiAqIEByZXR1cm5zIGFuIGFycmF5IHdpdGggaGFuZGxlIGNvbm5lY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZUhhbmRsZUNvbm5lY3Rpb25zKHsgdHlwZSwgaWQsIG5vZGVJZCwgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3QsIH0pIHtcbiAgICBjb25zb2xlLndhcm4oJ1tERVBSRUNBVEVEXSBgdXNlSGFuZGxlQ29ubmVjdGlvbnNgIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgdXNlIGB1c2VOb2RlQ29ubmVjdGlvbnNgIGh0dHBzOi8vcmVhY3RmbG93LmRldi9hcGktcmVmZXJlbmNlL2hvb2tzL3VzZU5vZGVDb25uZWN0aW9ucycpO1xuICAgIGNvbnN0IF9ub2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlkID0gbm9kZUlkID8/IF9ub2RlSWQ7XG4gICAgY29uc3QgcHJldkNvbm5lY3Rpb25zID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5jb25uZWN0aW9uTG9va3VwLmdldChgJHtjdXJyZW50Tm9kZUlkfS0ke3R5cGV9JHtpZCA/IGAtJHtpZH1gIDogJyd9YCksIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEB0b2RvIGRpY3VzcyBpZiBvbkNvbm5lY3Qvb25EaXNjb25uZWN0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IG1vdW50cy91bm1vdW50c1xuICAgICAgICBpZiAocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgJiYgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgIT09IGNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBfY29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBfY29ubmVjdGlvbnMsIG9uRGlzY29ubmVjdCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKF9jb25uZWN0aW9ucywgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIG9uQ29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgfSwgW2Nvbm5lY3Rpb25zLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdF0pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IEFycmF5LmZyb20oY29ubmVjdGlvbnM/LnZhbHVlcygpID8/IFtdKSwgW2Nvbm5lY3Rpb25zXSk7XG59XG5cbmNvbnN0IGVycm9yMDE0ID0gZXJyb3JNZXNzYWdlc1snZXJyb3IwMTQnXSgpO1xuLyoqXG4gKiBIb29rIHRvIHJldHJpZXZlIGFsbCBlZGdlcyBjb25uZWN0ZWQgdG8gYSBub2RlLiBDYW4gYmUgZmlsdGVyZWQgYnkgaGFuZGxlIHR5cGUgYW5kIGlkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBwYXJhbS5pZCAtIG5vZGUgaWQgLSBvcHRpb25hbCBpZiBjYWxsZWQgaW5zaWRlIGEgY3VzdG9tIG5vZGVcbiAqIEBwYXJhbSBwYXJhbS5oYW5kbGVUeXBlIC0gZmlsdGVyIGJ5IGhhbmRsZSB0eXBlICdzb3VyY2UnIG9yICd0YXJnZXQnXG4gKiBAcGFyYW0gcGFyYW0uaGFuZGxlSWQgLSBmaWx0ZXIgYnkgaGFuZGxlIGlkICh0aGlzIGlzIG9ubHkgbmVlZGVkIGlmIHRoZSBub2RlIGhhcyBtdWx0aXBsZSBoYW5kbGVzIG9mIHRoZSBzYW1lIHR5cGUpXG4gKiBAcGFyYW0gcGFyYW0ub25Db25uZWN0IC0gZ2V0cyBjYWxsZWQgd2hlbiBhIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWRcbiAqIEBwYXJhbSBwYXJhbS5vbkRpc2Nvbm5lY3QgLSBnZXRzIGNhbGxlZCB3aGVuIGEgY29ubmVjdGlvbiBpcyByZW1vdmVkXG4gKiBAcmV0dXJucyBhbiBhcnJheSB3aXRoIGNvbm5lY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVDb25uZWN0aW9ucyh7IGlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3QsIH0gPSB7fSkge1xuICAgIGNvbnN0IG5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IGN1cnJlbnROb2RlSWQgPSBpZCA/PyBub2RlSWQ7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcjAxNCk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZDb25uZWN0aW9ucyA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHVzZVN0b3JlKChzdGF0ZSkgPT4gc3RhdGUuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7Y3VycmVudE5vZGVJZH0ke2hhbmRsZVR5cGUgPyAoaGFuZGxlSWQgPyBgLSR7aGFuZGxlVHlwZX0tJHtoYW5kbGVJZH1gIDogYC0ke2hhbmRsZVR5cGV9YCkgOiAnJ31gKSwgYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gQHRvZG8gZGljdXNzIGlmIG9uQ29ubmVjdC9vbkRpc2Nvbm5lY3Qgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgbW91bnRzL3VubW91bnRzXG4gICAgICAgIGlmIChwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAmJiBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAhPT0gY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9jb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIF9jb25uZWN0aW9ucywgb25EaXNjb25uZWN0KTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UoX2Nvbm5lY3Rpb25zLCBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCwgb25Db25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICB9LCBbY29ubmVjdGlvbnMsIG9uQ29ubmVjdCwgb25EaXNjb25uZWN0XSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gQXJyYXkuZnJvbShjb25uZWN0aW9ucz8udmFsdWVzKCkgPz8gW10pLCBbY29ubmVjdGlvbnNdKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHVzZU5vZGVzRGF0YShub2RlSWRzKSB7XG4gICAgY29uc3Qgbm9kZXNEYXRhID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHMpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBjb25zdCBpc0FycmF5T2ZJZHMgPSBBcnJheS5pc0FycmF5KG5vZGVJZHMpO1xuICAgICAgICBjb25zdCBfbm9kZUlkcyA9IGlzQXJyYXlPZklkcyA/IG5vZGVJZHMgOiBbbm9kZUlkc107XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZUlkIG9mIF9ub2RlSWRzKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gcy5ub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBub2RlLmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXlPZklkcyA/IGRhdGEgOiBkYXRhWzBdID8/IG51bGw7XG4gICAgfSwgW25vZGVJZHNdKSwgc2hhbGxvd05vZGVEYXRhKTtcbiAgICByZXR1cm4gbm9kZXNEYXRhO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgYW4gaW50ZXJuYWwgbm9kZSBieSBpZFxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBpZCAtIGlkIG9mIHRoZSBub2RlXG4gKiBAcmV0dXJucyBhcnJheSB3aXRoIHZpc2libGUgbm9kZSBpZHNcbiAqL1xuZnVuY3Rpb24gdXNlSW50ZXJuYWxOb2RlKGlkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiBzLm5vZGVMb29rdXAuZ2V0KGlkKSwgW2lkXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBMaW5lUGF0dGVybih7IGRpbWVuc2lvbnMsIGxpbmVXaWR0aCwgdmFyaWFudCwgY2xhc3NOYW1lIH0pIHtcbiAgICByZXR1cm4gKGpzeChcInBhdGhcIiwgeyBzdHJva2VXaWR0aDogbGluZVdpZHRoLCBkOiBgTSR7ZGltZW5zaW9uc1swXSAvIDJ9IDAgViR7ZGltZW5zaW9uc1sxXX0gTTAgJHtkaW1lbnNpb25zWzFdIC8gMn0gSCR7ZGltZW5zaW9uc1swXX1gLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZC1wYXR0ZXJuJywgdmFyaWFudCwgY2xhc3NOYW1lXSkgfSkpO1xufVxuZnVuY3Rpb24gRG90UGF0dGVybih7IHJhZGl1cywgY2xhc3NOYW1lIH0pIHtcbiAgICByZXR1cm4gKGpzeChcImNpcmNsZVwiLCB7IGN4OiByYWRpdXMsIGN5OiByYWRpdXMsIHI6IHJhZGl1cywgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2JhY2tncm91bmQtcGF0dGVybicsICdkb3RzJywgY2xhc3NOYW1lXSkgfSkpO1xufVxuXG52YXIgQmFja2dyb3VuZFZhcmlhbnQ7XG4oZnVuY3Rpb24gKEJhY2tncm91bmRWYXJpYW50KSB7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJMaW5lc1wiXSA9IFwibGluZXNcIjtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkRvdHNcIl0gPSBcImRvdHNcIjtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkNyb3NzXCJdID0gXCJjcm9zc1wiO1xufSkoQmFja2dyb3VuZFZhcmlhbnQgfHwgKEJhY2tncm91bmRWYXJpYW50ID0ge30pKTtcblxuY29uc3QgZGVmYXVsdFNpemUgPSB7XG4gICAgW0JhY2tncm91bmRWYXJpYW50LkRvdHNdOiAxLFxuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc106IDEsXG4gICAgW0JhY2tncm91bmRWYXJpYW50LkNyb3NzXTogNixcbn07XG5jb25zdCBzZWxlY3RvciQzID0gKHMpID0+ICh7IHRyYW5zZm9ybTogcy50cmFuc2Zvcm0sIHBhdHRlcm5JZDogYHBhdHRlcm4tJHtzLnJmSWR9YCB9KTtcbmZ1bmN0aW9uIEJhY2tncm91bmRDb21wb25lbnQoeyBpZCwgdmFyaWFudCA9IEJhY2tncm91bmRWYXJpYW50LkRvdHMsIFxuLy8gb25seSB1c2VkIGZvciBkb3RzIGFuZCBjcm9zc1xuZ2FwID0gMjAsIFxuLy8gb25seSB1c2VkIGZvciBsaW5lcyBhbmQgY3Jvc3NcbnNpemUsIGxpbmVXaWR0aCA9IDEsIG9mZnNldCA9IDAsIGNvbG9yLCBiZ0NvbG9yLCBzdHlsZSwgY2xhc3NOYW1lLCBwYXR0ZXJuQ2xhc3NOYW1lLCB9KSB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBwYXR0ZXJuSWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDMsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHBhdHRlcm5TaXplID0gc2l6ZSB8fCBkZWZhdWx0U2l6ZVt2YXJpYW50XTtcbiAgICBjb25zdCBpc0RvdHMgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzO1xuICAgIGNvbnN0IGlzQ3Jvc3MgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Dcm9zcztcbiAgICBjb25zdCBnYXBYWSA9IEFycmF5LmlzQXJyYXkoZ2FwKSA/IGdhcCA6IFtnYXAsIGdhcF07XG4gICAgY29uc3Qgc2NhbGVkR2FwID0gW2dhcFhZWzBdICogdHJhbnNmb3JtWzJdIHx8IDEsIGdhcFhZWzFdICogdHJhbnNmb3JtWzJdIHx8IDFdO1xuICAgIGNvbnN0IHNjYWxlZFNpemUgPSBwYXR0ZXJuU2l6ZSAqIHRyYW5zZm9ybVsyXTtcbiAgICBjb25zdCBvZmZzZXRYWSA9IEFycmF5LmlzQXJyYXkob2Zmc2V0KSA/IG9mZnNldCA6IFtvZmZzZXQsIG9mZnNldF07XG4gICAgY29uc3QgcGF0dGVybkRpbWVuc2lvbnMgPSBpc0Nyb3NzID8gW3NjYWxlZFNpemUsIHNjYWxlZFNpemVdIDogc2NhbGVkR2FwO1xuICAgIGNvbnN0IHNjYWxlZE9mZnNldCA9IFtcbiAgICAgICAgb2Zmc2V0WFlbMF0gKiB0cmFuc2Zvcm1bMl0gfHwgMSArIHBhdHRlcm5EaW1lbnNpb25zWzBdIC8gMixcbiAgICAgICAgb2Zmc2V0WFlbMV0gKiB0cmFuc2Zvcm1bMl0gfHwgMSArIHBhdHRlcm5EaW1lbnNpb25zWzFdIC8gMixcbiAgICBdO1xuICAgIGNvbnN0IF9wYXR0ZXJuSWQgPSBgJHtwYXR0ZXJuSWR9JHtpZCA/IGlkIDogJyd9YDtcbiAgICByZXR1cm4gKGpzeHMoXCJzdmdcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZCcsIGNsYXNzTmFtZV0pLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAuLi5jb250YWluZXJTdHlsZSxcbiAgICAgICAgICAgICctLXh5LWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiBiZ0NvbG9yLFxuICAgICAgICAgICAgJy0teHktYmFja2dyb3VuZC1wYXR0ZXJuLWNvbG9yLXByb3BzJzogY29sb3IsXG4gICAgICAgIH0sIHJlZjogcmVmLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX2JhY2tncm91bmRcIiwgY2hpbGRyZW46IFtqc3goXCJwYXR0ZXJuXCIsIHsgaWQ6IF9wYXR0ZXJuSWQsIHg6IHRyYW5zZm9ybVswXSAlIHNjYWxlZEdhcFswXSwgeTogdHJhbnNmb3JtWzFdICUgc2NhbGVkR2FwWzFdLCB3aWR0aDogc2NhbGVkR2FwWzBdLCBoZWlnaHQ6IHNjYWxlZEdhcFsxXSwgcGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsIHBhdHRlcm5UcmFuc2Zvcm06IGB0cmFuc2xhdGUoLSR7c2NhbGVkT2Zmc2V0WzBdfSwtJHtzY2FsZWRPZmZzZXRbMV19KWAsIGNoaWxkcmVuOiBpc0RvdHMgPyAoanN4KERvdFBhdHRlcm4sIHsgcmFkaXVzOiBzY2FsZWRTaXplIC8gMiwgY2xhc3NOYW1lOiBwYXR0ZXJuQ2xhc3NOYW1lIH0pKSA6IChqc3goTGluZVBhdHRlcm4sIHsgZGltZW5zaW9uczogcGF0dGVybkRpbWVuc2lvbnMsIGxpbmVXaWR0aDogbGluZVdpZHRoLCB2YXJpYW50OiB2YXJpYW50LCBjbGFzc05hbWU6IHBhdHRlcm5DbGFzc05hbWUgfSkpIH0pLCBqc3goXCJyZWN0XCIsIHsgeDogXCIwXCIsIHk6IFwiMFwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIGZpbGw6IGB1cmwoIyR7X3BhdHRlcm5JZH0pYCB9KV0gfSkpO1xufVxuQmFja2dyb3VuZENvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdCYWNrZ3JvdW5kJztcbmNvbnN0IEJhY2tncm91bmQgPSBtZW1vKEJhY2tncm91bmRDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBQbHVzSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDMyXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMzIgMTguMTMzSDE4LjEzM1YzMmgtNC4yNjZWMTguMTMzSDB2LTQuMjY2aDEzLjg2N1YwaDQuMjY2djEzLjg2N0gzMnpcIiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIE1pbnVzSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDVcIiwgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBkOiBcIk0wIDBoMzJ2NC4ySDB6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBGaXRWaWV3SWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDMyIDMwXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMy42OTIgNC42M2MwLS41My40LS45MzguOTM5LS45MzhoNS4yMTVWMEg0LjcwOEMyLjEzIDAgMCAyLjA1NCAwIDQuNjN2NS4yMTZoMy42OTJWNC42MzF6TTI3LjM1NCAwaC01LjJ2My42OTJoNS4xN2MuNTMgMCAuOTg0LjQuOTg0LjkzOXY1LjIxNUgzMlY0LjYzMUE0LjYyNCA0LjYyNCAwIDAwMjcuMzU0IDB6bS45NTQgMjQuODNjMCAuNTMyLS40Ljk0LS45MzkuOTRoLTUuMjE1djMuNzY4aDUuMjE1YzIuNTc3IDAgNC42MzEtMi4xMyA0LjYzMS00LjcwN3YtNS4xMzloLTMuNjkydjUuMTM5em0tMjMuNjc3Ljk0Yy0uNTMxIDAtLjkzOS0uNC0uOTM5LS45NHYtNS4xMzhIMHY1LjEzOWMwIDIuNTc3IDIuMTMgNC43MDcgNC43MDggNC43MDdoNS4xMzhWMjUuNzdINC42MzF6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBMb2NrSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDI1IDMyXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMjEuMzMzIDEwLjY2N0gxOS44MVY3LjYxOUMxOS44MSAzLjQyOSAxNi4zOCAwIDEyLjE5IDAgOCAwIDQuNTcxIDMuNDI5IDQuNTcxIDcuNjE5djMuMDQ4SDMuMDQ4QTMuMDU2IDMuMDU2IDAgMDAwIDEzLjcxNHYxNS4yMzhBMy4wNTYgMy4wNTYgMCAwMDMuMDQ4IDMyaDE4LjI4NWEzLjA1NiAzLjA1NiAwIDAwMy4wNDgtMy4wNDhWMTMuNzE0YTMuMDU2IDMuMDU2IDAgMDAtMy4wNDgtMy4wNDd6TTEyLjE5IDI0LjUzM2EzLjA1NiAzLjA1NiAwIDAxLTMuMDQ3LTMuMDQ3IDMuMDU2IDMuMDU2IDAgMDEzLjA0Ny0zLjA0OCAzLjA1NiAzLjA1NiAwIDAxMy4wNDggMy4wNDggMy4wNTYgMy4wNTYgMCAwMS0zLjA0OCAzLjA0N3ptNC43MjQtMTMuODY2SDcuNDY3VjcuNjE5YzAtMi41OSAyLjEzMy00LjcyNCA0LjcyMy00LjcyNCAyLjU5MSAwIDQuNzI0IDIuMTMzIDQuNzI0IDQuNzI0djMuMDQ4elwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gVW5sb2NrSWNvbigpIHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDI1IDMyXCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMjEuMzMzIDEwLjY2N0gxOS44MVY3LjYxOUMxOS44MSAzLjQyOSAxNi4zOCAwIDEyLjE5IDBjLTQuMTE0IDEuODI4LTEuMzcgMi4xMzMuMzA1IDIuNDM4IDEuNjc2LjMwNSA0LjQyIDIuNTkgNC40MiA1LjE4MXYzLjA0OEgzLjA0N0EzLjA1NiAzLjA1NiAwIDAwMCAxMy43MTR2MTUuMjM4QTMuMDU2IDMuMDU2IDAgMDAzLjA0OCAzMmgxOC4yODVhMy4wNTYgMy4wNTYgMCAwMDMuMDQ4LTMuMDQ4VjEzLjcxNGEzLjA1NiAzLjA1NiAwIDAwLTMuMDQ4LTMuMDQ3ek0xMi4xOSAyNC41MzNhMy4wNTYgMy4wNTYgMCAwMS0zLjA0Ny0zLjA0NyAzLjA1NiAzLjA1NiAwIDAxMy4wNDctMy4wNDggMy4wNTYgMy4wNTYgMCAwMTMuMDQ4IDMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEtMy4wNDggMy4wNDd6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBDb250cm9sQnV0dG9uKHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucmVzdCB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fY29udHJvbHMtYnV0dG9uJywgY2xhc3NOYW1lXSksIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDIgPSAocykgPT4gKHtcbiAgICBpc0ludGVyYWN0aXZlOiBzLm5vZGVzRHJhZ2dhYmxlIHx8IHMubm9kZXNDb25uZWN0YWJsZSB8fCBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBtaW5ab29tUmVhY2hlZDogcy50cmFuc2Zvcm1bMl0gPD0gcy5taW5ab29tLFxuICAgIG1heFpvb21SZWFjaGVkOiBzLnRyYW5zZm9ybVsyXSA+PSBzLm1heFpvb20sXG59KTtcbmZ1bmN0aW9uIENvbnRyb2xzQ29tcG9uZW50KHsgc3R5bGUsIHNob3dab29tID0gdHJ1ZSwgc2hvd0ZpdFZpZXcgPSB0cnVlLCBzaG93SW50ZXJhY3RpdmUgPSB0cnVlLCBmaXRWaWV3T3B0aW9ucywgb25ab29tSW4sIG9uWm9vbU91dCwgb25GaXRWaWV3LCBvbkludGVyYWN0aXZlQ2hhbmdlLCBjbGFzc05hbWUsIGNoaWxkcmVuLCBwb3NpdGlvbiA9ICdib3R0b20tbGVmdCcsIG9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJywgJ2FyaWEtbGFiZWwnOiBhcmlhTGFiZWwgPSAnUmVhY3QgRmxvdyBjb250cm9scycsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyBpc0ludGVyYWN0aXZlLCBtaW5ab29tUmVhY2hlZCwgbWF4Wm9vbVJlYWNoZWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDIsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHsgem9vbUluLCB6b29tT3V0LCBmaXRWaWV3IH0gPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBvblpvb21JbkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHpvb21JbigpO1xuICAgICAgICBvblpvb21Jbj8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvblpvb21PdXRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB6b29tT3V0KCk7XG4gICAgICAgIG9uWm9vbU91dD8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvbkZpdFZpZXdIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBmaXRWaWV3KGZpdFZpZXdPcHRpb25zKTtcbiAgICAgICAgb25GaXRWaWV3Py4oKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uVG9nZ2xlSW50ZXJhY3Rpdml0eSA9ICgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgbm9kZXNEcmFnZ2FibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICAgICAgbm9kZXNDb25uZWN0YWJsZTogIWlzSW50ZXJhY3RpdmUsXG4gICAgICAgICAgICBlbGVtZW50c1NlbGVjdGFibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICB9KTtcbiAgICAgICAgb25JbnRlcmFjdGl2ZUNoYW5nZT8uKCFpc0ludGVyYWN0aXZlKTtcbiAgICB9O1xuICAgIGNvbnN0IG9yaWVudGF0aW9uQ2xhc3MgPSBvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbiAgICByZXR1cm4gKGpzeHMoUGFuZWwsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2NvbnRyb2xzJywgb3JpZW50YXRpb25DbGFzcywgY2xhc3NOYW1lXSksIHBvc2l0aW9uOiBwb3NpdGlvbiwgc3R5bGU6IHN0eWxlLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX2NvbnRyb2xzXCIsIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsIGNoaWxkcmVuOiBbc2hvd1pvb20gJiYgKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goQ29udHJvbEJ1dHRvbiwgeyBvbkNsaWNrOiBvblpvb21JbkhhbmRsZXIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy16b29taW5cIiwgdGl0bGU6IFwiem9vbSBpblwiLCBcImFyaWEtbGFiZWxcIjogXCJ6b29tIGluXCIsIGRpc2FibGVkOiBtYXhab29tUmVhY2hlZCwgY2hpbGRyZW46IGpzeChQbHVzSWNvbiwge30pIH0pLCBqc3goQ29udHJvbEJ1dHRvbiwgeyBvbkNsaWNrOiBvblpvb21PdXRIYW5kbGVyLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtem9vbW91dFwiLCB0aXRsZTogXCJ6b29tIG91dFwiLCBcImFyaWEtbGFiZWxcIjogXCJ6b29tIG91dFwiLCBkaXNhYmxlZDogbWluWm9vbVJlYWNoZWQsIGNoaWxkcmVuOiBqc3goTWludXNJY29uLCB7fSkgfSldIH0pKSwgc2hvd0ZpdFZpZXcgJiYgKGpzeChDb250cm9sQnV0dG9uLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy1maXR2aWV3XCIsIG9uQ2xpY2s6IG9uRml0Vmlld0hhbmRsZXIsIHRpdGxlOiBcImZpdCB2aWV3XCIsIFwiYXJpYS1sYWJlbFwiOiBcImZpdCB2aWV3XCIsIGNoaWxkcmVuOiBqc3goRml0Vmlld0ljb24sIHt9KSB9KSksIHNob3dJbnRlcmFjdGl2ZSAmJiAoanN4KENvbnRyb2xCdXR0b24sIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLWludGVyYWN0aXZlXCIsIG9uQ2xpY2s6IG9uVG9nZ2xlSW50ZXJhY3Rpdml0eSwgdGl0bGU6IFwidG9nZ2xlIGludGVyYWN0aXZpdHlcIiwgXCJhcmlhLWxhYmVsXCI6IFwidG9nZ2xlIGludGVyYWN0aXZpdHlcIiwgY2hpbGRyZW46IGlzSW50ZXJhY3RpdmUgPyBqc3goVW5sb2NrSWNvbiwge30pIDoganN4KExvY2tJY29uLCB7fSkgfSkpLCBjaGlsZHJlbl0gfSkpO1xufVxuQ29udHJvbHNDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnQ29udHJvbHMnO1xuY29uc3QgQ29udHJvbHMgPSBtZW1vKENvbnRyb2xzQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gTWluaU1hcE5vZGVDb21wb25lbnQoeyBpZCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgc3R5bGUsIGNvbG9yLCBzdHJva2VDb2xvciwgc3Ryb2tlV2lkdGgsIGNsYXNzTmFtZSwgYm9yZGVyUmFkaXVzLCBzaGFwZVJlbmRlcmluZywgc2VsZWN0ZWQsIG9uQ2xpY2ssIH0pIHtcbiAgICBjb25zdCB7IGJhY2tncm91bmQsIGJhY2tncm91bmRDb2xvciB9ID0gc3R5bGUgfHwge307XG4gICAgY29uc3QgZmlsbCA9IChjb2xvciB8fCBiYWNrZ3JvdW5kIHx8IGJhY2tncm91bmRDb2xvcik7XG4gICAgcmV0dXJuIChqc3goXCJyZWN0XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX21pbmltYXAtbm9kZScsIHsgc2VsZWN0ZWQgfSwgY2xhc3NOYW1lXSksIHg6IHgsIHk6IHksIHJ4OiBib3JkZXJSYWRpdXMsIHJ5OiBib3JkZXJSYWRpdXMsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHN0eWxlOiB7XG4gICAgICAgICAgICBmaWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB9LCBzaGFwZVJlbmRlcmluZzogc2hhcGVSZW5kZXJpbmcsIG9uQ2xpY2s6IG9uQ2xpY2sgPyAoZXZlbnQpID0+IG9uQ2xpY2soZXZlbnQsIGlkKSA6IHVuZGVmaW5lZCB9KSk7XG59XG5jb25zdCBNaW5pTWFwTm9kZSA9IG1lbW8oTWluaU1hcE5vZGVDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3Rvck5vZGVJZHMgPSAocykgPT4gcy5ub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuaWQpO1xuY29uc3QgZ2V0QXR0ckZ1bmN0aW9uID0gKGZ1bmMpID0+IGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGZ1bmMgOiAoKSA9PiBmdW5jO1xuZnVuY3Rpb24gTWluaU1hcE5vZGVzKHsgbm9kZVN0cm9rZUNvbG9yLCBub2RlQ29sb3IsIG5vZGVDbGFzc05hbWUgPSAnJywgbm9kZUJvcmRlclJhZGl1cyA9IDUsIG5vZGVTdHJva2VXaWR0aCwgXG4vLyBXZSBuZWVkIHRvIHJlbmFtZSB0aGUgcHJvcCB0byBiZSBgQ2FwaXRhbENhc2VgIHNvIHRoYXQgSlNYIHdpbGwgcmVuZGVyIGl0IGFzXG4vLyBhIGNvbXBvbmVudCBwcm9wZXJseS5cbm5vZGVDb21wb25lbnQ6IE5vZGVDb21wb25lbnQgPSBNaW5pTWFwTm9kZSwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IG5vZGVJZHMgPSB1c2VTdG9yZShzZWxlY3Rvck5vZGVJZHMsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG5vZGVDb2xvckZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZUNvbG9yKTtcbiAgICBjb25zdCBub2RlU3Ryb2tlQ29sb3JGdW5jID0gZ2V0QXR0ckZ1bmN0aW9uKG5vZGVTdHJva2VDb2xvcik7XG4gICAgY29uc3Qgbm9kZUNsYXNzTmFtZUZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZUNsYXNzTmFtZSk7XG4gICAgY29uc3Qgc2hhcGVSZW5kZXJpbmcgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhIXdpbmRvdy5jaHJvbWUgPyAnY3Jpc3BFZGdlcycgOiAnZ2VvbWV0cmljUHJlY2lzaW9uJztcbiAgICByZXR1cm4gKGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogbm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4gKFxuICAgICAgICAvLyBUaGUgc3BsaXQgb2YgcmVzcG9uc2liaWxpdGllcyBiZXR3ZWVuIE1pbmlNYXBOb2RlcyBhbmRcbiAgICAgICAgLy8gTm9kZUNvbXBvbmVudFdyYXBwZXIgbWF5IGFwcGVhciB3ZWlyZC4gSG93ZXZlciwgaXTigJlzIGRlc2lnbmVkIHRvXG4gICAgICAgIC8vIG1pbmltaXplIHRoZSBjb3N0IG9mIHVwZGF0ZXMgd2hlbiBpbmRpdmlkdWFsIG5vZGVzIGNoYW5nZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRm9yIG1vcmUgZGV0YWlscywgc2VlIGEgc2ltaWxhciBjb21taXQgaW4gYE5vZGVSZW5kZXJlci9pbmRleC50c3hgLlxuICAgICAgICBqc3goTm9kZUNvbXBvbmVudFdyYXBwZXIsIHsgaWQ6IG5vZGVJZCwgbm9kZUNvbG9yRnVuYzogbm9kZUNvbG9yRnVuYywgbm9kZVN0cm9rZUNvbG9yRnVuYzogbm9kZVN0cm9rZUNvbG9yRnVuYywgbm9kZUNsYXNzTmFtZUZ1bmM6IG5vZGVDbGFzc05hbWVGdW5jLCBub2RlQm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBub2RlU3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgTm9kZUNvbXBvbmVudDogTm9kZUNvbXBvbmVudCwgb25DbGljazogb25DbGljaywgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nIH0sIG5vZGVJZCkpKSB9KSk7XG59XG5mdW5jdGlvbiBOb2RlQ29tcG9uZW50V3JhcHBlcklubmVyKHsgaWQsIG5vZGVDb2xvckZ1bmMsIG5vZGVTdHJva2VDb2xvckZ1bmMsIG5vZGVDbGFzc05hbWVGdW5jLCBub2RlQm9yZGVyUmFkaXVzLCBub2RlU3Ryb2tlV2lkdGgsIHNoYXBlUmVuZGVyaW5nLCBOb2RlQ29tcG9uZW50LCBvbkNsaWNrLCB9KSB7XG4gICAgY29uc3QgeyBub2RlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VTdG9yZSgocykgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gcy5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH0sIHNoYWxsb3cpO1xuICAgIGlmICghbm9kZSB8fCBub2RlLmhpZGRlbiB8fCAhbm9kZUhhc0RpbWVuc2lvbnMobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KE5vZGVDb21wb25lbnQsIHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgc3R5bGU6IG5vZGUuc3R5bGUsIHNlbGVjdGVkOiAhIW5vZGUuc2VsZWN0ZWQsIGNsYXNzTmFtZTogbm9kZUNsYXNzTmFtZUZ1bmMobm9kZSksIGNvbG9yOiBub2RlQ29sb3JGdW5jKG5vZGUpLCBib3JkZXJSYWRpdXM6IG5vZGVCb3JkZXJSYWRpdXMsIHN0cm9rZUNvbG9yOiBub2RlU3Ryb2tlQ29sb3JGdW5jKG5vZGUpLCBzdHJva2VXaWR0aDogbm9kZVN0cm9rZVdpZHRoLCBzaGFwZVJlbmRlcmluZzogc2hhcGVSZW5kZXJpbmcsIG9uQ2xpY2s6IG9uQ2xpY2ssIGlkOiBub2RlLmlkIH0pKTtcbn1cbmNvbnN0IE5vZGVDb21wb25lbnRXcmFwcGVyID0gbWVtbyhOb2RlQ29tcG9uZW50V3JhcHBlcklubmVyKTtcbnZhciBNaW5pTWFwTm9kZXMkMSA9IG1lbW8oTWluaU1hcE5vZGVzKTtcblxuY29uc3QgZGVmYXVsdFdpZHRoID0gMjAwO1xuY29uc3QgZGVmYXVsdEhlaWdodCA9IDE1MDtcbmNvbnN0IHNlbGVjdG9yJDEgPSAocykgPT4ge1xuICAgIGNvbnN0IHZpZXdCQiA9IHtcbiAgICAgICAgeDogLXMudHJhbnNmb3JtWzBdIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIHk6IC1zLnRyYW5zZm9ybVsxXSAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICB3aWR0aDogcy53aWR0aCAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICBoZWlnaHQ6IHMuaGVpZ2h0IC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2aWV3QkIsXG4gICAgICAgIGJvdW5kaW5nUmVjdDogcy5ub2RlTG9va3VwLnNpemUgPiAwID8gZ2V0Qm91bmRzT2ZSZWN0cyhnZXRJbnRlcm5hbE5vZGVzQm91bmRzKHMubm9kZUxvb2t1cCksIHZpZXdCQikgOiB2aWV3QkIsXG4gICAgICAgIHJmSWQ6IHMucmZJZCxcbiAgICAgICAgcGFuWm9vbTogcy5wYW5ab29tLFxuICAgICAgICB0cmFuc2xhdGVFeHRlbnQ6IHMudHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICBmbG93V2lkdGg6IHMud2lkdGgsXG4gICAgICAgIGZsb3dIZWlnaHQ6IHMuaGVpZ2h0LFxuICAgIH07XG59O1xuY29uc3QgQVJJQV9MQUJFTF9LRVkgPSAncmVhY3QtZmxvd19fbWluaW1hcC1kZXNjJztcbmZ1bmN0aW9uIE1pbmlNYXBDb21wb25lbnQoeyBzdHlsZSwgY2xhc3NOYW1lLCBub2RlU3Ryb2tlQ29sb3IsIG5vZGVDb2xvciwgbm9kZUNsYXNzTmFtZSA9ICcnLCBub2RlQm9yZGVyUmFkaXVzID0gNSwgbm9kZVN0cm9rZVdpZHRoLCBcbi8vIFdlIG5lZWQgdG8gcmVuYW1lIHRoZSBwcm9wIHRvIGJlIGBDYXBpdGFsQ2FzZWAgc28gdGhhdCBKU1ggd2lsbCByZW5kZXIgaXQgYXNcbi8vIGEgY29tcG9uZW50IHByb3Blcmx5Llxubm9kZUNvbXBvbmVudCwgYmdDb2xvciwgbWFza0NvbG9yLCBtYXNrU3Ryb2tlQ29sb3IsIG1hc2tTdHJva2VXaWR0aCwgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0Jywgb25DbGljaywgb25Ob2RlQ2xpY2ssIHBhbm5hYmxlID0gZmFsc2UsIHpvb21hYmxlID0gZmFsc2UsIGFyaWFMYWJlbCA9ICdSZWFjdCBGbG93IG1pbmkgbWFwJywgaW52ZXJzZVBhbiwgem9vbVN0ZXAgPSAxMCwgb2Zmc2V0U2NhbGUgPSA1LCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHN2ZyA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB7IGJvdW5kaW5nUmVjdCwgdmlld0JCLCByZklkLCBwYW5ab29tLCB0cmFuc2xhdGVFeHRlbnQsIGZsb3dXaWR0aCwgZmxvd0hlaWdodCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkMSwgc2hhbGxvdyk7XG4gICAgY29uc3QgZWxlbWVudFdpZHRoID0gc3R5bGU/LndpZHRoID8/IGRlZmF1bHRXaWR0aDtcbiAgICBjb25zdCBlbGVtZW50SGVpZ2h0ID0gc3R5bGU/LmhlaWdodCA/PyBkZWZhdWx0SGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gYm91bmRpbmdSZWN0LndpZHRoIC8gZWxlbWVudFdpZHRoO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IGJvdW5kaW5nUmVjdC5oZWlnaHQgLyBlbGVtZW50SGVpZ2h0O1xuICAgIGNvbnN0IHZpZXdTY2FsZSA9IE1hdGgubWF4KHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgIGNvbnN0IHZpZXdXaWR0aCA9IHZpZXdTY2FsZSAqIGVsZW1lbnRXaWR0aDtcbiAgICBjb25zdCB2aWV3SGVpZ2h0ID0gdmlld1NjYWxlICogZWxlbWVudEhlaWdodDtcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRTY2FsZSAqIHZpZXdTY2FsZTtcbiAgICBjb25zdCB4ID0gYm91bmRpbmdSZWN0LnggLSAodmlld1dpZHRoIC0gYm91bmRpbmdSZWN0LndpZHRoKSAvIDIgLSBvZmZzZXQ7XG4gICAgY29uc3QgeSA9IGJvdW5kaW5nUmVjdC55IC0gKHZpZXdIZWlnaHQgLSBib3VuZGluZ1JlY3QuaGVpZ2h0KSAvIDIgLSBvZmZzZXQ7XG4gICAgY29uc3Qgd2lkdGggPSB2aWV3V2lkdGggKyBvZmZzZXQgKiAyO1xuICAgIGNvbnN0IGhlaWdodCA9IHZpZXdIZWlnaHQgKyBvZmZzZXQgKiAyO1xuICAgIGNvbnN0IGxhYmVsbGVkQnkgPSBgJHtBUklBX0xBQkVMX0tFWX0tJHtyZklkfWA7XG4gICAgY29uc3Qgdmlld1NjYWxlUmVmID0gdXNlUmVmKDApO1xuICAgIGNvbnN0IG1pbmltYXBJbnN0YW5jZSA9IHVzZVJlZigpO1xuICAgIHZpZXdTY2FsZVJlZi5jdXJyZW50ID0gdmlld1NjYWxlO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzdmcuY3VycmVudCAmJiBwYW5ab29tKSB7XG4gICAgICAgICAgICBtaW5pbWFwSW5zdGFuY2UuY3VycmVudCA9IFhZTWluaW1hcCh7XG4gICAgICAgICAgICAgICAgZG9tTm9kZTogc3ZnLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcGFuWm9vbSxcbiAgICAgICAgICAgICAgICBnZXRUcmFuc2Zvcm06ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIGdldFZpZXdTY2FsZTogKCkgPT4gdmlld1NjYWxlUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWluaW1hcEluc3RhbmNlLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbcGFuWm9vbV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIG1pbmltYXBJbnN0YW5jZS5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgdHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICAgICAgd2lkdGg6IGZsb3dXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZmxvd0hlaWdodCxcbiAgICAgICAgICAgIGludmVyc2VQYW4sXG4gICAgICAgICAgICBwYW5uYWJsZSxcbiAgICAgICAgICAgIHpvb21TdGVwLFxuICAgICAgICAgICAgem9vbWFibGUsXG4gICAgICAgIH0pO1xuICAgIH0sIFtwYW5uYWJsZSwgem9vbWFibGUsIGludmVyc2VQYW4sIHpvb21TdGVwLCB0cmFuc2xhdGVFeHRlbnQsIGZsb3dXaWR0aCwgZmxvd0hlaWdodF0pO1xuICAgIGNvbnN0IG9uU3ZnQ2xpY2sgPSBvbkNsaWNrXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBtaW5pbWFwSW5zdGFuY2UuY3VycmVudD8ucG9pbnRlcihldmVudCkgfHwgWzAsIDBdO1xuICAgICAgICAgICAgb25DbGljayhldmVudCwgeyB4LCB5IH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uU3ZnTm9kZUNsaWNrID0gb25Ob2RlQ2xpY2tcbiAgICAgICAgPyB1c2VDYWxsYmFjaygoZXZlbnQsIG5vZGVJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHN0b3JlLmdldFN0YXRlKCkubm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIG9uTm9kZUNsaWNrKGV2ZW50LCBub2RlKTtcbiAgICAgICAgfSwgW10pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiAoanN4KFBhbmVsLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgc3R5bGU6IHtcbiAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogdHlwZW9mIGJnQ29sb3IgPT09ICdzdHJpbmcnID8gYmdDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbWFzay1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogdHlwZW9mIG1hc2tDb2xvciA9PT0gJ3N0cmluZycgPyBtYXNrQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW1hc2stc3Ryb2tlLWNvbG9yLXByb3BzJzogdHlwZW9mIG1hc2tTdHJva2VDb2xvciA9PT0gJ3N0cmluZycgPyBtYXNrU3Ryb2tlQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW1hc2stc3Ryb2tlLXdpZHRoLXByb3BzJzogdHlwZW9mIG1hc2tTdHJva2VXaWR0aCA9PT0gJ251bWJlcicgPyBtYXNrU3Ryb2tlV2lkdGggKiB2aWV3U2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW5vZGUtYmFja2dyb3VuZC1jb2xvci1wcm9wcyc6IHR5cGVvZiBub2RlQ29sb3IgPT09ICdzdHJpbmcnID8gbm9kZUNvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1ub2RlLXN0cm9rZS1jb2xvci1wcm9wcyc6IHR5cGVvZiBub2RlU3Ryb2tlQ29sb3IgPT09ICdzdHJpbmcnID8gbm9kZVN0cm9rZUNvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1ub2RlLXN0cm9rZS13aWR0aC1wcm9wcyc6IHR5cGVvZiBub2RlU3Ryb2tlV2lkdGggPT09ICdzdHJpbmcnID8gbm9kZVN0cm9rZVdpZHRoIDogdW5kZWZpbmVkLFxuICAgICAgICB9LCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbWluaW1hcCcsIGNsYXNzTmFtZV0pLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX21pbmltYXBcIiwgY2hpbGRyZW46IGpzeHMoXCJzdmdcIiwgeyB3aWR0aDogZWxlbWVudFdpZHRoLCBoZWlnaHQ6IGVsZW1lbnRIZWlnaHQsIHZpZXdCb3g6IGAke3h9ICR7eX0gJHt3aWR0aH0gJHtoZWlnaHR9YCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX21pbmltYXAtc3ZnXCIsIHJvbGU6IFwiaW1nXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkQnksIHJlZjogc3ZnLCBvbkNsaWNrOiBvblN2Z0NsaWNrLCBjaGlsZHJlbjogW2FyaWFMYWJlbCAmJiBqc3goXCJ0aXRsZVwiLCB7IGlkOiBsYWJlbGxlZEJ5LCBjaGlsZHJlbjogYXJpYUxhYmVsIH0pLCBqc3goTWluaU1hcE5vZGVzJDEsIHsgb25DbGljazogb25TdmdOb2RlQ2xpY2ssIG5vZGVDb2xvcjogbm9kZUNvbG9yLCBub2RlU3Ryb2tlQ29sb3I6IG5vZGVTdHJva2VDb2xvciwgbm9kZUJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgbm9kZUNsYXNzTmFtZTogbm9kZUNsYXNzTmFtZSwgbm9kZVN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIG5vZGVDb21wb25lbnQ6IG5vZGVDb21wb25lbnQgfSksIGpzeChcInBhdGhcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbWluaW1hcC1tYXNrXCIsIGQ6IGBNJHt4IC0gb2Zmc2V0fSwke3kgLSBvZmZzZXR9aCR7d2lkdGggKyBvZmZzZXQgKiAyfXYke2hlaWdodCArIG9mZnNldCAqIDJ9aCR7LXdpZHRoIC0gb2Zmc2V0ICogMn16XG4gICAgICAgIE0ke3ZpZXdCQi54fSwke3ZpZXdCQi55fWgke3ZpZXdCQi53aWR0aH12JHt2aWV3QkIuaGVpZ2h0fWgkey12aWV3QkIud2lkdGh9emAsIGZpbGxSdWxlOiBcImV2ZW5vZGRcIiwgcG9pbnRlckV2ZW50czogXCJub25lXCIgfSldIH0pIH0pKTtcbn1cbk1pbmlNYXBDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnTWluaU1hcCc7XG5jb25zdCBNaW5pTWFwID0gbWVtbyhNaW5pTWFwQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gUmVzaXplQ29udHJvbCh7IG5vZGVJZCwgcG9zaXRpb24sIHZhcmlhbnQgPSBSZXNpemVDb250cm9sVmFyaWFudC5IYW5kbGUsIGNsYXNzTmFtZSwgc3R5bGUgPSB7fSwgY2hpbGRyZW4sIGNvbG9yLCBtaW5XaWR0aCA9IDEwLCBtaW5IZWlnaHQgPSAxMCwgbWF4V2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFLCBtYXhIZWlnaHQgPSBOdW1iZXIuTUFYX1ZBTFVFLCBrZWVwQXNwZWN0UmF0aW8gPSBmYWxzZSwgc2hvdWxkUmVzaXplLCBvblJlc2l6ZVN0YXJ0LCBvblJlc2l6ZSwgb25SZXNpemVFbmQsIH0pIHtcbiAgICBjb25zdCBjb250ZXh0Tm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgaWQgPSB0eXBlb2Ygbm9kZUlkID09PSAnc3RyaW5nJyA/IG5vZGVJZCA6IGNvbnRleHROb2RlSWQ7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHJlc2l6ZUNvbnRyb2xSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgZGVmYXVsdFBvc2l0aW9uID0gdmFyaWFudCA9PT0gUmVzaXplQ29udHJvbFZhcmlhbnQuTGluZSA/ICdyaWdodCcgOiAnYm90dG9tLXJpZ2h0JztcbiAgICBjb25zdCBjb250cm9sUG9zaXRpb24gPSBwb3NpdGlvbiA/PyBkZWZhdWx0UG9zaXRpb247XG4gICAgY29uc3QgcmVzaXplciA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXJlc2l6ZUNvbnRyb2xSZWYuY3VycmVudCB8fCAhaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc2l6ZXIuY3VycmVudCkge1xuICAgICAgICAgICAgcmVzaXplci5jdXJyZW50ID0gWFlSZXNpemVyKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiByZXNpemVDb250cm9sUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICBnZXRTdG9yZUl0ZW1zOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBUb0dyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZURvbU5vZGU6IGRvbU5vZGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogKGNoYW5nZSwgY2hpbGRDaGFuZ2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJpZ2dlck5vZGVDaGFuZ2VzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0geyB4OiBjaGFuZ2UueCwgeTogY2hhbmdlLnkgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5leHBhbmRQYXJlbnQgJiYgbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gY2hhbmdlLndpZHRoID8/IG5vZGUubWVhc3VyZWQud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBjaGFuZ2UuaGVpZ2h0ID8/IG5vZGUubWVhc3VyZWQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IG5vZGUucGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ldmFsdWF0ZUFic29sdXRlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2hhbmdlLnggPz8gbm9kZS5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hhbmdlLnkgPz8gbm9kZS5wb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7IHdpZHRoLCBoZWlnaHQgfSwgbm9kZS5wYXJlbnRJZCwgbm9kZUxvb2t1cCwgb3JpZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQoW2NoaWxkXSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHBhcmVudCB3YXMgZXhwYW5kZWQgYnkgdGhlIGNoaWxkIG5vZGUsIGl0cyBwb3NpdGlvbiB3aWxsIGJlIGNsYW1wZWQgYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAsMCB3aGVuIG5vZGUgb3JpZ2luIGlzIDAsMCBhbmQgdG8gd2lkdGgsIGhlaWdodCBpZiBpdCdzIDEsMVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLnggPSBjaGFuZ2UueCA/IE1hdGgubWF4KG9yaWdpblswXSAqIHdpZHRoLCBjaGFuZ2UueCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24ueSA9IGNoYW5nZS55ID8gTWF0aC5tYXgob3JpZ2luWzFdICogaGVpZ2h0LCBjaGFuZ2UueSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRQb3NpdGlvbi54ICE9PSB1bmRlZmluZWQgJiYgbmV4dFBvc2l0aW9uLnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyAuLi5uZXh0UG9zaXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2gocG9zaXRpb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uud2lkdGggIT09IHVuZGVmaW5lZCAmJiBjaGFuZ2UuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXppbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjaGFuZ2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2hhbmdlLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChkaW1lbnNpb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGRDaGFuZ2Ugb2YgY2hpbGRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChwb3NpdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25FbmQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXppbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLnRyaWdnZXJOb2RlQ2hhbmdlcyhbZGltZW5zaW9uQ2hhbmdlXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc2l6ZXIuY3VycmVudC51cGRhdGUoe1xuICAgICAgICAgICAgY29udHJvbFBvc2l0aW9uLFxuICAgICAgICAgICAgYm91bmRhcmllczoge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgICAgIG1pbkhlaWdodCxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2VlcEFzcGVjdFJhdGlvLFxuICAgICAgICAgICAgb25SZXNpemVTdGFydCxcbiAgICAgICAgICAgIG9uUmVzaXplLFxuICAgICAgICAgICAgb25SZXNpemVFbmQsXG4gICAgICAgICAgICBzaG91bGRSZXNpemUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplci5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjb250cm9sUG9zaXRpb24sXG4gICAgICAgIG1pbldpZHRoLFxuICAgICAgICBtaW5IZWlnaHQsXG4gICAgICAgIG1heFdpZHRoLFxuICAgICAgICBtYXhIZWlnaHQsXG4gICAgICAgIGtlZXBBc3BlY3RSYXRpbyxcbiAgICAgICAgb25SZXNpemVTdGFydCxcbiAgICAgICAgb25SZXNpemUsXG4gICAgICAgIG9uUmVzaXplRW5kLFxuICAgICAgICBzaG91bGRSZXNpemUsXG4gICAgXSk7XG4gICAgY29uc3QgcG9zaXRpb25DbGFzc05hbWVzID0gY29udHJvbFBvc2l0aW9uLnNwbGl0KCctJyk7XG4gICAgY29uc3QgY29sb3JTdHlsZVByb3AgPSB2YXJpYW50ID09PSBSZXNpemVDb250cm9sVmFyaWFudC5MaW5lID8gJ2JvcmRlckNvbG9yJyA6ICdiYWNrZ3JvdW5kQ29sb3InO1xuICAgIGNvbnN0IGNvbnRyb2xTdHlsZSA9IGNvbG9yID8geyAuLi5zdHlsZSwgW2NvbG9yU3R5bGVQcm9wXTogY29sb3IgfSA6IHN0eWxlO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX3Jlc2l6ZS1jb250cm9sJywgJ25vZHJhZycsIC4uLnBvc2l0aW9uQ2xhc3NOYW1lcywgdmFyaWFudCwgY2xhc3NOYW1lXSksIHJlZjogcmVzaXplQ29udHJvbFJlZiwgc3R5bGU6IGNvbnRyb2xTdHlsZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cbmNvbnN0IE5vZGVSZXNpemVDb250cm9sID0gbWVtbyhSZXNpemVDb250cm9sKTtcblxuZnVuY3Rpb24gTm9kZVJlc2l6ZXIoeyBub2RlSWQsIGlzVmlzaWJsZSA9IHRydWUsIGhhbmRsZUNsYXNzTmFtZSwgaGFuZGxlU3R5bGUsIGxpbmVDbGFzc05hbWUsIGxpbmVTdHlsZSwgY29sb3IsIG1pbldpZHRoID0gMTAsIG1pbkhlaWdodCA9IDEwLCBtYXhXaWR0aCA9IE51bWJlci5NQVhfVkFMVUUsIG1heEhlaWdodCA9IE51bWJlci5NQVhfVkFMVUUsIGtlZXBBc3BlY3RSYXRpbyA9IGZhbHNlLCBzaG91bGRSZXNpemUsIG9uUmVzaXplU3RhcnQsIG9uUmVzaXplLCBvblJlc2l6ZUVuZCwgfSkge1xuICAgIGlmICghaXNWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TLm1hcCgocG9zaXRpb24pID0+IChqc3goTm9kZVJlc2l6ZUNvbnRyb2wsIHsgY2xhc3NOYW1lOiBsaW5lQ2xhc3NOYW1lLCBzdHlsZTogbGluZVN0eWxlLCBub2RlSWQ6IG5vZGVJZCwgcG9zaXRpb246IHBvc2l0aW9uLCB2YXJpYW50OiBSZXNpemVDb250cm9sVmFyaWFudC5MaW5lLCBjb2xvcjogY29sb3IsIG1pbldpZHRoOiBtaW5XaWR0aCwgbWluSGVpZ2h0OiBtaW5IZWlnaHQsIG1heFdpZHRoOiBtYXhXaWR0aCwgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsIG9uUmVzaXplU3RhcnQ6IG9uUmVzaXplU3RhcnQsIGtlZXBBc3BlY3RSYXRpbzoga2VlcEFzcGVjdFJhdGlvLCBzaG91bGRSZXNpemU6IHNob3VsZFJlc2l6ZSwgb25SZXNpemU6IG9uUmVzaXplLCBvblJlc2l6ZUVuZDogb25SZXNpemVFbmQgfSwgcG9zaXRpb24pKSksIFhZX1JFU0laRVJfSEFORExFX1BPU0lUSU9OUy5tYXAoKHBvc2l0aW9uKSA9PiAoanN4KE5vZGVSZXNpemVDb250cm9sLCB7IGNsYXNzTmFtZTogaGFuZGxlQ2xhc3NOYW1lLCBzdHlsZTogaGFuZGxlU3R5bGUsIG5vZGVJZDogbm9kZUlkLCBwb3NpdGlvbjogcG9zaXRpb24sIGNvbG9yOiBjb2xvciwgbWluV2lkdGg6IG1pbldpZHRoLCBtaW5IZWlnaHQ6IG1pbkhlaWdodCwgbWF4V2lkdGg6IG1heFdpZHRoLCBtYXhIZWlnaHQ6IG1heEhlaWdodCwgb25SZXNpemVTdGFydDogb25SZXNpemVTdGFydCwga2VlcEFzcGVjdFJhdGlvOiBrZWVwQXNwZWN0UmF0aW8sIHNob3VsZFJlc2l6ZTogc2hvdWxkUmVzaXplLCBvblJlc2l6ZTogb25SZXNpemUsIG9uUmVzaXplRW5kOiBvblJlc2l6ZUVuZCB9LCBwb3NpdGlvbikpKV0gfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUuZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX3JlbmRlcmVyJyk7XG5mdW5jdGlvbiBOb2RlVG9vbGJhclBvcnRhbCh7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCB3cmFwcGVyUmVmID0gdXNlU3RvcmUoc2VsZWN0b3IpO1xuICAgIGlmICghd3JhcHBlclJlZikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgd3JhcHBlclJlZik7XG59XG5cbmNvbnN0IG5vZGVFcXVhbGl0eUZuID0gKGEsIGIpID0+IGE/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggIT09IGI/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggfHxcbiAgICBhPy5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55ICE9PSBiPy5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55IHx8XG4gICAgYT8ubWVhc3VyZWQud2lkdGggIT09IGI/Lm1lYXN1cmVkLndpZHRoIHx8XG4gICAgYT8ubWVhc3VyZWQuaGVpZ2h0ICE9PSBiPy5tZWFzdXJlZC5oZWlnaHQgfHxcbiAgICBhPy5zZWxlY3RlZCAhPT0gYj8uc2VsZWN0ZWQgfHxcbiAgICBhPy5pbnRlcm5hbHMueiAhPT0gYj8uaW50ZXJuYWxzLno7XG5jb25zdCBub2Rlc0VxdWFsaXR5Rm4gPSAoYSwgYikgPT4ge1xuICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgbm9kZV0gb2YgYSkge1xuICAgICAgICBpZiAobm9kZUVxdWFsaXR5Rm4obm9kZSwgYi5nZXQoa2V5KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBzdG9yZVNlbGVjdG9yID0gKHN0YXRlKSA9PiAoe1xuICAgIHg6IHN0YXRlLnRyYW5zZm9ybVswXSxcbiAgICB5OiBzdGF0ZS50cmFuc2Zvcm1bMV0sXG4gICAgem9vbTogc3RhdGUudHJhbnNmb3JtWzJdLFxuICAgIHNlbGVjdGVkTm9kZXNDb3VudDogc3RhdGUubm9kZXMuZmlsdGVyKChub2RlKSA9PiBub2RlLnNlbGVjdGVkKS5sZW5ndGgsXG59KTtcbmZ1bmN0aW9uIE5vZGVUb29sYmFyKHsgbm9kZUlkLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgaXNWaXNpYmxlLCBwb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgb2Zmc2V0ID0gMTAsIGFsaWduID0gJ2NlbnRlcicsIC4uLnJlc3QgfSkge1xuICAgIGNvbnN0IGNvbnRleHROb2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBub2Rlc1NlbGVjdG9yID0gdXNlQ2FsbGJhY2soKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGVJZHMgPSBBcnJheS5pc0FycmF5KG5vZGVJZCkgPyBub2RlSWQgOiBbbm9kZUlkIHx8IGNvbnRleHROb2RlSWQgfHwgJyddO1xuICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGVzID0gbm9kZUlkcy5yZWR1Y2UoKHJlcywgaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzdGF0ZS5ub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBuZXcgTWFwKCkpO1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxOb2RlcztcbiAgICB9LCBbbm9kZUlkLCBjb250ZXh0Tm9kZUlkXSk7XG4gICAgY29uc3Qgbm9kZXMgPSB1c2VTdG9yZShub2Rlc1NlbGVjdG9yLCBub2Rlc0VxdWFsaXR5Rm4pO1xuICAgIGNvbnN0IHsgeCwgeSwgem9vbSwgc2VsZWN0ZWROb2Rlc0NvdW50IH0gPSB1c2VTdG9yZShzdG9yZVNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICAvLyBpZiBpc1Zpc2libGUgaXMgbm90IHNldCwgd2Ugc2hvdyB0aGUgdG9vbGJhciBvbmx5IGlmIGl0cyBub2RlIGlzIHNlbGVjdGVkIGFuZCBubyBvdGhlciBub2RlIGlzIHNlbGVjdGVkXG4gICAgY29uc3QgaXNBY3RpdmUgPSB0eXBlb2YgaXNWaXNpYmxlID09PSAnYm9vbGVhbidcbiAgICAgICAgPyBpc1Zpc2libGVcbiAgICAgICAgOiBub2Rlcy5zaXplID09PSAxICYmIG5vZGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZS5zZWxlY3RlZCAmJiBzZWxlY3RlZE5vZGVzQ291bnQgPT09IDE7XG4gICAgaWYgKCFpc0FjdGl2ZSB8fCAhbm9kZXMuc2l6ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZVJlY3QgPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKG5vZGVzKTtcbiAgICBjb25zdCBub2Rlc0FycmF5ID0gQXJyYXkuZnJvbShub2Rlcy52YWx1ZXMoKSk7XG4gICAgY29uc3QgekluZGV4ID0gTWF0aC5tYXgoLi4ubm9kZXNBcnJheS5tYXAoKG5vZGUpID0+IG5vZGUuaW50ZXJuYWxzLnogKyAxKSk7XG4gICAgY29uc3Qgd3JhcHBlclN0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdHJhbnNmb3JtOiBnZXROb2RlVG9vbGJhclRyYW5zZm9ybShub2RlUmVjdCwgeyB4LCB5LCB6b29tIH0sIHBvc2l0aW9uLCBvZmZzZXQsIGFsaWduKSxcbiAgICAgICAgekluZGV4LFxuICAgICAgICAuLi5zdHlsZSxcbiAgICB9O1xuICAgIHJldHVybiAoanN4KE5vZGVUb29sYmFyUG9ydGFsLCB7IGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyBzdHlsZTogd3JhcHBlclN0eWxlLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbm9kZS10b29sYmFyJywgY2xhc3NOYW1lXSksIC4uLnJlc3QsIFwiZGF0YS1pZFwiOiBub2Rlc0FycmF5LnJlZHVjZSgoYWNjLCBub2RlKSA9PiBgJHthY2N9JHtub2RlLmlkfSBgLCAnJykudHJpbSgpLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkpO1xufVxuXG5leHBvcnQgeyBCYWNrZ3JvdW5kLCBCYWNrZ3JvdW5kVmFyaWFudCwgQmFzZUVkZ2UsIEJlemllckVkZ2UsIENvbnRyb2xCdXR0b24sIENvbnRyb2xzLCBFZGdlTGFiZWxSZW5kZXJlciwgRWRnZVRleHQsIEhhbmRsZSwgTWluaU1hcCwgTm9kZVJlc2l6ZUNvbnRyb2wsIE5vZGVSZXNpemVyLCBOb2RlVG9vbGJhciwgUGFuZWwsIGluZGV4IGFzIFJlYWN0RmxvdywgUmVhY3RGbG93UHJvdmlkZXIsIFNpbXBsZUJlemllckVkZ2UsIFNtb290aFN0ZXBFZGdlLCBTdGVwRWRnZSwgU3RyYWlnaHRFZGdlLCBWaWV3cG9ydFBvcnRhbCwgYXBwbHlFZGdlQ2hhbmdlcywgYXBwbHlOb2RlQ2hhbmdlcywgZ2V0U2ltcGxlQmV6aWVyUGF0aCwgaXNFZGdlLCBpc05vZGUsIHVzZUNvbm5lY3Rpb24sIHVzZUVkZ2VzLCB1c2VFZGdlc1N0YXRlLCB1c2VIYW5kbGVDb25uZWN0aW9ucywgdXNlSW50ZXJuYWxOb2RlLCB1c2VLZXlQcmVzcywgdXNlTm9kZUNvbm5lY3Rpb25zLCB1c2VOb2RlSWQsIHVzZU5vZGVzLCB1c2VOb2Rlc0RhdGEsIHVzZU5vZGVzSW5pdGlhbGl6ZWQsIHVzZU5vZGVzU3RhdGUsIHVzZU9uU2VsZWN0aW9uQ2hhbmdlLCB1c2VPblZpZXdwb3J0Q2hhbmdlLCB1c2VSZWFjdEZsb3csIHVzZVN0b3JlLCB1c2VTdG9yZUFwaSwgdXNlVXBkYXRlTm9kZUludGVybmFscywgdXNlVmlld3BvcnQgfTtcbiJdLCJuYW1lcyI6WyJqc3hzIiwiRnJhZ21lbnQiLCJqc3giLCJjYyIsImVycm9yTWVzc2FnZXMiLCJpbmZpbml0ZUV4dGVudCIsImlzSW5wdXRET01Ob2RlIiwiZ2V0Rml0Vmlld05vZGVzIiwiZ2V0RGltZW5zaW9ucyIsImZpdFZpZXciLCJnZXRWaWV3cG9ydEZvckJvdW5kcyIsInBvaW50VG9SZW5kZXJlclBvaW50IiwicmVuZGVyZXJQb2ludFRvUG9pbnQiLCJpc05vZGVCYXNlIiwiaXNFZGdlQmFzZSIsImdldEVsZW1lbnRzVG9SZW1vdmUiLCJpc1JlY3RPYmplY3QiLCJub2RlVG9SZWN0IiwiZ2V0T3ZlcmxhcHBpbmdBcmVhIiwiZ2V0Tm9kZXNCb3VuZHMiLCJldmFsdWF0ZUFic29sdXRlUG9zaXRpb24iLCJYWVBhblpvb20iLCJQYW5PblNjcm9sbE1vZGUiLCJTZWxlY3Rpb25Nb2RlIiwiZ2V0RXZlbnRQb3NpdGlvbiIsImdldE5vZGVzSW5zaWRlIiwiYXJlU2V0c0VxdWFsIiwiWFlEcmFnIiwic25hcFBvc2l0aW9uIiwiY2FsY3VsYXRlTm9kZVBvc2l0aW9uIiwiUG9zaXRpb24iLCJDb25uZWN0aW9uTW9kZSIsImlzTW91c2VFdmVudCIsIlhZSGFuZGxlIiwiZ2V0SG9zdEZvckVsZW1lbnQiLCJhZGRFZGdlIiwiZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyIsImlzTnVtZXJpYyIsIm5vZGVIYXNEaW1lbnNpb25zIiwiZ2V0Tm9kZURpbWVuc2lvbnMiLCJlbGVtZW50U2VsZWN0aW9uS2V5cyIsImlzRWRnZVZpc2libGUiLCJNYXJrZXJUeXBlIiwiY3JlYXRlTWFya2VySWRzIiwiZ2V0QmV6aWVyRWRnZUNlbnRlciIsImdldFNtb290aFN0ZXBQYXRoIiwiZ2V0U3RyYWlnaHRQYXRoIiwiZ2V0QmV6aWVyUGF0aCIsImdldEVkZ2VQb3NpdGlvbiIsImdldEVsZXZhdGVkRWRnZVpJbmRleCIsImdldE1hcmtlcklkIiwiZ2V0Q29ubmVjdGlvblN0YXR1cyIsIkNvbm5lY3Rpb25MaW5lVHlwZSIsInVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAiLCJhZG9wdFVzZXJOb2RlcyIsImluaXRpYWxDb25uZWN0aW9uIiwiZGV2V2FybiIsInVwZGF0ZU5vZGVJbnRlcm5hbHMiLCJ1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucyIsImhhbmRsZUV4cGFuZFBhcmVudCIsInBhbkJ5IiwiaXNNYWNPcyIsImFyZUNvbm5lY3Rpb25NYXBzRXF1YWwiLCJoYW5kbGVDb25uZWN0aW9uQ2hhbmdlIiwic2hhbGxvd05vZGVEYXRhIiwiWFlNaW5pbWFwIiwiZ2V0Qm91bmRzT2ZSZWN0cyIsIlJlc2l6ZUNvbnRyb2xWYXJpYW50IiwiWFlSZXNpemVyIiwiWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUyIsIlhZX1JFU0laRVJfSEFORExFX1BPU0lUSU9OUyIsImdldE5vZGVUb29sYmFyVHJhbnNmb3JtIiwiZ2V0Q29ubmVjdGVkRWRnZXMiLCJnZXRFZGdlQ2VudGVyIiwiZ2V0SW5jb21lcnMiLCJnZXRPdXRnb2VycyIsInJlY29ubmVjdEVkZ2UiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZU1lbW8iLCJmb3J3YXJkUmVmIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIm1lbW8iLCJ1c2VTdG9yZVdpdGhFcXVhbGl0eUZuIiwiY3JlYXRlV2l0aEVxdWFsaXR5Rm4iLCJzaGFsbG93IiwiY3JlYXRlUG9ydGFsIiwiU3RvcmVDb250ZXh0IiwiUHJvdmlkZXIkMSIsIlByb3ZpZGVyIiwienVzdGFuZEVycm9yTWVzc2FnZSIsInVzZVN0b3JlIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwic3RvcmUiLCJFcnJvciIsInVzZVN0b3JlQXBpIiwiZ2V0U3RhdGUiLCJzZXRTdGF0ZSIsInN1YnNjcmliZSIsInN0eWxlIiwiZGlzcGxheSIsImFyaWFMaXZlU3R5bGUiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwibWFyZ2luIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiY2xpcCIsImNsaXBQYXRoIiwiQVJJQV9OT0RFX0RFU0NfS0VZIiwiQVJJQV9FREdFX0RFU0NfS0VZIiwiQVJJQV9MSVZFX01FU1NBR0UiLCJzZWxlY3RvciRvIiwicyIsImFyaWFMaXZlTWVzc2FnZSIsIkFyaWFMaXZlTWVzc2FnZSIsInJmSWQiLCJpZCIsImNoaWxkcmVuIiwiQTExeURlc2NyaXB0aW9ucyIsImRpc2FibGVLZXlib2FyZEExMXkiLCJzZWxlY3RvciRuIiwidXNlclNlbGVjdGlvbkFjdGl2ZSIsIlBhbmVsIiwiY2xhc3NOYW1lIiwicmVzdCIsInJlZiIsInBvaW50ZXJFdmVudHMiLCJwb3NpdGlvbkNsYXNzZXMiLCJzcGxpdCIsIkF0dHJpYnV0aW9uIiwicHJvT3B0aW9ucyIsImhpZGVBdHRyaWJ1dGlvbiIsImhyZWYiLCJ0YXJnZXQiLCJyZWwiLCJzZWxlY3RvciRtIiwic2VsZWN0ZWROb2RlcyIsInNlbGVjdGVkRWRnZXMiLCJub2RlIiwibm9kZUxvb2t1cCIsInNlbGVjdGVkIiwicHVzaCIsImludGVybmFscyIsInVzZXJOb2RlIiwiZWRnZSIsImVkZ2VMb29rdXAiLCJzZWxlY3RJZCIsIm9iaiIsImFyZUVxdWFsIiwiYSIsImIiLCJtYXAiLCJTZWxlY3Rpb25MaXN0ZW5lcklubmVyIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJwYXJhbXMiLCJub2RlcyIsImVkZ2VzIiwib25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyIsImZvckVhY2giLCJmbiIsImNoYW5nZVNlbGVjdG9yIiwiU2VsZWN0aW9uTGlzdGVuZXIiLCJzdG9yZUhhc1NlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIiwiZGVmYXVsdE5vZGVPcmlnaW4iLCJkZWZhdWx0Vmlld3BvcnQiLCJ4IiwieSIsInpvb20iLCJyZWFjdEZsb3dGaWVsZHNUb1RyYWNrIiwiZmllbGRzVG9UcmFjayIsInNlbGVjdG9yJGwiLCJzZXROb2RlcyIsInNldEVkZ2VzIiwic2V0TWluWm9vbSIsInNldE1heFpvb20iLCJzZXRUcmFuc2xhdGVFeHRlbnQiLCJzZXROb2RlRXh0ZW50IiwicmVzZXQiLCJzZXREZWZhdWx0Tm9kZXNBbmRFZGdlcyIsInNldFBhbmVDbGlja0Rpc3RhbmNlIiwiaW5pdFByZXZWYWx1ZXMiLCJ0cmFuc2xhdGVFeHRlbnQiLCJub2RlT3JpZ2luIiwibWluWm9vbSIsIm1heFpvb20iLCJlbGVtZW50c1NlbGVjdGFibGUiLCJub1BhbkNsYXNzTmFtZSIsInBhbmVDbGlja0Rpc3RhbmNlIiwiU3RvcmVVcGRhdGVyIiwicHJvcHMiLCJkZWZhdWx0Tm9kZXMiLCJkZWZhdWx0RWRnZXMiLCJwcmV2aW91c0ZpZWxkcyIsImN1cnJlbnQiLCJmaWVsZE5hbWUiLCJmaWVsZFZhbHVlIiwicHJldmlvdXNGaWVsZFZhbHVlIiwiZml0Vmlld09uSW5pdCIsImZpdFZpZXdPbkluaXRPcHRpb25zIiwiZ2V0TWVkaWFRdWVyeSIsIndpbmRvdyIsIm1hdGNoTWVkaWEiLCJ1c2VDb2xvck1vZGVDbGFzcyIsImNvbG9yTW9kZSIsImNvbG9yTW9kZUNsYXNzIiwic2V0Q29sb3JNb2RlQ2xhc3MiLCJtZWRpYVF1ZXJ5IiwidXBkYXRlQ29sb3JNb2RlQ2xhc3MiLCJtYXRjaGVzIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZWZhdWx0RG9jIiwiZG9jdW1lbnQiLCJ1c2VLZXlQcmVzcyIsImtleUNvZGUiLCJvcHRpb25zIiwiYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXIiLCJrZXlQcmVzc2VkIiwic2V0S2V5UHJlc3NlZCIsIm1vZGlmaWVyUHJlc3NlZCIsInByZXNzZWRLZXlzIiwiU2V0Iiwia2V5Q29kZXMiLCJrZXlzVG9XYXRjaCIsImtleUNvZGVBcnIiLCJBcnJheSIsImlzQXJyYXkiLCJrZXlzIiwiZmlsdGVyIiwia2MiLCJyZXBsYWNlIiwia2V5c0ZsYXQiLCJyZWR1Y2UiLCJyZXMiLCJpdGVtIiwiY29uY2F0IiwiZG93bkhhbmRsZXIiLCJldmVudCIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJwcmV2ZW50QWN0aW9uIiwia2V5T3JDb2RlIiwidXNlS2V5T3JDb2RlIiwiY29kZSIsImFkZCIsImlzTWF0Y2hpbmdLZXkiLCJwcmV2ZW50RGVmYXVsdCIsInVwSGFuZGxlciIsImNsZWFyIiwiZGVsZXRlIiwia2V5IiwicmVzZXRIYW5kbGVyIiwiaXNVcCIsImxlbmd0aCIsInNpemUiLCJzb21lIiwiZXZlcnkiLCJrIiwiaGFzIiwiZXZlbnRDb2RlIiwiaW5jbHVkZXMiLCJ1c2VWaWV3cG9ydEhlbHBlciIsInpvb21JbiIsInBhblpvb20iLCJzY2FsZUJ5IiwiZHVyYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInpvb21PdXQiLCJ6b29tVG8iLCJ6b29tTGV2ZWwiLCJzY2FsZVRvIiwiZ2V0Wm9vbSIsInRyYW5zZm9ybSIsInNldFZpZXdwb3J0Iiwidmlld3BvcnQiLCJ0WCIsInRZIiwidFpvb20iLCJnZXRWaWV3cG9ydCIsImRvbU5vZGUiLCJmaXRWaWV3Tm9kZXMiLCJzZXRDZW50ZXIiLCJuZXh0Wm9vbSIsImNlbnRlclgiLCJjZW50ZXJZIiwiZml0Qm91bmRzIiwiYm91bmRzIiwic2NyZWVuVG9GbG93UG9zaXRpb24iLCJjbGllbnRQb3NpdGlvbiIsInNuYXBUb0dyaWQiLCJzbmFwR3JpZCIsImRvbVgiLCJkb21ZIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY29ycmVjdGVkUG9zaXRpb24iLCJmbG93VG9TY3JlZW5Qb3NpdGlvbiIsImZsb3dQb3NpdGlvbiIsInJlbmRlcmVyUG9zaXRpb24iLCJhcHBseUNoYW5nZXMiLCJjaGFuZ2VzIiwiZWxlbWVudHMiLCJ1cGRhdGVkRWxlbWVudHMiLCJjaGFuZ2VzTWFwIiwiTWFwIiwiYWRkSXRlbUNoYW5nZXMiLCJjaGFuZ2UiLCJ0eXBlIiwic2V0IiwiZWxlbWVudENoYW5nZXMiLCJnZXQiLCJlbGVtZW50IiwidXBkYXRlZEVsZW1lbnQiLCJhcHBseUNoYW5nZSIsImluZGV4IiwidW5kZWZpbmVkIiwic3BsaWNlIiwiZHJhZ2dpbmciLCJkaW1lbnNpb25zIiwibWVhc3VyZWQiLCJzZXRBdHRyaWJ1dGVzIiwicmVzaXppbmciLCJhcHBseU5vZGVDaGFuZ2VzIiwiYXBwbHlFZGdlQ2hhbmdlcyIsImNyZWF0ZVNlbGVjdGlvbkNoYW5nZSIsImdldFNlbGVjdGlvbkNoYW5nZXMiLCJpdGVtcyIsInNlbGVjdGVkSWRzIiwibXV0YXRlSXRlbSIsIndpbGxCZVNlbGVjdGVkIiwiZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyIsImxvb2t1cCIsIml0ZW1zTG9va3VwIiwiZW50cmllcyIsImxvb2t1cEl0ZW0iLCJzdG9yZUl0ZW0iLCJuZXh0Tm9kZSIsImVsZW1lbnRUb1JlbW92ZUNoYW5nZSIsImlzTm9kZSIsImlzRWRnZSIsImZpeGVkRm9yd2FyZFJlZiIsInJlbmRlciIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ1c2VRdWV1ZSIsInJ1blF1ZXVlIiwic2VyaWFsIiwic2V0U2VyaWFsIiwiQmlnSW50IiwicXVldWUiLCJjcmVhdGVRdWV1ZSIsIm4iLCJxdWV1ZUl0ZW1zIiwiY2IiLCJCYXRjaENvbnRleHQiLCJCYXRjaFByb3ZpZGVyIiwibm9kZVF1ZXVlSGFuZGxlciIsImhhc0RlZmF1bHROb2RlcyIsIm9uTm9kZXNDaGFuZ2UiLCJuZXh0IiwicGF5bG9hZCIsIm5vZGVRdWV1ZSIsImVkZ2VRdWV1ZUhhbmRsZXIiLCJoYXNEZWZhdWx0RWRnZXMiLCJvbkVkZ2VzQ2hhbmdlIiwiZWRnZVF1ZXVlIiwidmFsdWUiLCJ1c2VCYXRjaENvbnRleHQiLCJiYXRjaENvbnRleHQiLCJzZWxlY3RvciRrIiwidXNlUmVhY3RGbG93Iiwidmlld3BvcnRIZWxwZXIiLCJ2aWV3cG9ydEluaXRpYWxpemVkIiwiZ2VuZXJhbEhlbHBlciIsImdldEludGVybmFsTm9kZSIsImdldE5vZGVSZWN0Iiwibm9kZVRvVXNlIiwicGFyZW50SWQiLCJub2RlV2l0aFBvc2l0aW9uIiwidXBkYXRlTm9kZSIsIm5vZGVVcGRhdGUiLCJwcmV2Tm9kZXMiLCJ1cGRhdGVFZGdlIiwiZWRnZVVwZGF0ZSIsInByZXZFZGdlcyIsIm5leHRFZGdlIiwiZ2V0Tm9kZXMiLCJnZXROb2RlIiwiZ2V0RWRnZXMiLCJlIiwiZ2V0RWRnZSIsImFkZE5vZGVzIiwibmV3Tm9kZXMiLCJhZGRFZGdlcyIsIm5ld0VkZ2VzIiwidG9PYmplY3QiLCJkZWxldGVFbGVtZW50cyIsIm5vZGVzVG9SZW1vdmUiLCJlZGdlc1RvUmVtb3ZlIiwib25Ob2Rlc0RlbGV0ZSIsIm9uRWRnZXNEZWxldGUiLCJ0cmlnZ2VyTm9kZUNoYW5nZXMiLCJ0cmlnZ2VyRWRnZUNoYW5nZXMiLCJvbkRlbGV0ZSIsIm9uQmVmb3JlRGVsZXRlIiwibWF0Y2hpbmdOb2RlcyIsIm1hdGNoaW5nRWRnZXMiLCJoYXNNYXRjaGluZ0VkZ2VzIiwiaGFzTWF0Y2hpbmdOb2RlcyIsImVkZ2VDaGFuZ2VzIiwibm9kZUNoYW5nZXMiLCJkZWxldGVkTm9kZXMiLCJkZWxldGVkRWRnZXMiLCJnZXRJbnRlcnNlY3RpbmdOb2RlcyIsIm5vZGVPclJlY3QiLCJwYXJ0aWFsbHkiLCJpc1JlY3QiLCJub2RlUmVjdCIsImhhc05vZGVzT3B0aW9uIiwiaW50ZXJuYWxOb2RlIiwicG9zaXRpb25BYnNvbHV0ZSIsImN1cnJOb2RlUmVjdCIsIm92ZXJsYXBwaW5nQXJlYSIsInBhcnRpYWxseVZpc2libGUiLCJpc05vZGVJbnRlcnNlY3RpbmciLCJhcmVhIiwidXBkYXRlTm9kZURhdGEiLCJkYXRhVXBkYXRlIiwibmV4dERhdGEiLCJkYXRhIiwidXBkYXRlRWRnZURhdGEiLCJnZXRIYW5kbGVDb25uZWN0aW9ucyIsIm5vZGVJZCIsImZyb20iLCJjb25uZWN0aW9uTG9va3VwIiwidmFsdWVzIiwiZ2V0Tm9kZUNvbm5lY3Rpb25zIiwiaGFuZGxlSWQiLCJkZWxldGVLZXlPcHRpb25zIiwid2luJDEiLCJ1c2VHbG9iYWxLZXlIYW5kbGVyIiwiZGVsZXRlS2V5Q29kZSIsIm11bHRpU2VsZWN0aW9uS2V5Q29kZSIsImRlbGV0ZUtleVByZXNzZWQiLCJtdWx0aVNlbGVjdGlvbktleVByZXNzZWQiLCJub2Rlc1NlbGVjdGlvbkFjdGl2ZSIsIm11bHRpU2VsZWN0aW9uQWN0aXZlIiwidXNlUmVzaXplSGFuZGxlciIsInVwZGF0ZURpbWVuc2lvbnMiLCJvbkVycm9yIiwicmVzaXplT2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJjb250YWluZXJTdHlsZSIsInRvcCIsImxlZnQiLCJzZWxlY3RvciRqIiwibGliIiwiWm9vbVBhbmUiLCJvblBhbmVDb250ZXh0TWVudSIsInpvb21PblNjcm9sbCIsInpvb21PblBpbmNoIiwicGFuT25TY3JvbGwiLCJwYW5PblNjcm9sbFNwZWVkIiwicGFuT25TY3JvbGxNb2RlIiwiRnJlZSIsInpvb21PbkRvdWJsZUNsaWNrIiwicGFuT25EcmFnIiwiem9vbUFjdGl2YXRpb25LZXlDb2RlIiwicHJldmVudFNjcm9sbGluZyIsIm5vV2hlZWxDbGFzc05hbWUiLCJvblZpZXdwb3J0Q2hhbmdlIiwiaXNDb250cm9sbGVkVmlld3BvcnQiLCJ6b29tUGFuZSIsInpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCIsIm9uVHJhbnNmb3JtQ2hhbmdlIiwib25EcmFnZ2luZ0NoYW5nZSIsInBhbmVEcmFnZ2luZyIsIm9uUGFuWm9vbVN0YXJ0IiwidnAiLCJvblZpZXdwb3J0Q2hhbmdlU3RhcnQiLCJvbk1vdmVTdGFydCIsIm9uUGFuWm9vbSIsIm9uTW92ZSIsIm9uUGFuWm9vbUVuZCIsIm9uVmlld3BvcnRDaGFuZ2VFbmQiLCJvbk1vdmVFbmQiLCJjbG9zZXN0IiwiZGVzdHJveSIsInVwZGF0ZSIsInNlbGVjdG9yJGkiLCJ1c2VyU2VsZWN0aW9uUmVjdCIsIlVzZXJTZWxlY3Rpb24iLCJpc0FjdGl2ZSIsIndyYXBIYW5kbGVyIiwiaGFuZGxlciIsImNvbnRhaW5lclJlZiIsInNlbGVjdG9yJGgiLCJQYW5lIiwiaXNTZWxlY3RpbmciLCJzZWxlY3Rpb25LZXlQcmVzc2VkIiwic2VsZWN0aW9uTW9kZSIsIkZ1bGwiLCJzZWxlY3Rpb25PbkRyYWciLCJvblNlbGVjdGlvblN0YXJ0Iiwib25TZWxlY3Rpb25FbmQiLCJvblBhbmVDbGljayIsIm9uUGFuZVNjcm9sbCIsIm9uUGFuZU1vdXNlRW50ZXIiLCJvblBhbmVNb3VzZU1vdmUiLCJvblBhbmVNb3VzZUxlYXZlIiwiaGFzQWN0aXZlU2VsZWN0aW9uIiwiY29udGFpbmVyIiwiY29udGFpbmVyQm91bmRzIiwic2VsZWN0ZWROb2RlSWRzIiwic2VsZWN0ZWRFZGdlSWRzIiwic2VsZWN0aW9uSW5Qcm9ncmVzcyIsInNlbGVjdGlvblN0YXJ0ZWQiLCJvbkNsaWNrIiwicmVzZXRTZWxlY3RlZEVsZW1lbnRzIiwib25Db250ZXh0TWVudSIsIm9uV2hlZWwiLCJvblBvaW50ZXJEb3duIiwiYnV0dG9uIiwic2V0UG9pbnRlckNhcHR1cmUiLCJwb2ludGVySWQiLCJuYXRpdmVFdmVudCIsInN0YXJ0WCIsInN0YXJ0WSIsIm9uUG9pbnRlck1vdmUiLCJkZWZhdWx0RWRnZU9wdGlvbnMiLCJtb3VzZVgiLCJtb3VzZVkiLCJuZXh0VXNlclNlbGVjdFJlY3QiLCJNYXRoIiwiYWJzIiwicHJldlNlbGVjdGVkTm9kZUlkcyIsInByZXZTZWxlY3RlZEVkZ2VJZHMiLCJQYXJ0aWFsIiwiZWRnZXNTZWxlY3RhYmxlIiwic2VsZWN0YWJsZSIsImNvbm5lY3Rpb25zIiwiZWRnZUlkIiwib25Qb2ludGVyVXAiLCJyZWxlYXNlUG9pbnRlckNhcHR1cmUiLCJkcmFnZ2FibGUiLCJzZWxlY3Rpb24iLCJvblBvaW50ZXJFbnRlciIsIm9uUG9pbnRlckxlYXZlIiwiaGFuZGxlTm9kZUNsaWNrIiwidW5zZWxlY3QiLCJub2RlUmVmIiwiYWRkU2VsZWN0ZWROb2RlcyIsInVuc2VsZWN0Tm9kZXNBbmRFZGdlcyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImJsdXIiLCJ1c2VEcmFnIiwiZGlzYWJsZWQiLCJub0RyYWdDbGFzc05hbWUiLCJoYW5kbGVTZWxlY3RvciIsImlzU2VsZWN0YWJsZSIsIm5vZGVDbGlja0Rpc3RhbmNlIiwic2V0RHJhZ2dpbmciLCJ4eURyYWciLCJnZXRTdG9yZUl0ZW1zIiwib25Ob2RlTW91c2VEb3duIiwib25EcmFnU3RhcnQiLCJvbkRyYWdTdG9wIiwic2VsZWN0ZWRBbmREcmFnZ2FibGUiLCJub2Rlc0RyYWdnYWJsZSIsInVzZU1vdmVTZWxlY3RlZE5vZGVzIiwibW92ZVNlbGVjdGVkTm9kZXMiLCJub2RlRXh0ZW50IiwidXBkYXRlTm9kZVBvc2l0aW9ucyIsIm5vZGVVcGRhdGVzIiwiaXNTZWxlY3RlZCIsInhWZWxvIiwieVZlbG8iLCJ4RGlmZiIsImRpcmVjdGlvbiIsImZhY3RvciIsInlEaWZmIiwibmV4dFBvc2l0aW9uIiwiTm9kZUlkQ29udGV4dCIsIkNvbnN1bWVyIiwidXNlTm9kZUlkIiwic2VsZWN0b3IkZyIsImNvbm5lY3RPbkNsaWNrIiwiY29ubmVjdGluZ1NlbGVjdG9yIiwic3RhdGUiLCJjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSIsImNsaWNrSGFuZGxlIiwiY29ubmVjdGlvbk1vZGUiLCJjb25uZWN0aW9uIiwiZnJvbUhhbmRsZSIsInRvSGFuZGxlIiwiaXNWYWxpZCIsImNvbm5lY3RpbmdUbyIsImNvbm5lY3RpbmdGcm9tIiwiY2xpY2tDb25uZWN0aW5nIiwiaXNQb3NzaWJsZUVuZEhhbmRsZSIsIlN0cmljdCIsImNvbm5lY3Rpb25JblByb2Nlc3MiLCJ2YWxpZCIsIkhhbmRsZUNvbXBvbmVudCIsIlRvcCIsImlzVmFsaWRDb25uZWN0aW9uIiwiaXNDb25uZWN0YWJsZSIsImlzQ29ubmVjdGFibGVTdGFydCIsImlzQ29ubmVjdGFibGVFbmQiLCJvbkNvbm5lY3QiLCJvbk1vdXNlRG93biIsIm9uVG91Y2hTdGFydCIsImlzVGFyZ2V0Iiwib25Db25uZWN0RXh0ZW5kZWQiLCJvbkNvbm5lY3RBY3Rpb24iLCJlZGdlUGFyYW1zIiwiaXNNb3VzZVRyaWdnZXJlZCIsImN1cnJlbnRTdG9yZSIsImF1dG9QYW5PbkNvbm5lY3QiLCJjb25uZWN0aW9uUmFkaXVzIiwiZmxvd0lkIiwiY2FuY2VsQ29ubmVjdGlvbiIsIm9uQ29ubmVjdFN0YXJ0Iiwib25Db25uZWN0RW5kIiwidXBkYXRlQ29ubmVjdGlvbiIsImdldFRyYW5zZm9ybSIsImdldEZyb21IYW5kbGUiLCJhdXRvUGFuU3BlZWQiLCJvbkNsaWNrQ29ubmVjdFN0YXJ0Iiwib25DbGlja0Nvbm5lY3RFbmQiLCJpc1ZhbGlkQ29ubmVjdGlvblN0b3JlIiwiY29ubmVjdGlvblN0YXRlIiwiaGFuZGxlVHlwZSIsImRvYyIsImlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciIsImhhbmRsZSIsImZyb21Ob2RlSWQiLCJmcm9tSGFuZGxlSWQiLCJmcm9tVHlwZSIsImNvbm5lY3Rpb25DbG9uZSIsInN0cnVjdHVyZWRDbG9uZSIsImluUHJvZ3Jlc3MiLCJ0b1Bvc2l0aW9uIiwic291cmNlIiwiY29ubmVjdGFibGUiLCJjb25uZWN0YWJsZXN0YXJ0IiwiY29ubmVjdGFibGVlbmQiLCJjbGlja2Nvbm5lY3RpbmciLCJjb25uZWN0aW5nZnJvbSIsImNvbm5lY3Rpbmd0byIsImNvbm5lY3Rpb25pbmRpY2F0b3IiLCJIYW5kbGUiLCJJbnB1dE5vZGUiLCJzb3VyY2VQb3NpdGlvbiIsIkJvdHRvbSIsImxhYmVsIiwiRGVmYXVsdE5vZGUiLCJ0YXJnZXRQb3NpdGlvbiIsIkdyb3VwTm9kZSIsIk91dHB1dE5vZGUiLCJhcnJvd0tleURpZmZzIiwiQXJyb3dVcCIsIkFycm93RG93biIsIkFycm93TGVmdCIsIkFycm93UmlnaHQiLCJidWlsdGluTm9kZVR5cGVzIiwiaW5wdXQiLCJkZWZhdWx0Iiwib3V0cHV0IiwiZ3JvdXAiLCJnZXROb2RlSW5saW5lU3R5bGVEaW1lbnNpb25zIiwiaGFuZGxlQm91bmRzIiwiaW5pdGlhbFdpZHRoIiwiaW5pdGlhbEhlaWdodCIsInNlbGVjdG9yJGYiLCJ0cmFuc2Zvcm1TdHJpbmciLCJOb2Rlc1NlbGVjdGlvbiIsIm9uU2VsZWN0aW9uQ29udGV4dE1lbnUiLCJmb2N1cyIsInByZXZlbnRTY3JvbGwiLCJvbktleURvd24iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ0YWJJbmRleCIsIndpbiIsInNlbGVjdG9yJGUiLCJGbG93UmVuZGVyZXJDb21wb25lbnQiLCJzZWxlY3Rpb25LZXlDb2RlIiwicGFuQWN0aXZhdGlvbktleUNvZGUiLCJfcGFuT25TY3JvbGwiLCJfcGFuT25EcmFnIiwicGFuQWN0aXZhdGlvbktleVByZXNzZWQiLCJfc2VsZWN0aW9uT25EcmFnIiwiZGlzcGxheU5hbWUiLCJGbG93UmVuZGVyZXIiLCJzZWxlY3RvciRkIiwib25seVJlbmRlclZpc2libGUiLCJ1c2VWaXNpYmxlTm9kZUlkcyIsIm5vZGVJZHMiLCJzZWxlY3RvciRjIiwidXNlUmVzaXplT2JzZXJ2ZXIiLCJ1cGRhdGVzIiwiZW50cnkiLCJnZXRBdHRyaWJ1dGUiLCJub2RlRWxlbWVudCIsImZvcmNlIiwiZGlzY29ubmVjdCIsInVzZU5vZGVPYnNlcnZlciIsIm5vZGVUeXBlIiwiaGFzRGltZW5zaW9ucyIsIm9ic2VydmVkTm9kZSIsInByZXZTb3VyY2VQb3NpdGlvbiIsInByZXZUYXJnZXRQb3NpdGlvbiIsInByZXZUeXBlIiwiaXNJbml0aWFsaXplZCIsImhpZGRlbiIsInR5cGVDaGFuZ2VkIiwic291cmNlUG9zQ2hhbmdlZCIsInRhcmdldFBvc0NoYW5nZWQiLCJOb2RlV3JhcHBlciIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZUxlYXZlIiwib25Eb3VibGVDbGljayIsIm5vZGVzQ29ubmVjdGFibGUiLCJub2Rlc0ZvY3VzYWJsZSIsIm5vZGVUeXBlcyIsImlzUGFyZW50IiwicGFyZW50TG9va3VwIiwiTm9kZUNvbXBvbmVudCIsImlzRHJhZ2dhYmxlIiwiaXNGb2N1c2FibGUiLCJmb2N1c2FibGUiLCJkcmFnSGFuZGxlIiwibm9kZURpbWVuc2lvbnMiLCJpbmxpbmVEaW1lbnNpb25zIiwiaGFzUG9pbnRlckV2ZW50cyIsIm9uTW91c2VFbnRlckhhbmRsZXIiLCJvbk1vdXNlTW92ZUhhbmRsZXIiLCJvbk1vdXNlTGVhdmVIYW5kbGVyIiwib25Db250ZXh0TWVudUhhbmRsZXIiLCJvbkRvdWJsZUNsaWNrSGFuZGxlciIsIm9uU2VsZWN0Tm9kZUhhbmRsZXIiLCJzZWxlY3ROb2Rlc09uRHJhZyIsIm5vZGVEcmFnVGhyZXNob2xkIiwidG9Mb3dlckNhc2UiLCJwYXJlbnQiLCJ6SW5kZXgiLCJ6IiwidmlzaWJpbGl0eSIsInJvbGUiLCJhcmlhTGFiZWwiLCJwb3NpdGlvbkFic29sdXRlWCIsInBvc2l0aW9uQWJzb2x1dGVZIiwiZGVsZXRhYmxlIiwic2VsZWN0b3IkYiIsIk5vZGVSZW5kZXJlckNvbXBvbmVudCIsIm9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMiLCJvbk5vZGVDbGljayIsIm9uTm9kZU1vdXNlRW50ZXIiLCJvbk5vZGVNb3VzZU1vdmUiLCJvbk5vZGVNb3VzZUxlYXZlIiwib25Ob2RlQ29udGV4dE1lbnUiLCJvbk5vZGVEb3VibGVDbGljayIsIk5vZGVSZW5kZXJlciIsInVzZVZpc2libGVFZGdlSWRzIiwiZWRnZUlkcyIsInZpc2libGVFZGdlSWRzIiwic291cmNlTm9kZSIsInRhcmdldE5vZGUiLCJBcnJvd1N5bWJvbCIsImNvbG9yIiwic3Ryb2tlV2lkdGgiLCJzdHJva2UiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJmaWxsIiwicG9pbnRzIiwiQXJyb3dDbG9zZWRTeW1ib2wiLCJNYXJrZXJTeW1ib2xzIiwiQXJyb3ciLCJBcnJvd0Nsb3NlZCIsInVzZU1hcmtlclN5bWJvbCIsInN5bWJvbCIsInN5bWJvbEV4aXN0cyIsIk1hcmtlciIsIm1hcmtlclVuaXRzIiwib3JpZW50IiwiU3ltYm9sIiwibWFya2VyV2lkdGgiLCJtYXJrZXJIZWlnaHQiLCJ2aWV3Qm94IiwicmVmWCIsInJlZlkiLCJNYXJrZXJEZWZpbml0aW9ucyIsImRlZmF1bHRDb2xvciIsIm1hcmtlcnMiLCJkZWZhdWx0TWFya2VyU3RhcnQiLCJtYXJrZXJTdGFydCIsImRlZmF1bHRNYXJrZXJFbmQiLCJtYXJrZXJFbmQiLCJtYXJrZXIiLCJNYXJrZXJEZWZpbml0aW9ucyQxIiwiRWRnZVRleHRDb21wb25lbnQiLCJsYWJlbFN0eWxlIiwibGFiZWxTaG93QmciLCJsYWJlbEJnU3R5bGUiLCJsYWJlbEJnUGFkZGluZyIsImxhYmVsQmdCb3JkZXJSYWRpdXMiLCJlZGdlVGV4dEJib3giLCJzZXRFZGdlVGV4dEJib3giLCJlZGdlVGV4dENsYXNzZXMiLCJlZGdlVGV4dFJlZiIsInRleHRCYm94IiwiZ2V0QkJveCIsInJ4IiwicnkiLCJkeSIsIkVkZ2VUZXh0IiwiQmFzZUVkZ2UiLCJwYXRoIiwibGFiZWxYIiwibGFiZWxZIiwiaW50ZXJhY3Rpb25XaWR0aCIsImQiLCJzdHJva2VPcGFjaXR5IiwiZ2V0Q29udHJvbCIsInBvcyIsIngxIiwieTEiLCJ4MiIsInkyIiwiTGVmdCIsIlJpZ2h0IiwiZ2V0U2ltcGxlQmV6aWVyUGF0aCIsInNvdXJjZVgiLCJzb3VyY2VZIiwidGFyZ2V0WCIsInRhcmdldFkiLCJzb3VyY2VDb250cm9sWCIsInNvdXJjZUNvbnRyb2xZIiwidGFyZ2V0Q29udHJvbFgiLCJ0YXJnZXRDb250cm9sWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwiY3JlYXRlU2ltcGxlQmV6aWVyRWRnZSIsIl9pZCIsImlzSW50ZXJuYWwiLCJTaW1wbGVCZXppZXJFZGdlIiwiU2ltcGxlQmV6aWVyRWRnZUludGVybmFsIiwiY3JlYXRlU21vb3RoU3RlcEVkZ2UiLCJwYXRoT3B0aW9ucyIsImJvcmRlclJhZGl1cyIsIm9mZnNldCIsIlNtb290aFN0ZXBFZGdlIiwiU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCIsImNyZWF0ZVN0ZXBFZGdlIiwiU3RlcEVkZ2UiLCJTdGVwRWRnZUludGVybmFsIiwiY3JlYXRlU3RyYWlnaHRFZGdlIiwiU3RyYWlnaHRFZGdlIiwiU3RyYWlnaHRFZGdlSW50ZXJuYWwiLCJjcmVhdGVCZXppZXJFZGdlIiwiY3VydmF0dXJlIiwiQmV6aWVyRWRnZSIsIkJlemllckVkZ2VJbnRlcm5hbCIsImJ1aWx0aW5FZGdlVHlwZXMiLCJzdHJhaWdodCIsInN0ZXAiLCJzbW9vdGhzdGVwIiwic2ltcGxlYmV6aWVyIiwibnVsbFBvc2l0aW9uIiwic2hpZnRYIiwic2hpZnQiLCJzaGlmdFkiLCJFZGdlVXBkYXRlckNsYXNzTmFtZSIsIkVkZ2VBbmNob3IiLCJyYWRpdXMiLCJvbk1vdXNlT3V0IiwiY3giLCJjeSIsInIiLCJFZGdlVXBkYXRlQW5jaG9ycyIsImlzUmVjb25uZWN0YWJsZSIsInJlY29ubmVjdFJhZGl1cyIsIm9uUmVjb25uZWN0Iiwib25SZWNvbm5lY3RTdGFydCIsIm9uUmVjb25uZWN0RW5kIiwic2V0UmVjb25uZWN0aW5nIiwic2V0VXBkYXRlSG92ZXIiLCJoYW5kbGVFZGdlVXBkYXRlciIsIm9wcG9zaXRlSGFuZGxlIiwiX29uUmVjb25uZWN0RW5kIiwiZXZ0Iiwib25Db25uZWN0RWRnZSIsImVkZ2VVcGRhdGVyVHlwZSIsIm9uUmVjb25uZWN0U291cmNlTW91c2VEb3duIiwidGFyZ2V0SGFuZGxlIiwib25SZWNvbm5lY3RUYXJnZXRNb3VzZURvd24iLCJzb3VyY2VIYW5kbGUiLCJvblJlY29ubmVjdE1vdXNlRW50ZXIiLCJvblJlY29ubmVjdE1vdXNlT3V0IiwiRWRnZVdyYXBwZXIiLCJlZGdlc0ZvY3VzYWJsZSIsImVkZ2VzUmVjb25uZWN0YWJsZSIsImVkZ2VUeXBlcyIsImVkZ2VUeXBlIiwiRWRnZUNvbXBvbmVudCIsInJlY29ubmVjdGFibGUiLCJlZGdlUmVmIiwidXBkYXRlSG92ZXIiLCJyZWNvbm5lY3RpbmciLCJlZGdlUG9zaXRpb24iLCJlbGV2YXRlT25TZWxlY3QiLCJlbGV2YXRlRWRnZXNPblNlbGVjdCIsIm1hcmtlclN0YXJ0VXJsIiwibWFya2VyRW5kVXJsIiwib25FZGdlQ2xpY2siLCJhZGRTZWxlY3RlZEVkZ2VzIiwib25FZGdlRG91YmxlQ2xpY2siLCJvbkVkZ2VDb250ZXh0TWVudSIsIm9uRWRnZU1vdXNlRW50ZXIiLCJvbkVkZ2VNb3VzZU1vdmUiLCJvbkVkZ2VNb3VzZUxlYXZlIiwiYW5pbWF0ZWQiLCJpbmFjdGl2ZSIsInVwZGF0aW5nIiwic291cmNlSGFuZGxlSWQiLCJ0YXJnZXRIYW5kbGVJZCIsInNlbGVjdG9yJGEiLCJFZGdlUmVuZGVyZXJDb21wb25lbnQiLCJkZWZhdWx0TWFya2VyQ29sb3IiLCJFZGdlUmVuZGVyZXIiLCJzZWxlY3RvciQ5IiwiVmlld3BvcnQiLCJ1c2VPbkluaXRIYW5kbGVyIiwib25Jbml0IiwicmZJbnN0YW5jZSIsInNldFRpbWVvdXQiLCJzZWxlY3RvciQ4Iiwic3luY1ZpZXdwb3J0IiwidXNlVmlld3BvcnRTeW5jIiwic3RvcmVTZWxlY3RvciQxIiwidG8iLCJnZXRTZWxlY3RvciIsImNvbm5lY3Rpb25TZWxlY3RvciIsImNvbWJpbmVkU2VsZWN0b3IiLCJ1c2VDb25uZWN0aW9uIiwic2VsZWN0b3IkNyIsIkNvbm5lY3Rpb25MaW5lV3JhcHBlciIsImNvbXBvbmVudCIsInJlbmRlckNvbm5lY3Rpb24iLCJDb25uZWN0aW9uTGluZSIsIkN1c3RvbUNvbXBvbmVudCIsIkJlemllciIsImZyb21Ob2RlIiwiZnJvbVBvc2l0aW9uIiwidG9Ob2RlIiwiY29ubmVjdGlvbkxpbmVUeXBlIiwiY29ubmVjdGlvbkxpbmVTdHlsZSIsImZyb21YIiwiZnJvbVkiLCJ0b1giLCJ0b1kiLCJjb25uZWN0aW9uU3RhdHVzIiwicGF0aFBhcmFtcyIsIlNpbXBsZUJlemllciIsIlN0ZXAiLCJTbW9vdGhTdGVwIiwiZW1wdHlUeXBlcyIsInVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmciLCJub2RlT3JFZGdlVHlwZXMiLCJ0eXBlc1JlZiIsInByb2Nlc3MiLCJ1c2VkS2V5cyIsInVzZVN0eWxlc0xvYWRlZFdhcm5pbmciLCJjaGVja2VkIiwicGFuZSIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRDb21wdXRlZFN0eWxlIiwiR3JhcGhWaWV3Q29tcG9uZW50IiwiY29ubmVjdGlvbkxpbmVDb21wb25lbnQiLCJjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlIiwiR3JhcGhWaWV3IiwiZ2V0SW5pdGlhbFN0YXRlIiwic3RvcmVFZGdlcyIsInN0b3JlTm9kZXMiLCJzdG9yZU5vZGVPcmlnaW4iLCJzdG9yZU5vZGVFeHRlbnQiLCJlbGV2YXRlTm9kZXNPblNlbGVjdCIsImZpdFZpZXdEb25lIiwiYXV0b1Bhbk9uTm9kZURyYWciLCJkZWJ1ZyIsImNyZWF0ZVN0b3JlIiwiZml0VmlldyQxIiwiY2hlY2tFcXVhbGl0eSIsInRyaWdnZXJGaXRWaWV3IiwiZml0Vmlld1N5bmMiLCJ1cGRhdGVkSW50ZXJuYWxzIiwibmV4dEZpdFZpZXdEb25lIiwiY29uc29sZSIsImxvZyIsIm5vZGVEcmFnSXRlbXMiLCJwYXJlbnRFeHBhbmRDaGlsZHJlbiIsImRyYWdJdGVtIiwiZXhwYW5kUGFyZW50IiwibWF4IiwicmVjdCIsInBhcmVudEV4cGFuZENoYW5nZXMiLCJ1cGRhdGVkTm9kZXMiLCJ1cGRhdGVkRWRnZXMiLCJjaGFuZ2VkRWRnZXMiLCJub2Rlc1RvVW5zZWxlY3QiLCJlZGdlc1RvVW5zZWxlY3QiLCJzZXRTY2FsZUV4dGVudCIsImNsaWNrRGlzdGFuY2UiLCJzZXRDbGlja0Rpc3RhbmNlIiwibmV4dE5vZGVFeHRlbnQiLCJkZWx0YSIsImlzIiwiUmVhY3RGbG93UHJvdmlkZXIiLCJpbml0aWFsTm9kZXMiLCJpbml0aWFsRWRnZXMiLCJXcmFwcGVyIiwiaXNXcmFwcGVkIiwid3JhcHBlclN0eWxlIiwiUmVhY3RGbG93Iiwib25Ob2RlRHJhZ1N0YXJ0Iiwib25Ob2RlRHJhZyIsIm9uTm9kZURyYWdTdG9wIiwib25TZWxlY3Rpb25EcmFnU3RhcnQiLCJvblNlbGVjdGlvbkRyYWciLCJvblNlbGVjdGlvbkRyYWdTdG9wIiwiZGVmYXVsdFZpZXdwb3J0JDEiLCJmaXRWaWV3T3B0aW9ucyIsImF0dHJpYnV0aW9uUG9zaXRpb24iLCJjb2xvck1vZGVDbGFzc05hbWUiLCJzZWxlY3RvciQ2IiwiRWRnZUxhYmVsUmVuZGVyZXIiLCJlZGdlTGFiZWxSZW5kZXJlciIsInNlbGVjdG9yJDUiLCJWaWV3cG9ydFBvcnRhbCIsInZpZXdQb3J0YWxEaXYiLCJ1c2VVcGRhdGVOb2RlSW50ZXJuYWxzIiwidXBkYXRlSWRzIiwidXBkYXRlSWQiLCJub2Rlc1NlbGVjdG9yIiwidXNlTm9kZXMiLCJlZGdlc1NlbGVjdG9yIiwidXNlRWRnZXMiLCJ2aWV3cG9ydFNlbGVjdG9yIiwidXNlVmlld3BvcnQiLCJ1c2VOb2Rlc1N0YXRlIiwibmRzIiwidXNlRWRnZXNTdGF0ZSIsImVkcyIsInVzZU9uVmlld3BvcnRDaGFuZ2UiLCJvblN0YXJ0Iiwib25DaGFuZ2UiLCJvbkVuZCIsInVzZU9uU2VsZWN0aW9uQ2hhbmdlIiwibmV4dE9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMiLCJuZXh0SGFuZGxlcnMiLCJzZWxlY3RvciQ0IiwiaW5jbHVkZUhpZGRlbk5vZGVzIiwiZGVmYXVsdE9wdGlvbnMiLCJ1c2VOb2Rlc0luaXRpYWxpemVkIiwiaW5pdGlhbGl6ZWQiLCJ1c2VIYW5kbGVDb25uZWN0aW9ucyIsIm9uRGlzY29ubmVjdCIsIndhcm4iLCJfbm9kZUlkIiwiY3VycmVudE5vZGVJZCIsInByZXZDb25uZWN0aW9ucyIsIl9jb25uZWN0aW9ucyIsImVycm9yMDE0IiwidXNlTm9kZUNvbm5lY3Rpb25zIiwidXNlTm9kZXNEYXRhIiwibm9kZXNEYXRhIiwiaXNBcnJheU9mSWRzIiwiX25vZGVJZHMiLCJ1c2VJbnRlcm5hbE5vZGUiLCJMaW5lUGF0dGVybiIsImxpbmVXaWR0aCIsInZhcmlhbnQiLCJEb3RQYXR0ZXJuIiwiQmFja2dyb3VuZFZhcmlhbnQiLCJkZWZhdWx0U2l6ZSIsIkRvdHMiLCJMaW5lcyIsIkNyb3NzIiwic2VsZWN0b3IkMyIsInBhdHRlcm5JZCIsIkJhY2tncm91bmRDb21wb25lbnQiLCJnYXAiLCJiZ0NvbG9yIiwicGF0dGVybkNsYXNzTmFtZSIsInBhdHRlcm5TaXplIiwiaXNEb3RzIiwiaXNDcm9zcyIsImdhcFhZIiwic2NhbGVkR2FwIiwic2NhbGVkU2l6ZSIsIm9mZnNldFhZIiwicGF0dGVybkRpbWVuc2lvbnMiLCJzY2FsZWRPZmZzZXQiLCJfcGF0dGVybklkIiwicGF0dGVyblVuaXRzIiwicGF0dGVyblRyYW5zZm9ybSIsIkJhY2tncm91bmQiLCJQbHVzSWNvbiIsInhtbG5zIiwiTWludXNJY29uIiwiRml0Vmlld0ljb24iLCJMb2NrSWNvbiIsIlVubG9ja0ljb24iLCJDb250cm9sQnV0dG9uIiwic2VsZWN0b3IkMiIsImlzSW50ZXJhY3RpdmUiLCJtaW5ab29tUmVhY2hlZCIsIm1heFpvb21SZWFjaGVkIiwiQ29udHJvbHNDb21wb25lbnQiLCJzaG93Wm9vbSIsInNob3dGaXRWaWV3Iiwic2hvd0ludGVyYWN0aXZlIiwib25ab29tSW4iLCJvblpvb21PdXQiLCJvbkZpdFZpZXciLCJvbkludGVyYWN0aXZlQ2hhbmdlIiwib3JpZW50YXRpb24iLCJvblpvb21JbkhhbmRsZXIiLCJvblpvb21PdXRIYW5kbGVyIiwib25GaXRWaWV3SGFuZGxlciIsIm9uVG9nZ2xlSW50ZXJhY3Rpdml0eSIsIm9yaWVudGF0aW9uQ2xhc3MiLCJ0aXRsZSIsIkNvbnRyb2xzIiwiTWluaU1hcE5vZGVDb21wb25lbnQiLCJzdHJva2VDb2xvciIsInNoYXBlUmVuZGVyaW5nIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRDb2xvciIsIk1pbmlNYXBOb2RlIiwic2VsZWN0b3JOb2RlSWRzIiwiZ2V0QXR0ckZ1bmN0aW9uIiwiZnVuYyIsIkZ1bmN0aW9uIiwiTWluaU1hcE5vZGVzIiwibm9kZVN0cm9rZUNvbG9yIiwibm9kZUNvbG9yIiwibm9kZUNsYXNzTmFtZSIsIm5vZGVCb3JkZXJSYWRpdXMiLCJub2RlU3Ryb2tlV2lkdGgiLCJub2RlQ29tcG9uZW50Iiwibm9kZUNvbG9yRnVuYyIsIm5vZGVTdHJva2VDb2xvckZ1bmMiLCJub2RlQ2xhc3NOYW1lRnVuYyIsImNocm9tZSIsIk5vZGVDb21wb25lbnRXcmFwcGVyIiwiTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lciIsIk1pbmlNYXBOb2RlcyQxIiwiZGVmYXVsdFdpZHRoIiwiZGVmYXVsdEhlaWdodCIsInNlbGVjdG9yJDEiLCJ2aWV3QkIiLCJib3VuZGluZ1JlY3QiLCJmbG93V2lkdGgiLCJmbG93SGVpZ2h0IiwiQVJJQV9MQUJFTF9LRVkiLCJNaW5pTWFwQ29tcG9uZW50IiwibWFza0NvbG9yIiwibWFza1N0cm9rZUNvbG9yIiwibWFza1N0cm9rZVdpZHRoIiwicGFubmFibGUiLCJ6b29tYWJsZSIsImludmVyc2VQYW4iLCJ6b29tU3RlcCIsIm9mZnNldFNjYWxlIiwic3ZnIiwiZWxlbWVudFdpZHRoIiwiZWxlbWVudEhlaWdodCIsInNjYWxlZFdpZHRoIiwic2NhbGVkSGVpZ2h0Iiwidmlld1NjYWxlIiwidmlld1dpZHRoIiwidmlld0hlaWdodCIsImxhYmVsbGVkQnkiLCJ2aWV3U2NhbGVSZWYiLCJtaW5pbWFwSW5zdGFuY2UiLCJnZXRWaWV3U2NhbGUiLCJvblN2Z0NsaWNrIiwicG9pbnRlciIsIm9uU3ZnTm9kZUNsaWNrIiwiZmlsbFJ1bGUiLCJNaW5pTWFwIiwiUmVzaXplQ29udHJvbCIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwibWF4V2lkdGgiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJtYXhIZWlnaHQiLCJrZWVwQXNwZWN0UmF0aW8iLCJzaG91bGRSZXNpemUiLCJvblJlc2l6ZVN0YXJ0Iiwib25SZXNpemUiLCJvblJlc2l6ZUVuZCIsImNvbnRleHROb2RlSWQiLCJyZXNpemVDb250cm9sUmVmIiwiZGVmYXVsdFBvc2l0aW9uIiwiTGluZSIsImNvbnRyb2xQb3NpdGlvbiIsInJlc2l6ZXIiLCJwYW5lRG9tTm9kZSIsImNoaWxkQ2hhbmdlcyIsIm9yaWdpbiIsImNoaWxkIiwicG9zaXRpb25DaGFuZ2UiLCJkaW1lbnNpb25DaGFuZ2UiLCJjaGlsZENoYW5nZSIsImJvdW5kYXJpZXMiLCJwb3NpdGlvbkNsYXNzTmFtZXMiLCJjb2xvclN0eWxlUHJvcCIsImNvbnRyb2xTdHlsZSIsIk5vZGVSZXNpemVDb250cm9sIiwiTm9kZVJlc2l6ZXIiLCJpc1Zpc2libGUiLCJoYW5kbGVDbGFzc05hbWUiLCJoYW5kbGVTdHlsZSIsImxpbmVDbGFzc05hbWUiLCJsaW5lU3R5bGUiLCJOb2RlVG9vbGJhclBvcnRhbCIsIndyYXBwZXJSZWYiLCJub2RlRXF1YWxpdHlGbiIsIm5vZGVzRXF1YWxpdHlGbiIsInN0b3JlU2VsZWN0b3IiLCJzZWxlY3RlZE5vZGVzQ291bnQiLCJOb2RlVG9vbGJhciIsImFsaWduIiwiaW50ZXJuYWxOb2RlcyIsIm5vZGVzQXJyYXkiLCJhY2MiLCJ0cmltIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/system/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xyflow/system/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),\n/* harmony export */   MarkerType: () => (/* binding */ MarkerType),\n/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   ResizeControlVariant: () => (/* binding */ ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),\n/* harmony export */   XYDrag: () => (/* binding */ XYDrag),\n/* harmony export */   XYHandle: () => (/* binding */ XYHandle),\n/* harmony export */   XYMinimap: () => (/* binding */ XYMinimap),\n/* harmony export */   XYPanZoom: () => (/* binding */ XYPanZoom),\n/* harmony export */   XYResizer: () => (/* binding */ XYResizer),\n/* harmony export */   XY_RESIZER_HANDLE_POSITIONS: () => (/* binding */ XY_RESIZER_HANDLE_POSITIONS),\n/* harmony export */   XY_RESIZER_LINE_POSITIONS: () => (/* binding */ XY_RESIZER_LINE_POSITIONS),\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   adoptUserNodes: () => (/* binding */ adoptUserNodes),\n/* harmony export */   areConnectionMapsEqual: () => (/* binding */ areConnectionMapsEqual),\n/* harmony export */   areSetsEqual: () => (/* binding */ areSetsEqual),\n/* harmony export */   boxToRect: () => (/* binding */ boxToRect),\n/* harmony export */   calcAutoPan: () => (/* binding */ calcAutoPan),\n/* harmony export */   calculateNodePosition: () => (/* binding */ calculateNodePosition),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   clampPosition: () => (/* binding */ clampPosition),\n/* harmony export */   clampPositionToParent: () => (/* binding */ clampPositionToParent),\n/* harmony export */   createMarkerIds: () => (/* binding */ createMarkerIds),\n/* harmony export */   devWarn: () => (/* binding */ devWarn),\n/* harmony export */   elementSelectionKeys: () => (/* binding */ elementSelectionKeys),\n/* harmony export */   errorMessages: () => (/* binding */ errorMessages),\n/* harmony export */   evaluateAbsolutePosition: () => (/* binding */ evaluateAbsolutePosition),\n/* harmony export */   fitView: () => (/* binding */ fitView),\n/* harmony export */   getBezierEdgeCenter: () => (/* binding */ getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),\n/* harmony export */   getBoundsOfBoxes: () => (/* binding */ getBoundsOfBoxes),\n/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),\n/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),\n/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),\n/* harmony export */   getDimensions: () => (/* binding */ getDimensions),\n/* harmony export */   getEdgeCenter: () => (/* binding */ getEdgeCenter),\n/* harmony export */   getEdgePosition: () => (/* binding */ getEdgePosition),\n/* harmony export */   getElementsToRemove: () => (/* binding */ getElementsToRemove),\n/* harmony export */   getElevatedEdgeZIndex: () => (/* binding */ getElevatedEdgeZIndex),\n/* harmony export */   getEventPosition: () => (/* binding */ getEventPosition),\n/* harmony export */   getFitViewNodes: () => (/* binding */ getFitViewNodes),\n/* harmony export */   getHandleBounds: () => (/* binding */ getHandleBounds),\n/* harmony export */   getHandlePosition: () => (/* binding */ getHandlePosition),\n/* harmony export */   getHostForElement: () => (/* binding */ getHostForElement),\n/* harmony export */   getIncomers: () => (/* binding */ getIncomers),\n/* harmony export */   getInternalNodesBounds: () => (/* binding */ getInternalNodesBounds),\n/* harmony export */   getMarkerId: () => (/* binding */ getMarkerId),\n/* harmony export */   getNodeDimensions: () => (/* binding */ getNodeDimensions),\n/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),\n/* harmony export */   getNodeToolbarTransform: () => (/* binding */ getNodeToolbarTransform),\n/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),\n/* harmony export */   getNodesInside: () => (/* binding */ getNodesInside),\n/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),\n/* harmony export */   getOverlappingArea: () => (/* binding */ getOverlappingArea),\n/* harmony export */   getPointerPosition: () => (/* binding */ getPointerPosition),\n/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),\n/* harmony export */   handleConnectionChange: () => (/* binding */ handleConnectionChange),\n/* harmony export */   handleExpandParent: () => (/* binding */ handleExpandParent),\n/* harmony export */   infiniteExtent: () => (/* binding */ infiniteExtent),\n/* harmony export */   initialConnection: () => (/* binding */ initialConnection),\n/* harmony export */   isCoordinateExtent: () => (/* binding */ isCoordinateExtent),\n/* harmony export */   isEdgeBase: () => (/* binding */ isEdgeBase),\n/* harmony export */   isEdgeVisible: () => (/* binding */ isEdgeVisible),\n/* harmony export */   isInputDOMNode: () => (/* binding */ isInputDOMNode),\n/* harmony export */   isInternalNodeBase: () => (/* binding */ isInternalNodeBase),\n/* harmony export */   isMacOs: () => (/* binding */ isMacOs),\n/* harmony export */   isMouseEvent: () => (/* binding */ isMouseEvent),\n/* harmony export */   isNodeBase: () => (/* binding */ isNodeBase),\n/* harmony export */   isNumeric: () => (/* binding */ isNumeric),\n/* harmony export */   isRectObject: () => (/* binding */ isRectObject),\n/* harmony export */   nodeHasDimensions: () => (/* binding */ nodeHasDimensions),\n/* harmony export */   nodeToBox: () => (/* binding */ nodeToBox),\n/* harmony export */   nodeToRect: () => (/* binding */ nodeToRect),\n/* harmony export */   oppositePosition: () => (/* binding */ oppositePosition),\n/* harmony export */   panBy: () => (/* binding */ panBy),\n/* harmony export */   pointToRendererPoint: () => (/* binding */ pointToRendererPoint),\n/* harmony export */   reconnectEdge: () => (/* binding */ reconnectEdge),\n/* harmony export */   rectToBox: () => (/* binding */ rectToBox),\n/* harmony export */   rendererPointToPoint: () => (/* binding */ rendererPointToPoint),\n/* harmony export */   shallowNodeData: () => (/* binding */ shallowNodeData),\n/* harmony export */   snapPosition: () => (/* binding */ snapPosition),\n/* harmony export */   updateAbsolutePositions: () => (/* binding */ updateAbsolutePositions),\n/* harmony export */   updateConnectionLookup: () => (/* binding */ updateConnectionLookup),\n/* harmony export */   updateNodeInternals: () => (/* binding */ updateNodeInternals)\n/* harmony export */ });\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n\n\n\n\nconst errorMessages = {\n    error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',\n    error002: () => \"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType) => `Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: () => 'The React Flow parent container needs a width and a height to render the graph.',\n    error005: () => 'Only child nodes can use a parent extent.',\n    error006: () => \"Can't create edge. An edge needs a source and a target.\",\n    error007: (id) => `The old edge with id=${id} does not exist.`,\n    error009: (type) => `Marker type \"${type}\" doesn't exist.`,\n    error008: (handleType, { id, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: \"${handleType === 'source' ? sourceHandle : targetHandle}\", edge id: ${id}.`,\n    error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',\n    error011: (edgeType) => `Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id) => `Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`,\n    error013: (lib = 'react') => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,\n    error014: () => 'useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.',\n};\nconst infiniteExtent = [\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n];\nconst elementSelectionKeys = ['Enter', ' ', 'Escape'];\n\nvar ConnectionMode;\n(function (ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\nvar PanOnScrollMode;\n(function (PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function (SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nconst initialConnection = {\n    inProgress: false,\n    isValid: null,\n    from: null,\n    fromHandle: null,\n    fromPosition: null,\n    fromNode: null,\n    to: null,\n    toHandle: null,\n    toPosition: null,\n    toNode: null,\n};\n\nvar ConnectionLineType;\n(function (ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\nvar MarkerType;\n(function (MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\n\nvar Position;\n(function (Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top,\n};\n\n/**\n * @internal\n */\nfunction areConnectionMapsEqual(a, b) {\n    if (!a && !b) {\n        return true;\n    }\n    if (!a || !b || a.size !== b.size) {\n        return false;\n    }\n    if (!a.size && !b.size) {\n        return true;\n    }\n    for (const key of a.keys()) {\n        if (!b.has(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * We call the callback for all connections in a that are not in b\n *\n * @internal\n */\nfunction handleConnectionChange(a, b, cb) {\n    if (!cb) {\n        return;\n    }\n    const diff = [];\n    a.forEach((connection, key) => {\n        if (!b?.has(key)) {\n            diff.push(connection);\n        }\n    });\n    if (diff.length) {\n        cb(diff);\n    }\n}\nfunction getConnectionStatus(isValid) {\n    return isValid === null ? null : isValid ? 'valid' : 'invalid';\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Test whether an object is useable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */\nconst isEdgeBase = (element) => 'id' in element && 'source' in element && 'target' in element;\n/**\n * Test whether an object is useable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */\nconst isNodeBase = (element) => 'id' in element && 'position' in element && !('source' in element) && !('target' in element);\nconst isInternalNodeBase = (element) => 'id' in element && 'internals' in element && !('source' in element) && !('target' in element);\n/**\n * Pass in a node, and get connected nodes where edge.source === node.id\n * @public\n * @param node - The node to get the connected nodes from\n * @param nodes - The array of all nodes\n * @param edges - The array of all edges\n * @returns An array of nodes that are connected over eges where the source is the given node\n */\nconst getOutgoers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const outgoerIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.source === node.id) {\n            outgoerIds.add(edge.target);\n        }\n    });\n    return nodes.filter((n) => outgoerIds.has(n.id));\n};\n/**\n * Pass in a node, and get connected nodes where edge.target === node.id\n * @public\n * @param node - The node to get the connected nodes from\n * @param nodes - The array of all nodes\n * @param edges - The array of all edges\n * @returns An array of nodes that are connected over eges where the target is the given node\n */\nconst getIncomers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const incomersIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.target === node.id) {\n            incomersIds.add(edge.source);\n        }\n    });\n    return nodes.filter((n) => incomersIds.has(n.id));\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {\n    const { width, height } = getNodeDimensions(node);\n    const origin = node.origin ?? nodeOrigin;\n    const offsetX = width * origin[0];\n    const offsetY = height * origin[1];\n    return {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY,\n    };\n};\n/**\n * Internal function for determining a bounding box that contains all given nodes in an array.\n * @public\n * @remarks Useful when combined with {@link getViewportForBounds} to calculate the correct transform to fit the given nodes in a viewport.\n * @param nodes - Nodes to calculate the bounds for\n * @param params.nodeOrigin - Origin of the nodes: [0, 0] - top left, [0.5, 0.5] - center\n * @returns Bounding box enclosing all nodes\n */\nconst getNodesBounds = (nodes, params = { nodeOrigin: [0, 0], nodeLookup: undefined }) => {\n    if ( true && !params.nodeLookup) {\n        console.warn('Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.');\n    }\n    if (nodes.length === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    const box = nodes.reduce((currBox, nodeOrId) => {\n        const isId = typeof nodeOrId === 'string';\n        let currentNode = !params.nodeLookup && !isId ? nodeOrId : undefined;\n        if (params.nodeLookup) {\n            currentNode = isId\n                ? params.nodeLookup.get(nodeOrId)\n                : !isInternalNodeBase(nodeOrId)\n                    ? params.nodeLookup.get(nodeOrId.id)\n                    : nodeOrId;\n        }\n        const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };\n        return getBoundsOfBoxes(currBox, nodeBox);\n    }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });\n    return boxToRect(box);\n};\n/**\n * Determines a bounding box that contains all given nodes in an array\n * @internal\n */\nconst getInternalNodesBounds = (nodeLookup, params = {}) => {\n    if (nodeLookup.size === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };\n    nodeLookup.forEach((node) => {\n        if (params.filter === undefined || params.filter(node)) {\n            const nodeBox = nodeToBox(node);\n            box = getBoundsOfBoxes(box, nodeBox);\n        }\n    });\n    return boxToRect(box);\n};\nconst getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, \n// set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false) => {\n    const paneRect = {\n        ...pointToRendererPoint(rect, [tx, ty, tScale]),\n        width: rect.width / tScale,\n        height: rect.height / tScale,\n    };\n    const visibleNodes = [];\n    for (const node of nodes.values()) {\n        const { measured, selectable = true, hidden = false } = node;\n        if ((excludeNonSelectableNodes && !selectable) || hidden) {\n            continue;\n        }\n        const width = measured.width ?? node.width ?? node.initialWidth ?? null;\n        const height = measured.height ?? node.height ?? node.initialHeight ?? null;\n        const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));\n        const area = (width ?? 0) * (height ?? 0);\n        const partiallyVisible = partially && overlappingArea > 0;\n        const forceInitialRender = !node.internals.handleBounds;\n        const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    }\n    return visibleNodes;\n};\n/**\n * Get all connecting edges for a given set of nodes\n * @param nodes - Nodes you want to get the connected edges for\n * @param edges - All edges\n * @returns Array of edges that connect any of the given nodes with each other\n */\nconst getConnectedEdges = (nodes, edges) => {\n    const nodeIds = new Set();\n    nodes.forEach((node) => {\n        nodeIds.add(node.id);\n    });\n    return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));\n};\nfunction getFitViewNodes(nodeLookup, options) {\n    const fitViewNodes = new Map();\n    const optionNodeIds = options?.nodes ? new Set(options.nodes.map((node) => node.id)) : null;\n    nodeLookup.forEach((n) => {\n        const isVisible = n.measured.width && n.measured.height && (options?.includeHiddenNodes || !n.hidden);\n        if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {\n            fitViewNodes.set(n.id, n);\n        }\n    });\n    return fitViewNodes;\n}\nasync function fitView({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {\n    if (nodes.size === 0) {\n        return Promise.resolve(false);\n    }\n    const bounds = getInternalNodesBounds(nodes);\n    const viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);\n    await panZoom.setViewport(viewport, { duration: options?.duration });\n    return Promise.resolve(true);\n}\n/**\n * This function calculates the next position of a node, taking into account the node's extent, parent node, and origin.\n *\n * @internal\n * @returns position, positionAbsolute\n */\nfunction calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError, }) {\n    const node = nodeLookup.get(nodeId);\n    const parentNode = node.parentId ? nodeLookup.get(node.parentId) : undefined;\n    const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };\n    const origin = node.origin ?? nodeOrigin;\n    let extent = nodeExtent;\n    if (node.extent === 'parent' && !node.expandParent) {\n        if (!parentNode) {\n            onError?.('005', errorMessages['error005']());\n        }\n        else {\n            const parentWidth = parentNode.measured.width;\n            const parentHeight = parentNode.measured.height;\n            if (parentWidth && parentHeight) {\n                extent = [\n                    [parentX, parentY],\n                    [parentX + parentWidth, parentY + parentHeight],\n                ];\n            }\n        }\n    }\n    else if (parentNode && isCoordinateExtent(node.extent)) {\n        extent = [\n            [node.extent[0][0] + parentX, node.extent[0][1] + parentY],\n            [node.extent[1][0] + parentX, node.extent[1][1] + parentY],\n        ];\n    }\n    const positionAbsolute = isCoordinateExtent(extent)\n        ? clampPosition(nextPosition, extent, node.measured)\n        : nextPosition;\n    return {\n        position: {\n            x: positionAbsolute.x - parentX + node.measured.width * origin[0],\n            y: positionAbsolute.y - parentY + node.measured.height * origin[1],\n        },\n        positionAbsolute,\n    };\n}\n/**\n * Pass in nodes & edges to delete, get arrays of nodes and edges that actually can be deleted\n * @internal\n * @param param.nodesToRemove - The nodes to remove\n * @param param.edgesToRemove - The edges to remove\n * @param param.nodes - All nodes\n * @param param.edges - All edges\n * @param param.onBeforeDelete - Callback to check which nodes and edges can be deleted\n * @returns nodes: nodes that can be deleted, edges: edges that can be deleted\n */\nasync function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete, }) {\n    const nodeIds = new Set(nodesToRemove.map((node) => node.id));\n    const matchingNodes = [];\n    for (const node of nodes) {\n        if (node.deletable === false) {\n            continue;\n        }\n        const isIncluded = nodeIds.has(node.id);\n        const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);\n        if (isIncluded || parentHit) {\n            matchingNodes.push(node);\n        }\n    }\n    const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));\n    const deletableEdges = edges.filter((edge) => edge.deletable !== false);\n    const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);\n    const matchingEdges = connectedEdges;\n    for (const edge of deletableEdges) {\n        const isIncluded = edgeIds.has(edge.id);\n        if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {\n            matchingEdges.push(edge);\n        }\n    }\n    if (!onBeforeDelete) {\n        return {\n            edges: matchingEdges,\n            nodes: matchingNodes,\n        };\n    }\n    const onBeforeDeleteResult = await onBeforeDelete({\n        nodes: matchingNodes,\n        edges: matchingEdges,\n    });\n    if (typeof onBeforeDeleteResult === 'boolean') {\n        return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };\n    }\n    return onBeforeDeleteResult;\n}\n\nconst clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);\nconst clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({\n    x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),\n    y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0)),\n});\nfunction clampPositionToParent(childPosition, childDimensions, parent) {\n    const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);\n    const { x: parentX, y: parentY } = parent.internals.positionAbsolute;\n    return clampPosition(childPosition, [\n        [parentX, parentY],\n        [parentX + parentWidth, parentY + parentHeight],\n    ], childDimensions);\n}\n/**\n * Calculates the velocity of panning when the mouse is close to the edge of the canvas\n * @internal\n * @param value - One dimensional poition of the mouse (x or y)\n * @param min - Minimal position on canvas before panning starts\n * @param max - Maximal position on canvas before panning starts\n * @returns - A number between 0 and 1 that represents the velocity of panning\n */\nconst calcAutoPanVelocity = (value, min, max) => {\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, min) / min;\n    }\n    else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, min) / min;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds, speed = 15, distance = 40) => {\n    const xMovement = calcAutoPanVelocity(pos.x, distance, bounds.width - distance) * speed;\n    const yMovement = calcAutoPanVelocity(pos.y, distance, bounds.height - distance) * speed;\n    return [xMovement, yMovement];\n};\nconst getBoundsOfBoxes = (box1, box2) => ({\n    x: Math.min(box1.x, box2.x),\n    y: Math.min(box1.y, box2.y),\n    x2: Math.max(box1.x2, box2.x2),\n    y2: Math.max(box1.y2, box2.y2),\n});\nconst rectToBox = ({ x, y, width, height }) => ({\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n});\nconst boxToRect = ({ x, y, x2, y2 }) => ({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y,\n});\nconst nodeToRect = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n};\nconst nodeToBox = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        x2: x + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),\n        y2: y + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0),\n    };\n};\nconst getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB) => {\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nconst isNumeric = (n) => !isNaN(n) && isFinite(n);\n// used for a11y key board controls for nodes and edges\nconst devWarn = (id, message) => {\n    if (true) {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst snapPosition = (position, snapGrid = [1, 1]) => {\n    return {\n        x: snapGrid[0] * Math.round(position.x / snapGrid[0]),\n        y: snapGrid[1] * Math.round(position.y / snapGrid[1]),\n    };\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale,\n    };\n    return snapToGrid ? snapPosition(position, snapGrid) : position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty,\n    };\n};\n/**\n * Returns a viewport that encloses the given bounds with optional padding.\n * @public\n * @remarks You can determine bounds of nodes with {@link getNodesBounds} and {@link getBoundsOfRects}\n * @param bounds - Bounds to fit inside viewport\n * @param width - Width of the viewport\n * @param height  - Height of the viewport\n * @param minZoom - Minimum zoom level of the resulting viewport\n * @param maxZoom - Maximum zoom level of the resulting viewport\n * @param padding - Optional padding around the bounds\n * @returns A transforned {@link Viewport} that encloses the given bounds which you can pass to e.g. {@link setViewport}\n * @example\n * const { x, y, zoom } = getViewportForBounds(\n  { x: 0, y: 0, width: 100, height: 100},\n  1200, 800, 0.5, 2);\n */\nconst getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {\n    const xZoom = width / (bounds.width * (1 + padding));\n    const yZoom = height / (bounds.height * (1 + padding));\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    return { x, y, zoom: clampedZoom };\n};\nconst isMacOs = () => typeof navigator !== 'undefined' && navigator?.userAgent?.indexOf('Mac') >= 0;\nfunction isCoordinateExtent(extent) {\n    return extent !== undefined && extent !== 'parent';\n}\nfunction getNodeDimensions(node) {\n    return {\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n}\nfunction nodeHasDimensions(node) {\n    return ((node.measured?.width ?? node.width ?? node.initialWidth) !== undefined &&\n        (node.measured?.height ?? node.height ?? node.initialHeight) !== undefined);\n}\n/**\n * Convert child position to aboslute position\n *\n * @internal\n * @param position\n * @param parentId\n * @param nodeLookup\n * @param nodeOrigin\n * @returns an internal node with an absolute position\n */\nfunction evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {\n    const positionAbsolute = { ...position };\n    const parent = nodeLookup.get(parentId);\n    if (parent) {\n        const origin = parent.origin || nodeOrigin;\n        positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];\n        positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];\n    }\n    return positionAbsolute;\n}\nfunction areSetsEqual(a, b) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a) {\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = false, transform, containerBounds }) {\n    const { x, y } = getEventPosition(event);\n    const pointerPos = pointToRendererPoint({ x: x - (containerBounds?.left ?? 0), y: y - (containerBounds?.top ?? 0) }, transform);\n    const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;\n    // we need the snapped position in order to be able to skip unnecessary drag events\n    return {\n        xSnapped,\n        ySnapped,\n        ...pointerPos,\n    };\n}\nconst getDimensions = (node) => ({\n    width: node.offsetWidth,\n    height: node.offsetHeight,\n});\nconst getHostForElement = (element) => element?.getRootNode?.() || window?.document;\nconst inputTags = ['INPUT', 'SELECT', 'TEXTAREA'];\nfunction isInputDOMNode(event) {\n    // using composed path for handling shadow dom\n    const target = (event.composedPath?.()?.[0] || event.target);\n    if (target?.nodeType !== 1 /* Node.ELEMENT_NODE */)\n        return false;\n    const isInput = inputTags.includes(target.nodeName) || target.hasAttribute('contenteditable');\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target.closest('.nokey');\n}\nconst isMouseEvent = (event) => 'clientX' in event;\nconst getEventPosition = (event, bounds) => {\n    const isMouse = isMouseEvent(event);\n    const evtX = isMouse ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouse ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0),\n    };\n};\n// The handle bounds are calculated relative to the node element.\n// We store them in the internals object of the node in order to avoid\n// unnecessary recalculations.\nconst getHandleBounds = (type, nodeElement, nodeBounds, zoom, nodeId) => {\n    const handles = nodeElement.querySelectorAll(`.${type}`);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    return Array.from(handles).map((handle) => {\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute('data-handleid'),\n            type,\n            nodeId,\n            position: handle.getAttribute('data-handlepos'),\n            x: (handleBounds.left - nodeBounds.left) / zoom,\n            y: (handleBounds.top - nodeBounds.top) / zoom,\n            ...getDimensions(handle),\n        };\n    });\n};\n\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY, }) {\n    // cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n    // https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [centerX, centerY, offsetX, offsetY];\n}\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch (pos) {\n        case Position.Left:\n            return [x1 - calculateControlOffset(x1 - x2, c), y1];\n        case Position.Right:\n            return [x1 + calculateControlOffset(x2 - x1, c), y1];\n        case Position.Top:\n            return [x1, y1 - calculateControlOffset(y1 - y2, c)];\n        case Position.Bottom:\n            return [x1, y1 + calculateControlOffset(y2 - y1, c)];\n    }\n}\n/**\n * Get a bezier path from source to target handle\n * @param params.sourceX - The x position of the source handle\n * @param params.sourceY - The y position of the source handle\n * @param params.sourcePosition - The position of the source handle (default: Position.Bottom)\n * @param params.targetX - The x position of the target handle\n * @param params.targetY - The y position of the target handle\n * @param params.targetPosition - The position of the target handle (default: Position.Top)\n * @param params.curvature - The curvature of the bezier edge\n * @returns A path string you can use in an SVG, the labelX and labelY position (center of path) and offsetX, offsetY between source handle and label\n * @example\n *  const source = { x: 0, y: 20 };\n    const target = { x: 150, y: 100 };\n    \n    const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({\n      sourceX: source.x,\n      sourceY: source.y,\n      sourcePosition: Position.Right,\n      targetX: target.x,\n      targetY: target.y,\n      targetPosition: Position.Left,\n});\n */\nfunction getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25, }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature,\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature,\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY,\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY,\n    ];\n}\n\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY, }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [centerX, centerY, xOffset, yOffset];\n}\nfunction getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex = 0, elevateOnSelect = false, }) {\n    if (!elevateOnSelect) {\n        return zIndex;\n    }\n    const edgeOrConnectedNodeSelected = selected || targetNode.selected || sourceNode.selected;\n    const selectedZIndex = Math.max(sourceNode.internals.z || 0, targetNode.internals.z || 0, 1000);\n    return zIndex + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);\n}\nfunction isEdgeVisible({ sourceNode, targetNode, width, height, transform }) {\n    const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewRect = {\n        x: -transform[0] / transform[2],\n        y: -transform[1] / transform[2],\n        width: width / transform[2],\n        height: height / transform[2],\n    };\n    return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;\n}\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ''}-${target}${targetHandle || ''}`;\nconst connectionExists = (edge, edges) => {\n    return edges.some((el) => el.source === edge.source &&\n        el.target === edge.target &&\n        (el.sourceHandle === edge.sourceHandle || (!el.sourceHandle && !edge.sourceHandle)) &&\n        (el.targetHandle === edge.targetHandle || (!el.targetHandle && !edge.targetHandle)));\n};\n/**\n * This util is a convenience function to add a new Edge to an array of edges\n * @remarks It also performs some validation to make sure you don't add an invalid edge or duplicate an existing one.\n * @public\n * @param edgeParams - Either an Edge or a Connection you want to add\n * @param edges -  The array of all current edges\n * @returns A new array of edges with the new edge added\n */\nconst addEdge = (edgeParams, edges) => {\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    let edge;\n    if (isEdgeBase(edgeParams)) {\n        edge = { ...edgeParams };\n    }\n    else {\n        edge = {\n            ...edgeParams,\n            id: getEdgeId(edgeParams),\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    if (edge.sourceHandle === null) {\n        delete edge.sourceHandle;\n    }\n    if (edge.targetHandle === null) {\n        delete edge.targetHandle;\n    }\n    return edges.concat(edge);\n};\n/**\n * A handy utility to reconnect an existing edge with new properties\n * @param oldEdge - The edge you want to update\n * @param newConnection - The new connection you want to update the edge with\n * @param edges - The array of all current edges\n * @param options.shouldReplaceId - should the id of the old edge be replaced with the new connection id\n * @returns the updated edges array\n */\nconst reconnectEdge = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    const foundEdge = edges.find((e) => e.id === oldEdge.id);\n    if (!foundEdge) {\n        devWarn('007', errorMessages['error007'](oldEdgeId));\n        return edges;\n    }\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle,\n    };\n    return edges.filter((e) => e.id !== oldEdgeId).concat(edge);\n};\n\n/**\n * Get a straight path from source to target handle\n * @param params.sourceX - The x position of the source handle\n * @param params.sourceY - The y position of the source handle\n * @param params.targetX - The x position of the target handle\n * @param params.targetY - The y position of the target handle\n * @returns A path string you can use in an SVG, the labelX and labelY position (center of path) and offsetX, offsetY between source handle and label\n * @example\n *  const source = { x: 0, y: 20 };\n    const target = { x: 150, y: 100 };\n    \n    const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({\n      sourceX: source.x,\n      sourceY: source.y,\n      sourcePosition: Position.Right,\n      targetX: target.x,\n      targetY: target.y,\n      targetPosition: Position.Left,\n    });\n */\nfunction getStraightPath({ sourceX, sourceY, targetX, targetY, }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n    });\n    return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];\n}\n\nconst handleDirections = {\n    [Position.Left]: { x: -1, y: 0 },\n    [Position.Right]: { x: 1, y: 0 },\n    [Position.Top]: { x: 0, y: -1 },\n    [Position.Bottom]: { x: 0, y: 1 },\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target, }) => {\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };\n    }\n    return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };\n};\nconst distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n// ith this function we try to mimic a orthogonal edge routing behaviour\n// It's not as good as a real orthogonal edge routing but it's faster and good enough as a default for step and smooth step edges\nfunction getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };\n    const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped,\n    });\n    const dirAccessor = dir.x !== 0 ? 'x' : 'y';\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = { x: 0, y: 0 };\n    const targetGapOffset = { x: 0, y: 0 };\n    const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        centerX = center.x ?? defaultCenterX;\n        centerY = center.y ?? defaultCenterY;\n        //    --->\n        //    |\n        // >---\n        const verticalSplit = [\n            { x: centerX, y: sourceGapped.y },\n            { x: centerX, y: targetGapped.y },\n        ];\n        //    |\n        //  ---\n        //  |\n        const horizontalSplit = [\n            { x: sourceGapped.x, y: centerY },\n            { x: targetGapped.x, y: centerY },\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;\n        }\n        else {\n            points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;\n        }\n    }\n    else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];\n        const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];\n        // this handles edges with same handle positions\n        if (dirAccessor === 'x') {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        }\n        else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n                else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = (sourceDir[dirAccessor] === 1 && ((!isSameDir && sourceGtTargetOppo) || (isSameDir && sourceLtTargetOppo))) ||\n                (sourceDir[dirAccessor] !== 1 && ((!isSameDir && sourceLtTargetOppo) || (isSameDir && sourceGtTargetOppo)));\n            if (flipSourceTarget) {\n                points = dirAccessor === 'x' ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };\n        const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        }\n        else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },\n        ...points,\n        { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },\n        target,\n    ];\n    return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if ((a.x === x && x === c.x) || (a.y === y && y === c.y)) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\n/**\n * Get a smooth step path from source to target handle\n * @param params.sourceX - The x position of the source handle\n * @param params.sourceY - The y position of the source handle\n * @param params.sourcePosition - The position of the source handle (default: Position.Bottom)\n * @param params.targetX - The x position of the target handle\n * @param params.targetY - The y position of the target handle\n * @param params.targetPosition - The position of the target handle (default: Position.Top)\n * @returns A path string you can use in an SVG, the labelX and labelY position (center of path) and offsetX, offsetY between source handle and label\n * @example\n *  const source = { x: 0, y: 20 };\n    const target = { x: 150, y: 100 };\n    \n    const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({\n      sourceX: source.x,\n      sourceY: source.y,\n      sourcePosition: Position.Right,\n      targetX: target.x,\n      targetY: target.y,\n      targetPosition: Position.Left,\n    });\n */\nfunction getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: { x: sourceX, y: sourceY },\n        sourcePosition,\n        target: { x: targetX, y: targetY },\n        targetPosition,\n        center: { x: centerX, y: centerY },\n        offset,\n    });\n    const path = points.reduce((res, p, i) => {\n        let segment = '';\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        }\n        else {\n            segment = `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, '');\n    return [path, labelX, labelY, offsetX, offsetY];\n}\n\nfunction isNodeInitialized(node) {\n    return (node &&\n        !!(node.internals.handleBounds || node.handles?.length) &&\n        !!(node.measured.width || node.width || node.initialWidth));\n}\nfunction getEdgePosition(params) {\n    const { sourceNode, targetNode } = params;\n    if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {\n        return null;\n    }\n    const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);\n    const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);\n    const sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle);\n    const targetHandle = getHandle$1(\n    // when connection type is loose we can define all handles as sources and connect source -> source\n    params.connectionMode === ConnectionMode.Strict\n        ? targetHandleBounds?.target ?? []\n        : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []), params.targetHandle);\n    if (!sourceHandle || !targetHandle) {\n        params.onError?.('008', errorMessages['error008'](!sourceHandle ? 'source' : 'target', {\n            id: params.id,\n            sourceHandle: params.sourceHandle,\n            targetHandle: params.targetHandle,\n        }));\n        return null;\n    }\n    const sourcePosition = sourceHandle?.position || Position.Bottom;\n    const targetPosition = targetHandle?.position || Position.Top;\n    const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);\n    const target = getHandlePosition(targetNode, targetHandle, targetPosition);\n    return {\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n        sourcePosition,\n        targetPosition,\n    };\n}\nfunction toHandleBounds(handles) {\n    if (!handles) {\n        return null;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of handles) {\n        handle.width = handle.width ?? 1;\n        handle.height = handle.height ?? 1;\n        if (handle.type === 'source') {\n            source.push(handle);\n        }\n        else if (handle.type === 'target') {\n            target.push(handle);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {\n    const x = (handle?.x ?? 0) + node.internals.positionAbsolute.x;\n    const y = (handle?.y ?? 0) + node.internals.positionAbsolute.y;\n    const { width, height } = handle ?? getNodeDimensions(node);\n    if (center) {\n        return { x: x + width / 2, y: y + height / 2 };\n    }\n    const position = handle?.position ?? fallbackPosition;\n    switch (position) {\n        case Position.Top:\n            return { x: x + width / 2, y };\n        case Position.Right:\n            return { x: x + width, y: y + height / 2 };\n        case Position.Bottom:\n            return { x: x + width / 2, y: y + height };\n        case Position.Left:\n            return { x, y: y + height / 2 };\n    }\n}\nfunction getHandle$1(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    // if no handleId is given, we use the first handle, otherwise we check for the id\n    return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;\n}\n\nfunction getMarkerId(marker, id) {\n    if (!marker) {\n        return '';\n    }\n    if (typeof marker === 'string') {\n        return marker;\n    }\n    const idPrefix = id ? `${id}__` : '';\n    return `${idPrefix}${Object.keys(marker)\n        .sort()\n        .map((key) => `${key}=${marker[key]}`)\n        .join('&')}`;\n}\nfunction createMarkerIds(edges, { id, defaultColor, defaultMarkerStart, defaultMarkerEnd, }) {\n    const ids = new Set();\n    return edges\n        .reduce((markers, edge) => {\n        [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {\n            if (marker && typeof marker === 'object') {\n                const markerId = getMarkerId(marker, id);\n                if (!ids.has(markerId)) {\n                    markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });\n                    ids.add(markerId);\n                }\n            }\n        });\n        return markers;\n    }, [])\n        .sort((a, b) => a.id.localeCompare(b.id));\n}\n\nfunction getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {\n    let alignmentOffset = 0.5;\n    if (align === 'start') {\n        alignmentOffset = 0;\n    }\n    else if (align === 'end') {\n        alignmentOffset = 1;\n    }\n    // position === Position.Top\n    // we set the x any y position of the toolbar based on the nodes position\n    let pos = [\n        (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,\n        nodeRect.y * viewport.zoom + viewport.y - offset,\n    ];\n    // and than shift it based on the alignment. The shift values are in %.\n    let shift = [-100 * alignmentOffset, -100];\n    switch (position) {\n        case Position.Right:\n            pos = [\n                (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [0, -100 * alignmentOffset];\n            break;\n        case Position.Bottom:\n            pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;\n            shift[1] = 0;\n            break;\n        case Position.Left:\n            pos = [\n                nodeRect.x * viewport.zoom + viewport.x - offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [-100, -100 * alignmentOffset];\n            break;\n    }\n    return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\n\nconst defaultOptions = {\n    nodeOrigin: [0, 0],\n    nodeExtent: infiniteExtent,\n    elevateNodesOnSelect: true,\n    defaults: {},\n};\nconst adoptUserNodesDefaultOptions = {\n    ...defaultOptions,\n    checkEquality: true,\n};\nfunction mergeObjects(base, incoming) {\n    const result = { ...base };\n    for (const key in incoming) {\n        if (incoming[key] !== undefined) {\n            // typecast is safe here, because we check for undefined\n            result[key] = incoming[key];\n        }\n    }\n    return result;\n}\nfunction updateAbsolutePositions(nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(defaultOptions, options);\n    for (const node of nodeLookup.values()) {\n        if (node.parentId) {\n            updateChildNode(node, nodeLookup, parentLookup, _options);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);\n            const extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));\n            node.internals.positionAbsolute = clampedPosition;\n        }\n    }\n}\nfunction adoptUserNodes(nodes, nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(adoptUserNodesDefaultOptions, options);\n    const tmpLookup = new Map(nodeLookup);\n    const selectedNodeZ = _options?.elevateNodesOnSelect ? 1000 : 0;\n    nodeLookup.clear();\n    parentLookup.clear();\n    for (const userNode of nodes) {\n        let internalNode = tmpLookup.get(userNode.id);\n        if (_options.checkEquality && userNode === internalNode?.internals.userNode) {\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);\n            const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));\n            internalNode = {\n                ..._options.defaults,\n                ...userNode,\n                measured: {\n                    width: userNode.measured?.width,\n                    height: userNode.measured?.height,\n                },\n                internals: {\n                    positionAbsolute: clampedPosition,\n                    // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured\n                    handleBounds: !userNode.measured ? undefined : internalNode?.internals.handleBounds,\n                    z: calculateZ(userNode, selectedNodeZ),\n                    userNode,\n                },\n            };\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        if (userNode.parentId) {\n            updateChildNode(internalNode, nodeLookup, parentLookup, options);\n        }\n    }\n}\nfunction updateParentLookup(node, parentLookup) {\n    if (!node.parentId) {\n        return;\n    }\n    const childNodes = parentLookup.get(node.parentId);\n    if (childNodes) {\n        childNodes.set(node.id, node);\n    }\n    else {\n        parentLookup.set(node.parentId, new Map([[node.id, node]]));\n    }\n}\n/**\n * Updates positionAbsolute and zIndex of a child node and the parentLookup.\n */\nfunction updateChildNode(node, nodeLookup, parentLookup, options) {\n    const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options);\n    const parentId = node.parentId;\n    const parentNode = nodeLookup.get(parentId);\n    if (!parentNode) {\n        console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);\n        return;\n    }\n    updateParentLookup(node, parentLookup);\n    const selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;\n    const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ);\n    const { positionAbsolute } = node.internals;\n    const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;\n    if (positionChanged || z !== node.internals.z) {\n        // we create a new object to mark the node as updated\n        nodeLookup.set(node.id, {\n            ...node,\n            internals: {\n                ...node.internals,\n                positionAbsolute: positionChanged ? { x, y } : positionAbsolute,\n                z,\n            },\n        });\n    }\n}\nfunction calculateZ(node, selectedNodeZ) {\n    return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);\n}\nfunction calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {\n    const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;\n    const childDimensions = getNodeDimensions(childNode);\n    const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);\n    const clampedPosition = isCoordinateExtent(childNode.extent)\n        ? clampPosition(positionWithOrigin, childNode.extent, childDimensions)\n        : positionWithOrigin;\n    let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);\n    if (childNode.extent === 'parent') {\n        absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);\n    }\n    const childZ = calculateZ(childNode, selectedNodeZ);\n    const parentZ = parentNode.internals.z ?? 0;\n    return {\n        x: absolutePosition.x,\n        y: absolutePosition.y,\n        z: parentZ > childZ ? parentZ : childZ,\n    };\n}\nfunction handleExpandParent(children, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {\n    const changes = [];\n    const parentExpansions = new Map();\n    // determine the expanded rectangle the child nodes would take for each parent\n    for (const child of children) {\n        const parent = nodeLookup.get(child.parentId);\n        if (!parent) {\n            continue;\n        }\n        const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent);\n        const expandedRect = getBoundsOfRects(parentRect, child.rect);\n        parentExpansions.set(child.parentId, { expandedRect, parent });\n    }\n    if (parentExpansions.size > 0) {\n        parentExpansions.forEach(({ expandedRect, parent }, parentId) => {\n            // determine the position & dimensions of the parent\n            const positionAbsolute = parent.internals.positionAbsolute;\n            const dimensions = getNodeDimensions(parent);\n            const origin = parent.origin ?? nodeOrigin;\n            // determine how much the parent expands in width and position\n            const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;\n            const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;\n            const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));\n            const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));\n            const widthChange = (newWidth - dimensions.width) * origin[0];\n            const heightChange = (newHeight - dimensions.height) * origin[1];\n            // We need to correct the position of the parent node if the origin is not [0,0]\n            if (xChange > 0 || yChange > 0 || widthChange || heightChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'position',\n                    position: {\n                        x: parent.position.x - xChange + widthChange,\n                        y: parent.position.y - yChange + heightChange,\n                    },\n                });\n                // We move all child nodes in the oppsite direction\n                // so the x,y changes of the parent do not move the children\n                parentLookup.get(parentId)?.forEach((childNode) => {\n                    if (!children.some((child) => child.id === childNode.id)) {\n                        changes.push({\n                            id: childNode.id,\n                            type: 'position',\n                            position: {\n                                x: childNode.position.x + xChange,\n                                y: childNode.position.y + yChange,\n                            },\n                        });\n                    }\n                });\n            }\n            // We need to correct the dimensions of the parent node if the origin is not [0,0]\n            if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'dimensions',\n                    setAttributes: true,\n                    dimensions: {\n                        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),\n                        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0),\n                    },\n                });\n            }\n        });\n    }\n    return changes;\n}\nfunction updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {\n    const viewportNode = domNode?.querySelector('.xyflow__viewport');\n    let updatedInternals = false;\n    if (!viewportNode) {\n        return { changes: [], updatedInternals };\n    }\n    const changes = [];\n    const style = window.getComputedStyle(viewportNode);\n    const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n    // in this array we collect nodes, that might trigger changes (like expanding parent)\n    const parentExpandChildren = [];\n    for (const update of updates.values()) {\n        const node = nodeLookup.get(update.id);\n        if (!node) {\n            continue;\n        }\n        if (node.hidden) {\n            nodeLookup.set(node.id, {\n                ...node,\n                internals: {\n                    ...node.internals,\n                    handleBounds: undefined,\n                },\n            });\n            updatedInternals = true;\n            continue;\n        }\n        const dimensions = getDimensions(update.nodeElement);\n        const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;\n        const doUpdate = !!(dimensions.width &&\n            dimensions.height &&\n            (dimensionChanged || !node.internals.handleBounds || update.force));\n        if (doUpdate) {\n            const nodeBounds = update.nodeElement.getBoundingClientRect();\n            const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;\n            let { positionAbsolute } = node.internals;\n            if (node.parentId && node.extent === 'parent') {\n                positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));\n            }\n            else if (extent) {\n                positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);\n            }\n            const newNode = {\n                ...node,\n                measured: dimensions,\n                internals: {\n                    ...node.internals,\n                    positionAbsolute,\n                    handleBounds: {\n                        source: getHandleBounds('source', update.nodeElement, nodeBounds, zoom, node.id),\n                        target: getHandleBounds('target', update.nodeElement, nodeBounds, zoom, node.id),\n                    },\n                },\n            };\n            nodeLookup.set(node.id, newNode);\n            if (node.parentId) {\n                updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin });\n            }\n            updatedInternals = true;\n            if (dimensionChanged) {\n                changes.push({\n                    id: node.id,\n                    type: 'dimensions',\n                    dimensions,\n                });\n                if (node.expandParent && node.parentId) {\n                    parentExpandChildren.push({\n                        id: node.id,\n                        parentId: node.parentId,\n                        rect: nodeToRect(newNode, nodeOrigin),\n                    });\n                }\n            }\n        }\n    }\n    if (parentExpandChildren.length > 0) {\n        const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n        changes.push(...parentExpandChanges);\n    }\n    return { changes, updatedInternals };\n}\nasync function panBy({ delta, panZoom, transform, translateExtent, width, height, }) {\n    if (!panZoom || (!delta.x && !delta.y)) {\n        return Promise.resolve(false);\n    }\n    const nextViewport = await panZoom.setViewportConstrained({\n        x: transform[0] + delta.x,\n        y: transform[1] + delta.y,\n        zoom: transform[2],\n    }, [\n        [0, 0],\n        [width, height],\n    ], translateExtent);\n    const transformChanged = !!nextViewport &&\n        (nextViewport.x !== transform[0] || nextViewport.y !== transform[1] || nextViewport.k !== transform[2]);\n    return Promise.resolve(transformChanged);\n}\n/**\n * this function adds the connection to the connectionLookup\n * at the following keys: nodeId-type-handleId, nodeId-type and nodeId\n * @param type type of the connection\n * @param connection connection that should be added to the lookup\n * @param connectionKey at which key the connection should be added\n * @param connectionLookup reference to the connection lookup\n * @param nodeId nodeId of the connection\n * @param handleId handleId of the conneciton\n */\nfunction addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {\n    // We add the connection to the connectionLookup at the following keys\n    // 1. nodeId, 2. nodeId-type, 3. nodeId-type-handleId\n    // If the key already exists, we add the connection to the existing map\n    let key = nodeId;\n    const nodeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, nodeMap.set(connectionKey, connection));\n    key = `${nodeId}-${type}`;\n    const typeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, typeMap.set(connectionKey, connection));\n    if (handleId) {\n        key = `${nodeId}-${type}-${handleId}`;\n        const handleMap = connectionLookup.get(key) || new Map();\n        connectionLookup.set(key, handleMap.set(connectionKey, connection));\n    }\n}\nfunction updateConnectionLookup(connectionLookup, edgeLookup, edges) {\n    connectionLookup.clear();\n    edgeLookup.clear();\n    for (const edge of edges) {\n        const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge;\n        const connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle };\n        const sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;\n        const targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;\n        addConnectionToLookup('source', connection, targetKey, connectionLookup, sourceNode, sourceHandle);\n        addConnectionToLookup('target', connection, sourceKey, connectionLookup, targetNode, targetHandle);\n        edgeLookup.set(edge.id, edge);\n    }\n}\n\nfunction shallowNodeData(a, b) {\n    if (a === null || b === null) {\n        return false;\n    }\n    const _a = Array.isArray(a) ? a : [a];\n    const _b = Array.isArray(b) ? b : [b];\n    if (_a.length !== _b.length) {\n        return false;\n    }\n    for (let i = 0; i < _a.length; i++) {\n        if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isParentSelected(node, nodeLookup) {\n    if (!node.parentId) {\n        return false;\n    }\n    const parentNode = nodeLookup.get(node.parentId);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeLookup);\n}\nfunction hasSelector(target, selector, domNode) {\n    let current = target;\n    do {\n        if (current?.matches?.(selector))\n            return true;\n        if (current === domNode)\n            return false;\n        current = current?.parentElement;\n    } while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {\n    const dragItems = new Map();\n    for (const [id, node] of nodeLookup) {\n        if ((node.selected || node.id === nodeId) &&\n            (!node.parentId || !isParentSelected(node, nodeLookup)) &&\n            (node.draggable || (nodesDraggable && typeof node.draggable === 'undefined'))) {\n            const internalNode = nodeLookup.get(id);\n            if (internalNode) {\n                dragItems.set(id, {\n                    id,\n                    position: internalNode.position || { x: 0, y: 0 },\n                    distance: {\n                        x: mousePos.x - internalNode.internals.positionAbsolute.x,\n                        y: mousePos.y - internalNode.internals.positionAbsolute.y,\n                    },\n                    extent: internalNode.extent,\n                    parentId: internalNode.parentId,\n                    origin: internalNode.origin,\n                    expandParent: internalNode.expandParent,\n                    internals: {\n                        positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 },\n                    },\n                    measured: {\n                        width: internalNode.measured.width ?? 0,\n                        height: internalNode.measured.height ?? 0,\n                    },\n                });\n            }\n        }\n    }\n    return dragItems;\n}\n// returns two params:\n// 1. the dragged node (or the first of the list, if we are dragging a node selection)\n// 2. array of selected nodes (for multi selections)\nfunction getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true, }) {\n    const nodesFromDragItems = [];\n    for (const [id, dragItem] of dragItems) {\n        const node = nodeLookup.get(id)?.internals.userNode;\n        if (node) {\n            nodesFromDragItems.push({\n                ...node,\n                position: dragItem.position,\n                dragging,\n            });\n        }\n    }\n    if (!nodeId) {\n        return [nodesFromDragItems[0], nodesFromDragItems];\n    }\n    const node = nodeLookup.get(nodeId)?.internals.userNode;\n    return [\n        !node\n            ? nodesFromDragItems[0]\n            : {\n                ...node,\n                position: dragItems.get(nodeId)?.position || node.position,\n                dragging,\n            },\n        nodesFromDragItems,\n    ];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop, }) {\n    let lastPos = { x: null, y: null };\n    let autoPanId = 0;\n    let dragItems = new Map();\n    let autoPanStarted = false;\n    let mousePosition = { x: 0, y: 0 };\n    let containerBounds = null;\n    let dragStarted = false;\n    let d3Selection = null;\n    let abortDrag = false; // prevents unintentional dragging on multitouch\n    // public functions\n    function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0, }) {\n        d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n        function updateNodes({ x, y }, dragEvent) {\n            const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions, } = getStoreItems();\n            lastPos = { x, y };\n            let hasChange = false;\n            let nodesBox = { x: 0, y: 0, x2: 0, y2: 0 };\n            if (dragItems.size > 1 && nodeExtent) {\n                const rect = getInternalNodesBounds(dragItems);\n                nodesBox = rectToBox(rect);\n            }\n            for (const [id, dragItem] of dragItems) {\n                if (!nodeLookup.has(id)) {\n                    // if the node is not in the nodeLookup anymore, it was probably deleted while dragging\n                    // and we don't need to update it anymore\n                    continue;\n                }\n                let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };\n                if (snapToGrid) {\n                    nextPosition = snapPosition(nextPosition, snapGrid);\n                }\n                // if there is selection with multiple nodes and a node extent is set, we need to adjust the node extent for each node\n                // based on its position so that the node stays at it's position relative to the selection.\n                let adjustedNodeExtent = [\n                    [nodeExtent[0][0], nodeExtent[0][1]],\n                    [nodeExtent[1][0], nodeExtent[1][1]],\n                ];\n                if (dragItems.size > 1 && nodeExtent && !dragItem.extent) {\n                    const { positionAbsolute } = dragItem.internals;\n                    const x1 = positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                    const x2 = positionAbsolute.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];\n                    const y1 = positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                    const y2 = positionAbsolute.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];\n                    adjustedNodeExtent = [\n                        [x1, y1],\n                        [x2, y2],\n                    ];\n                }\n                const { position, positionAbsolute } = calculateNodePosition({\n                    nodeId: id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent: adjustedNodeExtent,\n                    nodeOrigin,\n                    onError,\n                });\n                // we want to make sure that we only fire a change event when there is a change\n                hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;\n                dragItem.position = position;\n                dragItem.internals.positionAbsolute = positionAbsolute;\n            }\n            if (!hasChange) {\n                return;\n            }\n            updateNodePositions(dragItems, true);\n            if (dragEvent && (onDrag || onNodeDrag || (!nodeId && onSelectionDrag))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDrag?.(dragEvent, dragItems, currentNode, currentNodes);\n                onNodeDrag?.(dragEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDrag?.(dragEvent, currentNodes);\n                }\n            }\n        }\n        async function autoPan() {\n            if (!containerBounds) {\n                return;\n            }\n            const { transform, panBy, autoPanSpeed } = getStoreItems();\n            const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);\n            if (xMovement !== 0 || yMovement !== 0) {\n                lastPos.x = (lastPos.x ?? 0) - xMovement / transform[2];\n                lastPos.y = (lastPos.y ?? 0) - yMovement / transform[2];\n                if (await panBy({ x: xMovement, y: yMovement })) {\n                    updateNodes(lastPos, null);\n                }\n            }\n            autoPanId = requestAnimationFrame(autoPan);\n        }\n        function startDrag(event) {\n            const { nodeLookup, multiSelectionActive, nodesDraggable, transform, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges, } = getStoreItems();\n            dragStarted = true;\n            if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                if (!nodeLookup.get(nodeId)?.selected) {\n                    // we need to reset selected nodes when selectNodesOnDrag=false\n                    unselectNodesAndEdges();\n                }\n            }\n            if (isSelectable && selectNodesOnDrag && nodeId) {\n                onNodeMouseDown?.(nodeId);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);\n            if (dragItems.size > 0 && (onDragStart || onNodeDragStart || (!nodeId && onSelectionDragStart))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDragStart?.(event.sourceEvent, currentNodes);\n                }\n            }\n        }\n        const d3DragInstance = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .clickDistance(nodeClickDistance)\n            .on('start', (event) => {\n            const { domNode, nodeDragThreshold, transform, snapGrid, snapToGrid } = getStoreItems();\n            containerBounds = domNode?.getBoundingClientRect() || null;\n            abortDrag = false;\n            if (nodeDragThreshold === 0) {\n                startDrag(event);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n        })\n            .on('drag', (event) => {\n            const { autoPanOnNodeDrag, transform, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems();\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            if ((event.sourceEvent.type === 'touchmove' && event.sourceEvent.touches.length > 1) ||\n                // if user deletes a node while dragging, we need to abort the drag to prevent errors\n                (nodeId && !nodeLookup.has(nodeId))) {\n                abortDrag = true;\n            }\n            if (abortDrag) {\n                return;\n            }\n            if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {\n                autoPanStarted = true;\n                autoPan();\n            }\n            if (!dragStarted) {\n                const x = pointerPos.xSnapped - (lastPos.x ?? 0);\n                const y = pointerPos.ySnapped - (lastPos.y ?? 0);\n                const distance = Math.sqrt(x * x + y * y);\n                if (distance > nodeDragThreshold) {\n                    startDrag(event);\n                }\n            }\n            // skip events without movement\n            if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {\n                // dragEvent = event.sourceEvent as MouseEvent;\n                mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                updateNodes(pointerPos, event.sourceEvent);\n            }\n        })\n            .on('end', (event) => {\n            if (!dragStarted || abortDrag) {\n                return;\n            }\n            autoPanStarted = false;\n            dragStarted = false;\n            cancelAnimationFrame(autoPanId);\n            if (dragItems.size > 0) {\n                const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();\n                updateNodePositions(dragItems, false);\n                if (onDragStop || onNodeDragStop || (!nodeId && onSelectionDragStop)) {\n                    const [currentNode, currentNodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems,\n                        nodeLookup,\n                        dragging: false,\n                    });\n                    onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                    onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes);\n                    if (!nodeId) {\n                        onSelectionDragStop?.(event.sourceEvent, currentNodes);\n                    }\n                }\n            }\n        })\n            .filter((event) => {\n            const target = event.target;\n            const isDraggable = !event.button &&\n                (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) &&\n                (!handleSelector || hasSelector(target, handleSelector, domNode));\n            return isDraggable;\n        });\n        d3Selection.call(d3DragInstance);\n    }\n    function destroy() {\n        d3Selection?.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\nfunction getNodesWithinDistance(position, nodeLookup, distance) {\n    const nodes = [];\n    const rect = {\n        x: position.x - distance,\n        y: position.y - distance,\n        width: distance * 2,\n        height: distance * 2,\n    };\n    for (const node of nodeLookup.values()) {\n        if (getOverlappingArea(rect, nodeToRect(node)) > 0) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n// this distance is used for the area around the user pointer\n// while doing a connection for finding the closest nodes\nconst ADDITIONAL_DISTANCE = 250;\nfunction getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {\n    let closestHandles = [];\n    let minDistance = Infinity;\n    const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);\n    for (const node of closeNodes) {\n        const allHandles = [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n        for (const handle of allHandles) {\n            // if the handle is the same as the fromHandle we skip it\n            if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {\n                continue;\n            }\n            // determine absolute position of the handle\n            const { x, y } = getHandlePosition(node, handle, handle.position, true);\n            const distance = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));\n            if (distance > connectionRadius) {\n                continue;\n            }\n            if (distance < minDistance) {\n                closestHandles = [{ ...handle, x, y }];\n                minDistance = distance;\n            }\n            else if (distance === minDistance) {\n                // when multiple handles are on the same distance we collect all of them\n                closestHandles.push({ ...handle, x, y });\n            }\n        }\n    }\n    if (!closestHandles.length) {\n        return null;\n    }\n    // when multiple handles overlay each other we prefer the opposite handle\n    if (closestHandles.length > 1) {\n        const oppositeHandleType = fromHandle.type === 'source' ? 'target' : 'source';\n        return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];\n    }\n    return closestHandles[0];\n}\nfunction getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {\n    const node = nodeLookup.get(nodeId);\n    if (!node) {\n        return null;\n    }\n    const handles = connectionMode === 'strict'\n        ? node.internals.handleBounds?.[handleType]\n        : [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n    const handle = (handleId ? handles?.find((h) => h.id === handleId) : handles?.[0]) ?? null;\n    return handle && withAbsolutePosition\n        ? { ...handle, ...getHandlePosition(node, handle, handle.position, true) }\n        : handle;\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    }\n    else if (handleDomNode?.classList.contains('target')) {\n        return 'target';\n    }\n    else if (handleDomNode?.classList.contains('source')) {\n        return 'source';\n    }\n    return null;\n}\nfunction isConnectionValid(isInsideConnectionRadius, isHandleValid) {\n    let isValid = null;\n    if (isHandleValid) {\n        isValid = true;\n    }\n    else if (isInsideConnectionRadius && !isHandleValid) {\n        isValid = false;\n    }\n    return isValid;\n}\n\nconst alwaysValid = () => true;\nfunction onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, }) {\n    // when xyflow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const clickedHandle = doc?.elementFromPoint(x, y);\n    const handleType = getHandleType(edgeUpdaterType, clickedHandle);\n    const containerBounds = domNode?.getBoundingClientRect();\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);\n    if (!fromHandleInternal) {\n        return;\n    }\n    let position = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let handleDomNode = null;\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    function autoPan() {\n        if (!autoPanOnConnect || !containerBounds) {\n            return;\n        }\n        const [x, y] = calcAutoPan(position, containerBounds, autoPanSpeed);\n        panBy({ x, y });\n        autoPanId = requestAnimationFrame(autoPan);\n    }\n    // Stays the same for all consecutive pointermove events\n    const fromHandle = {\n        ...fromHandleInternal,\n        nodeId,\n        type: handleType,\n        position: fromHandleInternal.position,\n    };\n    const fromNodeInternal = nodeLookup.get(nodeId);\n    const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);\n    const newConnection = {\n        inProgress: true,\n        isValid: null,\n        from,\n        fromHandle,\n        fromPosition: fromHandle.position,\n        fromNode: fromNodeInternal,\n        to: position,\n        toHandle: null,\n        toPosition: oppositePosition[fromHandle.position],\n        toNode: null,\n    };\n    updateConnection(newConnection);\n    let previousConnection = newConnection;\n    onConnectStart?.(event, { nodeId, handleId, handleType });\n    function onPointerMove(event) {\n        if (!getFromHandle() || !fromHandle) {\n            onPointerUp(event);\n            return;\n        }\n        const transform = getTransform();\n        position = getEventPosition(event, containerBounds);\n        closestHandle = getClosestHandle(pointToRendererPoint(position, transform, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        const result = isValidHandle(event, {\n            handle: closestHandle,\n            connectionMode,\n            fromNodeId: nodeId,\n            fromHandleId: handleId,\n            fromType: isTarget ? 'target' : 'source',\n            isValidConnection,\n            doc,\n            lib,\n            flowId,\n            nodeLookup,\n        });\n        handleDomNode = result.handleDomNode;\n        connection = result.connection;\n        isValid = isConnectionValid(!!closestHandle, result.isValid);\n        const newConnection = {\n            // from stays the same\n            ...previousConnection,\n            isValid,\n            to: closestHandle && isValid\n                ? rendererPointToPoint({ x: closestHandle.x, y: closestHandle.y }, transform)\n                : position,\n            toHandle: result.toHandle,\n            toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],\n            toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null,\n        };\n        // we don't want to trigger an update when the connection\n        // is snapped to the same handle as before\n        if (isValid &&\n            closestHandle &&\n            previousConnection.toHandle &&\n            newConnection.toHandle &&\n            previousConnection.toHandle.type === newConnection.toHandle.type &&\n            previousConnection.toHandle.nodeId === newConnection.toHandle.nodeId &&\n            previousConnection.toHandle.id === newConnection.toHandle.id &&\n            previousConnection.to.x === newConnection.to.x &&\n            previousConnection.to.y === newConnection.to.y) {\n            return;\n        }\n        updateConnection(newConnection);\n        previousConnection = newConnection;\n    }\n    function onPointerUp(event) {\n        if ((closestHandle || handleDomNode) && connection && isValid) {\n            onConnect?.(connection);\n        }\n        // it's important to get a fresh reference from the store here\n        // in order to get the latest state of onConnectEnd\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { inProgress, ...connectionState } = previousConnection;\n        const finalConnectionState = {\n            ...connectionState,\n            toPosition: previousConnection.toHandle ? previousConnection.toPosition : null,\n        };\n        onConnectEnd?.(event, finalConnectionState);\n        if (edgeUpdaterType) {\n            onReconnectEnd?.(event, finalConnectionState);\n        }\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        handleDomNode = null;\n        doc.removeEventListener('mousemove', onPointerMove);\n        doc.removeEventListener('mouseup', onPointerUp);\n        doc.removeEventListener('touchmove', onPointerMove);\n        doc.removeEventListener('touchend', onPointerUp);\n    }\n    doc.addEventListener('mousemove', onPointerMove);\n    doc.addEventListener('mouseup', onPointerUp);\n    doc.addEventListener('touchmove', onPointerMove);\n    doc.addEventListener('touchend', onPointerUp);\n}\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup, }) {\n    const isTarget = fromType === 'target';\n    const handleDomNode = handle\n        ? doc.querySelector(`.${lib}-flow__handle[data-id=\"${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`)\n        : null;\n    const { x, y } = getEventPosition(event);\n    const handleBelow = doc.elementFromPoint(x, y);\n    // we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n    // because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n    const handleToCheck = handleBelow?.classList.contains(`${lib}-flow__handle`) ? handleBelow : handleDomNode;\n    const result = {\n        handleDomNode: handleToCheck,\n        isValid: false,\n        connection: null,\n        toHandle: null,\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute('data-nodeid');\n        const handleId = handleToCheck.getAttribute('data-handleid');\n        const connectable = handleToCheck.classList.contains('connectable');\n        const connectableEnd = handleToCheck.classList.contains('connectableend');\n        if (!handleNodeId || !handleType) {\n            return result;\n        }\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId,\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable &&\n            (connectionMode === ConnectionMode.Strict\n                ? (isTarget && handleType === 'source') || (!isTarget && handleType === 'target')\n                : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        result.isValid = isValid && isValidConnection(connection);\n        result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, false);\n    }\n    return result;\n}\nconst XYHandle = {\n    onPointerDown,\n    isValid: isValidHandle,\n};\n\nfunction XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ translateExtent, width, height, zoomStep = 10, pannable = true, zoomable = true, inversePan = false, }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const zoomHandler = (event) => {\n            const transform = getTransform();\n            if (event.sourceEvent.type !== 'wheel' || !panZoom) {\n                return;\n            }\n            const pinchDelta = -event.sourceEvent.deltaY *\n                (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) *\n                zoomStep;\n            const nextZoom = transform[2] * Math.pow(2, pinchDelta);\n            panZoom.scaleTo(nextZoom);\n        };\n        let panStart = [0, 0];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panStartHandler = (event) => {\n            if (event.sourceEvent.type === 'mousedown' || event.sourceEvent.type === 'touchstart') {\n                panStart = [\n                    event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                    event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n                ];\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panHandler = (event) => {\n            const transform = getTransform();\n            if ((event.sourceEvent.type !== 'mousemove' && event.sourceEvent.type !== 'touchmove') || !panZoom) {\n                return;\n            }\n            const panCurrent = [\n                event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n            ];\n            const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];\n            panStart = panCurrent;\n            const moveScale = getViewScale() * Math.max(transform[2], Math.log(transform[2])) * (inversePan ? -1 : 1);\n            const position = {\n                x: transform[0] - panDelta[0] * moveScale,\n                y: transform[1] - panDelta[1] * moveScale,\n            };\n            const extent = [\n                [0, 0],\n                [width, height],\n            ];\n            panZoom.setViewportConstrained({\n                x: position.x,\n                y: position.y,\n                zoom: transform[2],\n            }, extent, translateExtent);\n        };\n        const zoomAndPanHandler = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n            .on('start', panStartHandler)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom', pannable ? panHandler : null)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom.wheel', zoomable ? zoomHandler : null);\n        selection.call(zoomAndPanHandler, {});\n    }\n    function destroy() {\n        selection.on('zoom', null);\n    }\n    return {\n        update,\n        destroy,\n        pointer: d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;\nconst transformToViewport = (transform) => ({\n    x: transform.x,\n    y: transform.y,\n    zoom: transform.k,\n});\nconst viewportToTransform = ({ x, y, zoom }) => d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity.translate(x, y).scale(zoom);\nconst isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\nconst getD3Transition = (selection, duration = 0, onEnd = () => { }) => {\n    const hasDuration = typeof duration === 'number' && duration > 0;\n    if (!hasDuration) {\n        onEnd();\n    }\n    return hasDuration ? selection.transition().duration(duration).on('end', onEnd) : selection;\n};\nconst wheelDelta = (event) => {\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\n\nfunction createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd, }) {\n    return (event) => {\n        if (isWrappedWithClass(event, noWheelClassName)) {\n            return false;\n        }\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        const currentZoom = d3Selection.property('__zoom').k || 1;\n        // macos sets ctrlKey=true for pinch gesture on a trackpad\n        if (event.ctrlKey && zoomOnPinch) {\n            const point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(event);\n            const pinchDelta = wheelDelta(event);\n            const zoom = currentZoom * Math.pow(2, pinchDelta);\n            // @ts-ignore\n            d3Zoom.scaleTo(d3Selection, zoom, point, event);\n            return;\n        }\n        // increase scroll speed in firefox\n        // firefox: deltaMode === 1; chrome: deltaMode === 0\n        const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n        let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n        let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n        // this enables vertical scrolling with shift + scroll on windows\n        if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n            deltaX = event.deltaY * deltaNormalize;\n            deltaY = 0;\n        }\n        d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, \n        // @ts-ignore\n        { internal: true });\n        const nextViewport = transformToViewport(d3Selection.property('__zoom'));\n        clearTimeout(zoomPanValues.panScrollTimeout);\n        // for pan on scroll we need to handle the event calls on our own\n        // we can't use the start, zoom and end events from d3-zoom\n        // because start and move gets called on every scroll event and not once at the beginning\n        if (!zoomPanValues.isPanScrolling) {\n            zoomPanValues.isPanScrolling = true;\n            onPanZoomStart?.(event, nextViewport);\n        }\n        if (zoomPanValues.isPanScrolling) {\n            onPanZoom?.(event, nextViewport);\n            zoomPanValues.panScrollTimeout = setTimeout(() => {\n                onPanZoomEnd?.(event, nextViewport);\n                zoomPanValues.isPanScrolling = false;\n            }, 150);\n        }\n    };\n}\nfunction createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {\n    return function (event, d) {\n        // we still want to enable pinch zooming even if preventScrolling is set to false\n        const preventZoom = !preventScrolling && event.type === 'wheel' && !event.ctrlKey;\n        if (preventZoom || isWrappedWithClass(event, noWheelClassName)) {\n            return null;\n        }\n        event.preventDefault();\n        d3ZoomHandler.call(this, event, d);\n    };\n}\nfunction createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        const viewport = transformToViewport(event.transform);\n        // we need to remember it here, because it's always 0 in the \"zoom\" event\n        zoomPanValues.mouseButton = event.sourceEvent?.button || 0;\n        zoomPanValues.isZoomingOrPanning = true;\n        zoomPanValues.prevViewport = viewport;\n        if (event.sourceEvent?.type === 'mousedown') {\n            onDraggingChange(true);\n        }\n        if (onPanZoomStart) {\n            onPanZoomStart?.(event.sourceEvent, viewport);\n        }\n    };\n}\nfunction createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom, }) {\n    return (event) => {\n        zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));\n        if (!event.sourceEvent?.sync) {\n            onTransformChange([event.transform.x, event.transform.y, event.transform.k]);\n        }\n        if (onPanZoom && !event.sourceEvent?.internal) {\n            onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));\n        }\n    };\n}\nfunction createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu, }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        zoomPanValues.isZoomingOrPanning = false;\n        if (onPaneContextMenu &&\n            isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) &&\n            !zoomPanValues.usedRightMouseButton &&\n            event.sourceEvent) {\n            onPaneContextMenu(event.sourceEvent);\n        }\n        zoomPanValues.usedRightMouseButton = false;\n        onDraggingChange(false);\n        if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform)) {\n            const viewport = transformToViewport(event.transform);\n            zoomPanValues.prevViewport = viewport;\n            clearTimeout(zoomPanValues.timerId);\n            zoomPanValues.timerId = setTimeout(() => {\n                onPanZoomEnd?.(event.sourceEvent, viewport);\n            }, \n            // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll\n            panOnScroll ? 150 : 0);\n        }\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib, }) {\n    return (event) => {\n        const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n        const pinchZoom = zoomOnPinch && event.ctrlKey;\n        if (event.button === 1 &&\n            event.type === 'mousedown' &&\n            (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {\n            return true;\n        }\n        // if all interactions are disabled, we prevent all zoom events\n        if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n            return false;\n        }\n        // during a selection we prevent all other interactions\n        if (userSelectionActive) {\n            return false;\n        }\n        // if the target element is inside an element with the nowheel class, we prevent zooming\n        if (isWrappedWithClass(event, noWheelClassName) && event.type === 'wheel') {\n            return false;\n        }\n        // if the target element is inside an element with the nopan class, we prevent panning\n        if (isWrappedWithClass(event, noPanClassName) &&\n            (event.type !== 'wheel' || (panOnScroll && event.type === 'wheel' && !zoomActivationKeyPressed))) {\n            return false;\n        }\n        if (!zoomOnPinch && event.ctrlKey && event.type === 'wheel') {\n            return false;\n        }\n        if (!zoomOnPinch && event.type === 'touchstart' && event.touches?.length > 1) {\n            event.preventDefault(); // if you manage to start with 2 touches, we prevent native zoom\n            return false;\n        }\n        // when there is no scroll handling enabled, we prevent all wheel events\n        if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === 'wheel') {\n            return false;\n        }\n        // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n        if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {\n            return false;\n        }\n        // if the pane is only movable using allowed clicks\n        if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === 'mousedown') {\n            return false;\n        }\n        // We only allow right clicks if pan on drag is set to right click\n        const buttonAllowed = (Array.isArray(panOnDrag) && panOnDrag.includes(event.button)) || !event.button || event.button <= 1;\n        // default filter for d3-zoom\n        return (!event.ctrlKey || event.type === 'wheel') && buttonAllowed;\n    };\n}\n\nfunction XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange, }) {\n    const zoomPanValues = {\n        isZoomingOrPanning: false,\n        usedRightMouseButton: false,\n        prevViewport: { x: 0, y: 0, zoom: 0 },\n        mouseButton: 0,\n        timerId: undefined,\n        panScrollTimeout: undefined,\n        isPanScrolling: false,\n    };\n    const bbox = domNode.getBoundingClientRect();\n    const d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n        .clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance)\n        .scaleExtent([minZoom, maxZoom])\n        .translateExtent(translateExtent);\n    const d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode).call(d3ZoomInstance);\n    setViewportConstrained({\n        x: viewport.x,\n        y: viewport.y,\n        zoom: clamp(viewport.zoom, minZoom, maxZoom),\n    }, [\n        [0, 0],\n        [bbox.width, bbox.height],\n    ], translateExtent);\n    const d3ZoomHandler = d3Selection.on('wheel.zoom');\n    const d3DblClickZoomHandler = d3Selection.on('dblclick.zoom');\n    d3ZoomInstance.wheelDelta(wheelDelta);\n    function setTransform(transform, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.transform(getD3Transition(d3Selection, options?.duration, () => resolve(true)), transform);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    // public functions\n    function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange, }) {\n        if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {\n            destroy();\n        }\n        const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;\n        const wheelHandler = isPanOnScroll\n            ? createPanOnScrollHandler({\n                zoomPanValues,\n                noWheelClassName,\n                d3Selection,\n                d3Zoom: d3ZoomInstance,\n                panOnScrollMode,\n                panOnScrollSpeed,\n                zoomOnPinch,\n                onPanZoomStart,\n                onPanZoom,\n                onPanZoomEnd,\n            })\n            : createZoomOnScrollHandler({\n                noWheelClassName,\n                preventScrolling,\n                d3ZoomHandler,\n            });\n        d3Selection.on('wheel.zoom', wheelHandler, { passive: false });\n        if (!userSelectionActive) {\n            // pan zoom start\n            const startHandler = createPanZoomStartHandler({\n                zoomPanValues,\n                onDraggingChange,\n                onPanZoomStart,\n            });\n            d3ZoomInstance.on('start', startHandler);\n            // pan zoom\n            const panZoomHandler = createPanZoomHandler({\n                zoomPanValues,\n                panOnDrag,\n                onPaneContextMenu: !!onPaneContextMenu,\n                onPanZoom,\n                onTransformChange,\n            });\n            d3ZoomInstance.on('zoom', panZoomHandler);\n            // pan zoom end\n            const panZoomEndHandler = createPanZoomEndHandler({\n                zoomPanValues,\n                panOnDrag,\n                panOnScroll,\n                onPaneContextMenu,\n                onPanZoomEnd,\n                onDraggingChange,\n            });\n            d3ZoomInstance.on('end', panZoomEndHandler);\n        }\n        const filter = createFilter({\n            zoomActivationKeyPressed,\n            panOnDrag,\n            zoomOnScroll,\n            panOnScroll,\n            zoomOnDoubleClick,\n            zoomOnPinch,\n            userSelectionActive,\n            noPanClassName,\n            noWheelClassName,\n            lib,\n        });\n        d3ZoomInstance.filter(filter);\n        // We cannot add zoomOnDoubleClick to the filter above because\n        // double tapping on touch screens circumvents the filter and\n        // dblclick.zoom is fired on the selection directly\n        if (zoomOnDoubleClick) {\n            d3Selection.on('dblclick.zoom', d3DblClickZoomHandler);\n        }\n        else {\n            d3Selection.on('dblclick.zoom', null);\n        }\n    }\n    function destroy() {\n        d3ZoomInstance.on('zoom', null);\n    }\n    async function setViewportConstrained(viewport, extent, translateExtent) {\n        const nextTransform = viewportToTransform(viewport);\n        const contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent);\n        if (contrainedTransform) {\n            await setTransform(contrainedTransform);\n        }\n        return new Promise((resolve) => resolve(contrainedTransform));\n    }\n    async function setViewport(viewport, options) {\n        const nextTransform = viewportToTransform(viewport);\n        await setTransform(nextTransform, options);\n        return new Promise((resolve) => resolve(nextTransform));\n    }\n    function syncViewport(viewport) {\n        if (d3Selection) {\n            const nextTransform = viewportToTransform(viewport);\n            const currentTransform = d3Selection.property('__zoom');\n            if (currentTransform.k !== viewport.zoom ||\n                currentTransform.x !== viewport.x ||\n                currentTransform.y !== viewport.y) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: true });\n            }\n        }\n    }\n    function getViewport() {\n        const transform = d3Selection ? (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(d3Selection.node()) : { x: 0, y: 0, k: 1 };\n        return { x: transform.x, y: transform.y, zoom: transform.k };\n    }\n    function scaleTo(zoom, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.scaleTo(getD3Transition(d3Selection, options?.duration, () => resolve(true)), zoom);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function scaleBy(factor, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.scaleBy(getD3Transition(d3Selection, options?.duration, () => resolve(true)), factor);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function setScaleExtent(scaleExtent) {\n        d3ZoomInstance?.scaleExtent(scaleExtent);\n    }\n    function setTranslateExtent(translateExtent) {\n        d3ZoomInstance?.translateExtent(translateExtent);\n    }\n    function setClickDistance(distance) {\n        const validDistance = !isNumeric(distance) || distance < 0 ? 0 : distance;\n        d3ZoomInstance?.clickDistance(validDistance);\n    }\n    return {\n        update,\n        destroy,\n        setViewport,\n        setViewportConstrained,\n        getViewport,\n        scaleTo,\n        scaleBy,\n        setScaleExtent,\n        setTranslateExtent,\n        syncViewport,\n        setClickDistance,\n    };\n}\n\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\nconst XY_RESIZER_HANDLE_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst XY_RESIZER_LINE_POSITIONS = ['top', 'right', 'bottom', 'left'];\n\n/**\n * Get all connecting edges for a given set of nodes\n * @param width - new width of the node\n * @param prevWidth - previous width of the node\n * @param height - new height of the node\n * @param prevHeight - previous height of the node\n * @param affectsX - whether to invert the resize direction for the x axis\n * @param affectsY - whether to invert the resize direction for the y axis\n * @returns array of two numbers representing the direction of the resize for each axis, 0 = no change, 1 = increase, -1 = decrease\n */\nfunction getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY, }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n    if (deltaWidth && affectsX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && affectsY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n/**\n * Parses the control position that is being dragged to dimensions that are being resized\n * @param controlPosition - position of the control that is being dragged\n * @returns isHorizontal, isVertical, affectsX, affectsY,\n */\nfunction getControlDirection(controlPosition) {\n    const isHorizontal = controlPosition.includes('right') || controlPosition.includes('left');\n    const isVertical = controlPosition.includes('bottom') || controlPosition.includes('top');\n    const affectsX = controlPosition.includes('left');\n    const affectsY = controlPosition.includes('top');\n    return {\n        isHorizontal,\n        isVertical,\n        affectsX,\n        affectsY,\n    };\n}\nfunction getLowerExtentClamp(lowerExtent, lowerBound) {\n    return Math.max(0, lowerBound - lowerExtent);\n}\nfunction getUpperExtentClamp(upperExtent, upperBound) {\n    return Math.max(0, upperExtent - upperBound);\n}\nfunction getSizeClamp(size, minSize, maxSize) {\n    return Math.max(0, minSize - size, size - maxSize);\n}\nfunction xor(a, b) {\n    return a ? !b : b;\n}\n/**\n * Calculates new width & height and x & y of node after resize based on pointer position\n * @description - Buckle up, this is a chunky one... If you want to determine the new dimensions of a node after a resize,\n * you have to account for all possible restrictions: min/max width/height of the node, the maximum extent the node is allowed\n * to move in (in this case: resize into) determined by the parent node, the minimal extent determined by child nodes\n * with expandParent or extent: 'parent' set and oh yeah, these things also have to work with keepAspectRatio!\n * The way this is done is by determining how much each of these restricting actually restricts the resize and then applying the\n * strongest restriction. Because the resize affects x, y and width, height and width, height of a opposing side with keepAspectRatio,\n * the resize amount is always kept in distX & distY amount (the distance in mouse movement)\n * Instead of clamping each value, we first calculate the biggest 'clamp' (for the lack of a better name) and then apply it to all values.\n * To complicate things nodeOrigin has to be taken into account as well. This is done by offsetting the nodes as if their origin is [0, 0],\n * then calculating the restrictions as usual\n * @param startValues - starting values of resize\n * @param controlDirection - dimensions affected by the resize\n * @param pointerPosition - the current pointer position corrected for snapping\n * @param boundaries - minimum and maximum dimensions of the node\n * @param keepAspectRatio - prevent changes of asprect ratio\n * @returns x, y, width and height of the node after resize\n */\nfunction getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {\n    let { affectsX, affectsY } = controlDirection;\n    const { isHorizontal, isVertical } = controlDirection;\n    const isDiagonal = isHorizontal && isVertical;\n    const { xSnapped, ySnapped } = pointerPosition;\n    const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;\n    const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;\n    let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);\n    let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);\n    const newWidth = startWidth + (affectsX ? -distX : distX);\n    const newHeight = startHeight + (affectsY ? -distY : distY);\n    const originOffsetX = -nodeOrigin[0] * startWidth;\n    const originOffsetY = -nodeOrigin[1] * startHeight;\n    // Check if maxWidth, minWWidth, maxHeight, minHeight are restricting the resize\n    let clampX = getSizeClamp(newWidth, minWidth, maxWidth);\n    let clampY = getSizeClamp(newHeight, minHeight, maxHeight);\n    // Check if extent is restricting the resize\n    if (extent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);\n        }\n        else if (!affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);\n        }\n        if (affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);\n        }\n        else if (!affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the child extent is restricting the resize\n    if (childExtent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);\n        }\n        else if (!affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);\n        }\n        if (affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);\n        }\n        else if (!affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the aspect ratio resizing of the other side is restricting the resize\n    if (keepAspectRatio) {\n        if (isHorizontal) {\n            // Check if the max dimensions might be restricting the resize\n            const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;\n            clampX = Math.max(clampX, aspectHeightClamp);\n            // Check if the extent is restricting the resize\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) *\n                            aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n            // Check if the child extent is restricting the resize\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n        }\n        // Do the same thing for vertical resizing\n        if (isVertical) {\n            const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;\n            clampY = Math.max(clampY, aspectWidthClamp);\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) /\n                            aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n        }\n    }\n    distY = distY + (distY < 0 ? clampY : -clampY);\n    distX = distX + (distX < 0 ? clampX : -clampX);\n    if (keepAspectRatio) {\n        if (isDiagonal) {\n            if (newWidth > newHeight * aspectRatio) {\n                distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;\n            }\n            else {\n                distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;\n            }\n        }\n        else {\n            if (isHorizontal) {\n                distY = distX / aspectRatio;\n                affectsY = affectsX;\n            }\n            else {\n                distX = distY * aspectRatio;\n                affectsX = affectsY;\n            }\n        }\n    }\n    const x = affectsX ? startX + distX : startX;\n    const y = affectsY ? startY + distY : startY;\n    return {\n        width: startWidth + (affectsX ? -distX : distX),\n        height: startHeight + (affectsY ? -distY : distY),\n        x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,\n        y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y,\n    };\n}\n\nconst initPrevValues = { width: 0, height: 0, x: 0, y: 0 };\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1,\n};\nfunction nodeToParentExtent(node) {\n    return [\n        [0, 0],\n        [node.measured.width, node.measured.height],\n    ];\n}\nfunction nodeToChildExtent(child, parent, nodeOrigin) {\n    const x = parent.position.x + child.position.x;\n    const y = parent.position.y + child.position.y;\n    const width = child.measured.width ?? 0;\n    const height = child.measured.height ?? 0;\n    const originOffsetX = nodeOrigin[0] * width;\n    const originOffsetY = nodeOrigin[1] * height;\n    return [\n        [x - originOffsetX, y - originOffsetY],\n        [x + width - originOffsetX, y + height - originOffsetY],\n    ];\n}\nfunction XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ controlPosition, boundaries, keepAspectRatio, onResizeStart, onResize, onResizeEnd, shouldResize, }) {\n        let prevValues = { ...initPrevValues };\n        let startValues = { ...initStartValues };\n        const controlDirection = getControlDirection(controlPosition);\n        let node = undefined;\n        let containerBounds = null;\n        let childNodes = [];\n        let parentNode = undefined; // Needed to fix expandParent\n        let parentExtent = undefined;\n        let childExtent = undefined;\n        const dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .on('start', (event) => {\n            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();\n            node = nodeLookup.get(nodeId);\n            if (!node) {\n                return;\n            }\n            containerBounds = paneDomNode?.getBoundingClientRect() ?? null;\n            const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            prevValues = {\n                width: node.measured.width ?? 0,\n                height: node.measured.height ?? 0,\n                x: node.position.x ?? 0,\n                y: node.position.y ?? 0,\n            };\n            startValues = {\n                ...prevValues,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.width / prevValues.height,\n            };\n            parentNode = undefined;\n            if (node.parentId && (node.extent === 'parent' || node.expandParent)) {\n                parentNode = nodeLookup.get(node.parentId);\n                parentExtent = parentNode && node.extent === 'parent' ? nodeToParentExtent(parentNode) : undefined;\n            }\n            // Collect all child nodes to correct their relative positions when top/left changes\n            // Determine largest minimal extent the parent node is allowed to resize to\n            childNodes = [];\n            childExtent = undefined;\n            for (const [childId, child] of nodeLookup) {\n                if (child.parentId === nodeId) {\n                    childNodes.push({\n                        id: childId,\n                        position: { ...child.position },\n                        extent: child.extent,\n                    });\n                    if (child.extent === 'parent' || child.expandParent) {\n                        const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);\n                        if (childExtent) {\n                            childExtent = [\n                                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],\n                                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])],\n                            ];\n                        }\n                        else {\n                            childExtent = extent;\n                        }\n                    }\n                }\n            }\n            onResizeStart?.(event, { ...prevValues });\n        })\n            .on('drag', (event) => {\n            const { transform, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();\n            const pointerPosition = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            const childChanges = [];\n            if (!node) {\n                return;\n            }\n            const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;\n            const change = {};\n            const nodeOrigin = node.origin ?? storeNodeOrigin;\n            const { width, height, x, y } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent);\n            const isWidthChange = width !== prevWidth;\n            const isHeightChange = height !== prevHeight;\n            const isXPosChange = x !== prevX && isWidthChange;\n            const isYPosChange = y !== prevY && isHeightChange;\n            if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {\n                return;\n            }\n            if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {\n                change.x = isXPosChange ? x : prevValues.x;\n                change.y = isYPosChange ? y : prevValues.y;\n                prevValues.x = change.x;\n                prevValues.y = change.y;\n                // when top/left changes, correct the relative positions of child nodes\n                // so that they stay in the same position\n                if (childNodes.length > 0) {\n                    const xChange = x - prevX;\n                    const yChange = y - prevY;\n                    for (const childNode of childNodes) {\n                        childNode.position = {\n                            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),\n                            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight),\n                        };\n                        childChanges.push(childNode);\n                    }\n                }\n            }\n            if (isWidthChange || isHeightChange) {\n                change.width = isWidthChange ? width : prevValues.width;\n                change.height = isHeightChange ? height : prevValues.height;\n                prevValues.width = change.width;\n                prevValues.height = change.height;\n            }\n            // Fix expandParent when resizing from top/left\n            if (parentNode && node.expandParent) {\n                const xLimit = nodeOrigin[0] * (change.width ?? 0);\n                if (change.x && change.x < xLimit) {\n                    prevValues.x = xLimit;\n                    startValues.x = startValues.x - (change.x - xLimit);\n                }\n                const yLimit = nodeOrigin[1] * (change.height ?? 0);\n                if (change.y && change.y < yLimit) {\n                    prevValues.y = yLimit;\n                    startValues.y = startValues.y - (change.y - yLimit);\n                }\n            }\n            const direction = getResizeDirection({\n                width: prevValues.width,\n                prevWidth,\n                height: prevValues.height,\n                prevHeight,\n                affectsX: controlDirection.affectsX,\n                affectsY: controlDirection.affectsY,\n            });\n            const nextValues = { ...prevValues, direction };\n            const callResize = shouldResize?.(event, nextValues);\n            if (callResize === false) {\n                return;\n            }\n            onResize?.(event, nextValues);\n            onChange(change, childChanges);\n        })\n            .on('end', (event) => {\n            onResizeEnd?.(event, { ...prevValues });\n            onEnd?.();\n        });\n        selection.call(dragHandler);\n    }\n    function destroy() {\n        selection.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9zeXN0ZW0vZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDZ0I7QUFDYTs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQsd0NBQXdDLEtBQUs7QUFDN0MsNkJBQTZCLGdDQUFnQyxpQ0FBaUMsWUFBWSxjQUFjLHNEQUFzRCxjQUFjLEdBQUc7QUFDL0w7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRCx1Q0FBdUMsR0FBRztBQUMxQyx3R0FBd0csSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFZLHFCQUFxQjtBQUNqQyxZQUFZLDJDQUEyQztBQUN2RCxZQUFZLDRFQUE0RTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpREFBaUQ7QUFDdEUsc0JBQXNCLHdEQUFNO0FBQzVCLHNCQUFzQixtR0FBbUc7QUFDekgsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsNEJBQTRCLG1EQUFJO0FBQ2hDO0FBQ0Esb0JBQW9CLHVFQUF1RTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxlQUFlO0FBQ3BELFNBQVM7QUFDVDtBQUNBLG9CQUFvQiwrREFBK0Q7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBMkQ7QUFDL0U7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyOUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcRGhhcm1lc2ggcmFpa3dhclxcRGVza3RvcFxcT3NpbnRBc3NpZ25tZW50XFxhc3NpZ25tZW50XFxGcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAeHlmbG93XFxzeXN0ZW1cXGRpc3RcXGVzbVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZHJhZyB9IGZyb20gJ2QzLWRyYWcnO1xuaW1wb3J0IHsgc2VsZWN0LCBwb2ludGVyIH0gZnJvbSAnZDMtc2VsZWN0aW9uJztcbmltcG9ydCB7IHpvb20sIHpvb21JZGVudGl0eSwgem9vbVRyYW5zZm9ybSB9IGZyb20gJ2QzLXpvb20nO1xuXG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xuICAgIGVycm9yMDAxOiAoKSA9PiAnW1JlYWN0IEZsb3ddOiBTZWVtcyBsaWtlIHlvdSBoYXZlIG5vdCB1c2VkIHp1c3RhbmQgcHJvdmlkZXIgYXMgYW4gYW5jZXN0b3IuIEhlbHA6IGh0dHBzOi8vcmVhY3RmbG93LmRldi9lcnJvciMwMDEnLFxuICAgIGVycm9yMDAyOiAoKSA9PiBcIkl0IGxvb2tzIGxpa2UgeW91J3ZlIGNyZWF0ZWQgYSBuZXcgbm9kZVR5cGVzIG9yIGVkZ2VUeXBlcyBvYmplY3QuIElmIHRoaXMgd2Fzbid0IG9uIHB1cnBvc2UgcGxlYXNlIGRlZmluZSB0aGUgbm9kZVR5cGVzL2VkZ2VUeXBlcyBvdXRzaWRlIG9mIHRoZSBjb21wb25lbnQgb3IgbWVtb2l6ZSB0aGVtLlwiLFxuICAgIGVycm9yMDAzOiAobm9kZVR5cGUpID0+IGBOb2RlIHR5cGUgXCIke25vZGVUeXBlfVwiIG5vdCBmb3VuZC4gVXNpbmcgZmFsbGJhY2sgdHlwZSBcImRlZmF1bHRcIi5gLFxuICAgIGVycm9yMDA0OiAoKSA9PiAnVGhlIFJlYWN0IEZsb3cgcGFyZW50IGNvbnRhaW5lciBuZWVkcyBhIHdpZHRoIGFuZCBhIGhlaWdodCB0byByZW5kZXIgdGhlIGdyYXBoLicsXG4gICAgZXJyb3IwMDU6ICgpID0+ICdPbmx5IGNoaWxkIG5vZGVzIGNhbiB1c2UgYSBwYXJlbnQgZXh0ZW50LicsXG4gICAgZXJyb3IwMDY6ICgpID0+IFwiQ2FuJ3QgY3JlYXRlIGVkZ2UuIEFuIGVkZ2UgbmVlZHMgYSBzb3VyY2UgYW5kIGEgdGFyZ2V0LlwiLFxuICAgIGVycm9yMDA3OiAoaWQpID0+IGBUaGUgb2xkIGVkZ2Ugd2l0aCBpZD0ke2lkfSBkb2VzIG5vdCBleGlzdC5gLFxuICAgIGVycm9yMDA5OiAodHlwZSkgPT4gYE1hcmtlciB0eXBlIFwiJHt0eXBlfVwiIGRvZXNuJ3QgZXhpc3QuYCxcbiAgICBlcnJvcjAwODogKGhhbmRsZVR5cGUsIHsgaWQsIHNvdXJjZUhhbmRsZSwgdGFyZ2V0SGFuZGxlIH0pID0+IGBDb3VsZG4ndCBjcmVhdGUgZWRnZSBmb3IgJHtoYW5kbGVUeXBlfSBoYW5kbGUgaWQ6IFwiJHtoYW5kbGVUeXBlID09PSAnc291cmNlJyA/IHNvdXJjZUhhbmRsZSA6IHRhcmdldEhhbmRsZX1cIiwgZWRnZSBpZDogJHtpZH0uYCxcbiAgICBlcnJvcjAxMDogKCkgPT4gJ0hhbmRsZTogTm8gbm9kZSBpZCBmb3VuZC4gTWFrZSBzdXJlIHRvIG9ubHkgdXNlIGEgSGFuZGxlIGluc2lkZSBhIGN1c3RvbSBOb2RlLicsXG4gICAgZXJyb3IwMTE6IChlZGdlVHlwZSkgPT4gYEVkZ2UgdHlwZSBcIiR7ZWRnZVR5cGV9XCIgbm90IGZvdW5kLiBVc2luZyBmYWxsYmFjayB0eXBlIFwiZGVmYXVsdFwiLmAsXG4gICAgZXJyb3IwMTI6IChpZCkgPT4gYE5vZGUgd2l0aCBpZCBcIiR7aWR9XCIgZG9lcyBub3QgZXhpc3QsIGl0IG1heSBoYXZlIGJlZW4gcmVtb3ZlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBub2RlIGlzIGRlbGV0ZWQgYmVmb3JlIHRoZSBcIm9uTm9kZUNsaWNrXCIgaGFuZGxlciBpcyBjYWxsZWQuYCxcbiAgICBlcnJvcjAxMzogKGxpYiA9ICdyZWFjdCcpID0+IGBJdCBzZWVtcyB0aGF0IHlvdSBoYXZlbid0IGxvYWRlZCB0aGUgc3R5bGVzLiBQbGVhc2UgaW1wb3J0ICdAeHlmbG93LyR7bGlifS9kaXN0L3N0eWxlLmNzcycgb3IgYmFzZS5jc3MgdG8gbWFrZSBzdXJlIGV2ZXJ5dGhpbmcgaXMgd29ya2luZyBwcm9wZXJseS5gLFxuICAgIGVycm9yMDE0OiAoKSA9PiAndXNlTm9kZUNvbm5lY3Rpb25zOiBObyBub2RlIElEIGZvdW5kLiBDYWxsIHVzZU5vZGVDb25uZWN0aW9ucyBpbnNpZGUgYSBjdXN0b20gTm9kZSBvciBwcm92aWRlIGEgbm9kZSBJRC4nLFxufTtcbmNvbnN0IGluZmluaXRlRXh0ZW50ID0gW1xuICAgIFtOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sXG4gICAgW051bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSxcbl07XG5jb25zdCBlbGVtZW50U2VsZWN0aW9uS2V5cyA9IFsnRW50ZXInLCAnICcsICdFc2NhcGUnXTtcblxudmFyIENvbm5lY3Rpb25Nb2RlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uTW9kZSkge1xuICAgIENvbm5lY3Rpb25Nb2RlW1wiU3RyaWN0XCJdID0gXCJzdHJpY3RcIjtcbiAgICBDb25uZWN0aW9uTW9kZVtcIkxvb3NlXCJdID0gXCJsb29zZVwiO1xufSkoQ29ubmVjdGlvbk1vZGUgfHwgKENvbm5lY3Rpb25Nb2RlID0ge30pKTtcbnZhciBQYW5PblNjcm9sbE1vZGU7XG4oZnVuY3Rpb24gKFBhbk9uU2Nyb2xsTW9kZSkge1xuICAgIFBhbk9uU2Nyb2xsTW9kZVtcIkZyZWVcIl0gPSBcImZyZWVcIjtcbiAgICBQYW5PblNjcm9sbE1vZGVbXCJWZXJ0aWNhbFwiXSA9IFwidmVydGljYWxcIjtcbiAgICBQYW5PblNjcm9sbE1vZGVbXCJIb3Jpem9udGFsXCJdID0gXCJob3Jpem9udGFsXCI7XG59KShQYW5PblNjcm9sbE1vZGUgfHwgKFBhbk9uU2Nyb2xsTW9kZSA9IHt9KSk7XG52YXIgU2VsZWN0aW9uTW9kZTtcbihmdW5jdGlvbiAoU2VsZWN0aW9uTW9kZSkge1xuICAgIFNlbGVjdGlvbk1vZGVbXCJQYXJ0aWFsXCJdID0gXCJwYXJ0aWFsXCI7XG4gICAgU2VsZWN0aW9uTW9kZVtcIkZ1bGxcIl0gPSBcImZ1bGxcIjtcbn0pKFNlbGVjdGlvbk1vZGUgfHwgKFNlbGVjdGlvbk1vZGUgPSB7fSkpO1xuY29uc3QgaW5pdGlhbENvbm5lY3Rpb24gPSB7XG4gICAgaW5Qcm9ncmVzczogZmFsc2UsXG4gICAgaXNWYWxpZDogbnVsbCxcbiAgICBmcm9tOiBudWxsLFxuICAgIGZyb21IYW5kbGU6IG51bGwsXG4gICAgZnJvbVBvc2l0aW9uOiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvOiBudWxsLFxuICAgIHRvSGFuZGxlOiBudWxsLFxuICAgIHRvUG9zaXRpb246IG51bGwsXG4gICAgdG9Ob2RlOiBudWxsLFxufTtcblxudmFyIENvbm5lY3Rpb25MaW5lVHlwZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvbkxpbmVUeXBlKSB7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiQmV6aWVyXCJdID0gXCJkZWZhdWx0XCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU3RyYWlnaHRcIl0gPSBcInN0cmFpZ2h0XCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU3RlcFwiXSA9IFwic3RlcFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlNtb290aFN0ZXBcIl0gPSBcInNtb290aHN0ZXBcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTaW1wbGVCZXppZXJcIl0gPSBcInNpbXBsZWJlemllclwiO1xufSkoQ29ubmVjdGlvbkxpbmVUeXBlIHx8IChDb25uZWN0aW9uTGluZVR5cGUgPSB7fSkpO1xudmFyIE1hcmtlclR5cGU7XG4oZnVuY3Rpb24gKE1hcmtlclR5cGUpIHtcbiAgICBNYXJrZXJUeXBlW1wiQXJyb3dcIl0gPSBcImFycm93XCI7XG4gICAgTWFya2VyVHlwZVtcIkFycm93Q2xvc2VkXCJdID0gXCJhcnJvd2Nsb3NlZFwiO1xufSkoTWFya2VyVHlwZSB8fCAoTWFya2VyVHlwZSA9IHt9KSk7XG5cbnZhciBQb3NpdGlvbjtcbihmdW5jdGlvbiAoUG9zaXRpb24pIHtcbiAgICBQb3NpdGlvbltcIkxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBQb3NpdGlvbltcIlRvcFwiXSA9IFwidG9wXCI7XG4gICAgUG9zaXRpb25bXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcbiAgICBQb3NpdGlvbltcIkJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG59KShQb3NpdGlvbiB8fCAoUG9zaXRpb24gPSB7fSkpO1xuY29uc3Qgb3Bwb3NpdGVQb3NpdGlvbiA9IHtcbiAgICBbUG9zaXRpb24uTGVmdF06IFBvc2l0aW9uLlJpZ2h0LFxuICAgIFtQb3NpdGlvbi5SaWdodF06IFBvc2l0aW9uLkxlZnQsXG4gICAgW1Bvc2l0aW9uLlRvcF06IFBvc2l0aW9uLkJvdHRvbSxcbiAgICBbUG9zaXRpb24uQm90dG9tXTogUG9zaXRpb24uVG9wLFxufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gYXJlQ29ubmVjdGlvbk1hcHNFcXVhbChhLCBiKSB7XG4gICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWEgfHwgIWIgfHwgYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWEuc2l6ZSAmJiAhYi5zaXplKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhLmtleXMoKSkge1xuICAgICAgICBpZiAoIWIuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogV2UgY2FsbCB0aGUgY2FsbGJhY2sgZm9yIGFsbCBjb25uZWN0aW9ucyBpbiBhIHRoYXQgYXJlIG5vdCBpbiBiXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UoYSwgYiwgY2IpIHtcbiAgICBpZiAoIWNiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlmZiA9IFtdO1xuICAgIGEuZm9yRWFjaCgoY29ubmVjdGlvbiwga2V5KSA9PiB7XG4gICAgICAgIGlmICghYj8uaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGRpZmYucHVzaChjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkaWZmLmxlbmd0aCkge1xuICAgICAgICBjYihkaWZmKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb25uZWN0aW9uU3RhdHVzKGlzVmFsaWQpIHtcbiAgICByZXR1cm4gaXNWYWxpZCA9PT0gbnVsbCA/IG51bGwgOiBpc1ZhbGlkID8gJ3ZhbGlkJyA6ICdpbnZhbGlkJztcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzZWFibGUgYXMgYW4gRWRnZVxuICogQHB1YmxpY1xuICogQHJlbWFya3MgSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvIEVkZ2UgaWYgaXQgcmV0dXJucyB0cnVlXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHRlc3RcbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYW4gRWRnZVxuICovXG5jb25zdCBpc0VkZ2VCYXNlID0gKGVsZW1lbnQpID0+ICdpZCcgaW4gZWxlbWVudCAmJiAnc291cmNlJyBpbiBlbGVtZW50ICYmICd0YXJnZXQnIGluIGVsZW1lbnQ7XG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgdXNlYWJsZSBhcyBhIE5vZGVcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBOb2RlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFuIE5vZGVcbiAqL1xuY29uc3QgaXNOb2RlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ3Bvc2l0aW9uJyBpbiBlbGVtZW50ICYmICEoJ3NvdXJjZScgaW4gZWxlbWVudCkgJiYgISgndGFyZ2V0JyBpbiBlbGVtZW50KTtcbmNvbnN0IGlzSW50ZXJuYWxOb2RlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ2ludGVybmFscycgaW4gZWxlbWVudCAmJiAhKCdzb3VyY2UnIGluIGVsZW1lbnQpICYmICEoJ3RhcmdldCcgaW4gZWxlbWVudCk7XG4vKipcbiAqIFBhc3MgaW4gYSBub2RlLCBhbmQgZ2V0IGNvbm5lY3RlZCBub2RlcyB3aGVyZSBlZGdlLnNvdXJjZSA9PT0gbm9kZS5pZFxuICogQHB1YmxpY1xuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBnZXQgdGhlIGNvbm5lY3RlZCBub2RlcyBmcm9tXG4gKiBAcGFyYW0gbm9kZXMgLSBUaGUgYXJyYXkgb2YgYWxsIG5vZGVzXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGVkZ2VzXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyB0aGF0IGFyZSBjb25uZWN0ZWQgb3ZlciBlZ2VzIHdoZXJlIHRoZSBzb3VyY2UgaXMgdGhlIGdpdmVuIG5vZGVcbiAqL1xuY29uc3QgZ2V0T3V0Z29lcnMgPSAobm9kZSwgbm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgaWYgKCFub2RlLmlkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qgb3V0Z29lcklkcyA9IG5ldyBTZXQoKTtcbiAgICBlZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICAgIGlmIChlZGdlLnNvdXJjZSA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgb3V0Z29lcklkcy5hZGQoZWRnZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcigobikgPT4gb3V0Z29lcklkcy5oYXMobi5pZCkpO1xufTtcbi8qKlxuICogUGFzcyBpbiBhIG5vZGUsIGFuZCBnZXQgY29ubmVjdGVkIG5vZGVzIHdoZXJlIGVkZ2UudGFyZ2V0ID09PSBub2RlLmlkXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGdldCB0aGUgY29ubmVjdGVkIG5vZGVzIGZyb21cbiAqIEBwYXJhbSBub2RlcyAtIFRoZSBhcnJheSBvZiBhbGwgbm9kZXNcbiAqIEBwYXJhbSBlZGdlcyAtIFRoZSBhcnJheSBvZiBhbGwgZWRnZXNcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIHRoYXQgYXJlIGNvbm5lY3RlZCBvdmVyIGVnZXMgd2hlcmUgdGhlIHRhcmdldCBpcyB0aGUgZ2l2ZW4gbm9kZVxuICovXG5jb25zdCBnZXRJbmNvbWVycyA9IChub2RlLCBub2RlcywgZWRnZXMpID0+IHtcbiAgICBpZiAoIW5vZGUuaWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBpbmNvbWVyc0lkcyA9IG5ldyBTZXQoKTtcbiAgICBlZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICAgIGlmIChlZGdlLnRhcmdldCA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgaW5jb21lcnNJZHMuYWRkKGVkZ2Uuc291cmNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlcy5maWx0ZXIoKG4pID0+IGluY29tZXJzSWRzLmhhcyhuLmlkKSk7XG59O1xuY29uc3QgZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbiA9IChub2RlLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBvcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgIGNvbnN0IG9mZnNldFggPSB3aWR0aCAqIG9yaWdpblswXTtcbiAgICBjb25zdCBvZmZzZXRZID0gaGVpZ2h0ICogb3JpZ2luWzFdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IG5vZGUucG9zaXRpb24ueCAtIG9mZnNldFgsXG4gICAgICAgIHk6IG5vZGUucG9zaXRpb24ueSAtIG9mZnNldFksXG4gICAgfTtcbn07XG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyBhIGJvdW5kaW5nIGJveCB0aGF0IGNvbnRhaW5zIGFsbCBnaXZlbiBub2RlcyBpbiBhbiBhcnJheS5cbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIFVzZWZ1bCB3aGVuIGNvbWJpbmVkIHdpdGgge0BsaW5rIGdldFZpZXdwb3J0Rm9yQm91bmRzfSB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIHRvIGZpdCB0aGUgZ2l2ZW4gbm9kZXMgaW4gYSB2aWV3cG9ydC5cbiAqIEBwYXJhbSBub2RlcyAtIE5vZGVzIHRvIGNhbGN1bGF0ZSB0aGUgYm91bmRzIGZvclxuICogQHBhcmFtIHBhcmFtcy5ub2RlT3JpZ2luIC0gT3JpZ2luIG9mIHRoZSBub2RlczogWzAsIDBdIC0gdG9wIGxlZnQsIFswLjUsIDAuNV0gLSBjZW50ZXJcbiAqIEByZXR1cm5zIEJvdW5kaW5nIGJveCBlbmNsb3NpbmcgYWxsIG5vZGVzXG4gKi9cbmNvbnN0IGdldE5vZGVzQm91bmRzID0gKG5vZGVzLCBwYXJhbXMgPSB7IG5vZGVPcmlnaW46IFswLCAwXSwgbm9kZUxvb2t1cDogdW5kZWZpbmVkIH0pID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgIXBhcmFtcy5ub2RlTG9va3VwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUGxlYXNlIHVzZSBgZ2V0Tm9kZXNCb3VuZHNgIGZyb20gYHVzZVJlYWN0Rmxvd2AvYHVzZVN2ZWx0ZUZsb3dgIGhvb2sgdG8gZW5zdXJlIGNvcnJlY3QgdmFsdWVzIGZvciBzdWIgZmxvd3MuIElmIG5vdCBwb3NzaWJsZSwgeW91IGhhdmUgdG8gcHJvdmlkZSBhIG5vZGVMb29rdXAgdG8gc3VwcG9ydCBzdWIgZmxvd3MuJyk7XG4gICAgfVxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIH1cbiAgICBjb25zdCBib3ggPSBub2Rlcy5yZWR1Y2UoKGN1cnJCb3gsIG5vZGVPcklkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzSWQgPSB0eXBlb2Ygbm9kZU9ySWQgPT09ICdzdHJpbmcnO1xuICAgICAgICBsZXQgY3VycmVudE5vZGUgPSAhcGFyYW1zLm5vZGVMb29rdXAgJiYgIWlzSWQgPyBub2RlT3JJZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBhcmFtcy5ub2RlTG9va3VwKSB7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGlzSWRcbiAgICAgICAgICAgICAgICA/IHBhcmFtcy5ub2RlTG9va3VwLmdldChub2RlT3JJZClcbiAgICAgICAgICAgICAgICA6ICFpc0ludGVybmFsTm9kZUJhc2Uobm9kZU9ySWQpXG4gICAgICAgICAgICAgICAgICAgID8gcGFyYW1zLm5vZGVMb29rdXAuZ2V0KG5vZGVPcklkLmlkKVxuICAgICAgICAgICAgICAgICAgICA6IG5vZGVPcklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVCb3ggPSBjdXJyZW50Tm9kZSA/IG5vZGVUb0JveChjdXJyZW50Tm9kZSwgcGFyYW1zLm5vZGVPcmlnaW4pIDogeyB4OiAwLCB5OiAwLCB4MjogMCwgeTI6IDAgfTtcbiAgICAgICAgcmV0dXJuIGdldEJvdW5kc09mQm94ZXMoY3VyckJveCwgbm9kZUJveCk7XG4gICAgfSwgeyB4OiBJbmZpbml0eSwgeTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkyOiAtSW5maW5pdHkgfSk7XG4gICAgcmV0dXJuIGJveFRvUmVjdChib3gpO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBhIGJvdW5kaW5nIGJveCB0aGF0IGNvbnRhaW5zIGFsbCBnaXZlbiBub2RlcyBpbiBhbiBhcnJheVxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IGdldEludGVybmFsTm9kZXNCb3VuZHMgPSAobm9kZUxvb2t1cCwgcGFyYW1zID0ge30pID0+IHtcbiAgICBpZiAobm9kZUxvb2t1cC5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICB9XG4gICAgbGV0IGJveCA9IHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MjogLUluZmluaXR5IH07XG4gICAgbm9kZUxvb2t1cC5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIGlmIChwYXJhbXMuZmlsdGVyID09PSB1bmRlZmluZWQgfHwgcGFyYW1zLmZpbHRlcihub2RlKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUJveCA9IG5vZGVUb0JveChub2RlKTtcbiAgICAgICAgICAgIGJveCA9IGdldEJvdW5kc09mQm94ZXMoYm94LCBub2RlQm94KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBib3hUb1JlY3QoYm94KTtcbn07XG5jb25zdCBnZXROb2Rlc0luc2lkZSA9IChub2RlcywgcmVjdCwgW3R4LCB0eSwgdFNjYWxlXSA9IFswLCAwLCAxXSwgcGFydGlhbGx5ID0gZmFsc2UsIFxuLy8gc2V0IGV4Y2x1ZGVOb25TZWxlY3RhYmxlTm9kZXMgaWYgeW91IHdhbnQgdG8gcGF5IGF0dGVudGlvbiB0byB0aGUgbm9kZXMgXCJzZWxlY3RhYmxlXCIgYXR0cmlidXRlXG5leGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBwYW5lUmVjdCA9IHtcbiAgICAgICAgLi4ucG9pbnRUb1JlbmRlcmVyUG9pbnQocmVjdCwgW3R4LCB0eSwgdFNjYWxlXSksXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoIC8gdFNjYWxlLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0IC8gdFNjYWxlLFxuICAgIH07XG4gICAgY29uc3QgdmlzaWJsZU5vZGVzID0gW107XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVhc3VyZWQsIHNlbGVjdGFibGUgPSB0cnVlLCBoaWRkZW4gPSBmYWxzZSB9ID0gbm9kZTtcbiAgICAgICAgaWYgKChleGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzICYmICFzZWxlY3RhYmxlKSB8fCBoaWRkZW4pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbWVhc3VyZWQud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyBudWxsO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IG51bGw7XG4gICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQXJlYSA9IGdldE92ZXJsYXBwaW5nQXJlYShwYW5lUmVjdCwgbm9kZVRvUmVjdChub2RlKSk7XG4gICAgICAgIGNvbnN0IGFyZWEgPSAod2lkdGggPz8gMCkgKiAoaGVpZ2h0ID8/IDApO1xuICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgIGNvbnN0IGZvcmNlSW5pdGlhbFJlbmRlciA9ICFub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM7XG4gICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGZvcmNlSW5pdGlhbFJlbmRlciB8fCBwYXJ0aWFsbHlWaXNpYmxlIHx8IG92ZXJsYXBwaW5nQXJlYSA+PSBhcmVhO1xuICAgICAgICBpZiAoaXNWaXNpYmxlIHx8IG5vZGUuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHZpc2libGVOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2aXNpYmxlTm9kZXM7XG59O1xuLyoqXG4gKiBHZXQgYWxsIGNvbm5lY3RpbmcgZWRnZXMgZm9yIGEgZ2l2ZW4gc2V0IG9mIG5vZGVzXG4gKiBAcGFyYW0gbm9kZXMgLSBOb2RlcyB5b3Ugd2FudCB0byBnZXQgdGhlIGNvbm5lY3RlZCBlZGdlcyBmb3JcbiAqIEBwYXJhbSBlZGdlcyAtIEFsbCBlZGdlc1xuICogQHJldHVybnMgQXJyYXkgb2YgZWRnZXMgdGhhdCBjb25uZWN0IGFueSBvZiB0aGUgZ2l2ZW4gbm9kZXMgd2l0aCBlYWNoIG90aGVyXG4gKi9cbmNvbnN0IGdldENvbm5lY3RlZEVkZ2VzID0gKG5vZGVzLCBlZGdlcykgPT4ge1xuICAgIGNvbnN0IG5vZGVJZHMgPSBuZXcgU2V0KCk7XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBub2RlSWRzLmFkZChub2RlLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBub2RlSWRzLmhhcyhlZGdlLnNvdXJjZSkgfHwgbm9kZUlkcy5oYXMoZWRnZS50YXJnZXQpKTtcbn07XG5mdW5jdGlvbiBnZXRGaXRWaWV3Tm9kZXMobm9kZUxvb2t1cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZpdFZpZXdOb2RlcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBvcHRpb25Ob2RlSWRzID0gb3B0aW9ucz8ubm9kZXMgPyBuZXcgU2V0KG9wdGlvbnMubm9kZXMubWFwKChub2RlKSA9PiBub2RlLmlkKSkgOiBudWxsO1xuICAgIG5vZGVMb29rdXAuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBuLm1lYXN1cmVkLndpZHRoICYmIG4ubWVhc3VyZWQuaGVpZ2h0ICYmIChvcHRpb25zPy5pbmNsdWRlSGlkZGVuTm9kZXMgfHwgIW4uaGlkZGVuKTtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSAmJiAoIW9wdGlvbk5vZGVJZHMgfHwgb3B0aW9uTm9kZUlkcy5oYXMobi5pZCkpKSB7XG4gICAgICAgICAgICBmaXRWaWV3Tm9kZXMuc2V0KG4uaWQsIG4pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpdFZpZXdOb2Rlcztcbn1cbmFzeW5jIGZ1bmN0aW9uIGZpdFZpZXcoeyBub2Rlcywgd2lkdGgsIGhlaWdodCwgcGFuWm9vbSwgbWluWm9vbSwgbWF4Wm9vbSB9LCBvcHRpb25zKSB7XG4gICAgaWYgKG5vZGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIGNvbnN0IGJvdW5kcyA9IGdldEludGVybmFsTm9kZXNCb3VuZHMobm9kZXMpO1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zPy5taW5ab29tID8/IG1pblpvb20sIG9wdGlvbnM/Lm1heFpvb20gPz8gbWF4Wm9vbSwgb3B0aW9ucz8ucGFkZGluZyA/PyAwLjEpO1xuICAgIGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnQodmlld3BvcnQsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgbmV4dCBwb3NpdGlvbiBvZiBhIG5vZGUsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIG5vZGUncyBleHRlbnQsIHBhcmVudCBub2RlLCBhbmQgb3JpZ2luLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgcG9zaXRpb24sIHBvc2l0aW9uQWJzb2x1dGVcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTm9kZVBvc2l0aW9uKHsgbm9kZUlkLCBuZXh0UG9zaXRpb24sIG5vZGVMb29rdXAsIG5vZGVPcmlnaW4gPSBbMCwgMF0sIG5vZGVFeHRlbnQsIG9uRXJyb3IsIH0pIHtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRJZCA/IG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHsgeDogcGFyZW50WCwgeTogcGFyZW50WSB9ID0gcGFyZW50Tm9kZSA/IHBhcmVudE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgOiB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCBvcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgIGxldCBleHRlbnQgPSBub2RlRXh0ZW50O1xuICAgIGlmIChub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcgJiYgIW5vZGUuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgb25FcnJvcj8uKCcwMDUnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNSddKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50V2lkdGggPSBwYXJlbnROb2RlLm1lYXN1cmVkLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SGVpZ2h0ID0gcGFyZW50Tm9kZS5tZWFzdXJlZC5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAocGFyZW50V2lkdGggJiYgcGFyZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICBbcGFyZW50WCwgcGFyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtwYXJlbnRYICsgcGFyZW50V2lkdGgsIHBhcmVudFkgKyBwYXJlbnRIZWlnaHRdLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50Tm9kZSAmJiBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpKSB7XG4gICAgICAgIGV4dGVudCA9IFtcbiAgICAgICAgICAgIFtub2RlLmV4dGVudFswXVswXSArIHBhcmVudFgsIG5vZGUuZXh0ZW50WzBdWzFdICsgcGFyZW50WV0sXG4gICAgICAgICAgICBbbm9kZS5leHRlbnRbMV1bMF0gKyBwYXJlbnRYLCBub2RlLmV4dGVudFsxXVsxXSArIHBhcmVudFldLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbkFic29sdXRlID0gaXNDb29yZGluYXRlRXh0ZW50KGV4dGVudClcbiAgICAgICAgPyBjbGFtcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgZXh0ZW50LCBub2RlLm1lYXN1cmVkKVxuICAgICAgICA6IG5leHRQb3NpdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zaXRpb25BYnNvbHV0ZS54IC0gcGFyZW50WCArIG5vZGUubWVhc3VyZWQud2lkdGggKiBvcmlnaW5bMF0sXG4gICAgICAgICAgICB5OiBwb3NpdGlvbkFic29sdXRlLnkgLSBwYXJlbnRZICsgbm9kZS5tZWFzdXJlZC5oZWlnaHQgKiBvcmlnaW5bMV0sXG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uQWJzb2x1dGUsXG4gICAgfTtcbn1cbi8qKlxuICogUGFzcyBpbiBub2RlcyAmIGVkZ2VzIHRvIGRlbGV0ZSwgZ2V0IGFycmF5cyBvZiBub2RlcyBhbmQgZWRnZXMgdGhhdCBhY3R1YWxseSBjYW4gYmUgZGVsZXRlZFxuICogQGludGVybmFsXG4gKiBAcGFyYW0gcGFyYW0ubm9kZXNUb1JlbW92ZSAtIFRoZSBub2RlcyB0byByZW1vdmVcbiAqIEBwYXJhbSBwYXJhbS5lZGdlc1RvUmVtb3ZlIC0gVGhlIGVkZ2VzIHRvIHJlbW92ZVxuICogQHBhcmFtIHBhcmFtLm5vZGVzIC0gQWxsIG5vZGVzXG4gKiBAcGFyYW0gcGFyYW0uZWRnZXMgLSBBbGwgZWRnZXNcbiAqIEBwYXJhbSBwYXJhbS5vbkJlZm9yZURlbGV0ZSAtIENhbGxiYWNrIHRvIGNoZWNrIHdoaWNoIG5vZGVzIGFuZCBlZGdlcyBjYW4gYmUgZGVsZXRlZFxuICogQHJldHVybnMgbm9kZXM6IG5vZGVzIHRoYXQgY2FuIGJlIGRlbGV0ZWQsIGVkZ2VzOiBlZGdlcyB0aGF0IGNhbiBiZSBkZWxldGVkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEVsZW1lbnRzVG9SZW1vdmUoeyBub2Rlc1RvUmVtb3ZlID0gW10sIGVkZ2VzVG9SZW1vdmUgPSBbXSwgbm9kZXMsIGVkZ2VzLCBvbkJlZm9yZURlbGV0ZSwgfSkge1xuICAgIGNvbnN0IG5vZGVJZHMgPSBuZXcgU2V0KG5vZGVzVG9SZW1vdmUubWFwKChub2RlKSA9PiBub2RlLmlkKSk7XG4gICAgY29uc3QgbWF0Y2hpbmdOb2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZS5kZWxldGFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0luY2x1ZGVkID0gbm9kZUlkcy5oYXMobm9kZS5pZCk7XG4gICAgICAgIGNvbnN0IHBhcmVudEhpdCA9ICFpc0luY2x1ZGVkICYmIG5vZGUucGFyZW50SWQgJiYgbWF0Y2hpbmdOb2Rlcy5maW5kKChuKSA9PiBuLmlkID09PSBub2RlLnBhcmVudElkKTtcbiAgICAgICAgaWYgKGlzSW5jbHVkZWQgfHwgcGFyZW50SGl0KSB7XG4gICAgICAgICAgICBtYXRjaGluZ05vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWRnZUlkcyA9IG5ldyBTZXQoZWRnZXNUb1JlbW92ZS5tYXAoKGVkZ2UpID0+IGVkZ2UuaWQpKTtcbiAgICBjb25zdCBkZWxldGFibGVFZGdlcyA9IGVkZ2VzLmZpbHRlcigoZWRnZSkgPT4gZWRnZS5kZWxldGFibGUgIT09IGZhbHNlKTtcbiAgICBjb25zdCBjb25uZWN0ZWRFZGdlcyA9IGdldENvbm5lY3RlZEVkZ2VzKG1hdGNoaW5nTm9kZXMsIGRlbGV0YWJsZUVkZ2VzKTtcbiAgICBjb25zdCBtYXRjaGluZ0VkZ2VzID0gY29ubmVjdGVkRWRnZXM7XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGRlbGV0YWJsZUVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IGlzSW5jbHVkZWQgPSBlZGdlSWRzLmhhcyhlZGdlLmlkKTtcbiAgICAgICAgaWYgKGlzSW5jbHVkZWQgJiYgIW1hdGNoaW5nRWRnZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gZWRnZS5pZCkpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nRWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW9uQmVmb3JlRGVsZXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlZGdlczogbWF0Y2hpbmdFZGdlcyxcbiAgICAgICAgICAgIG5vZGVzOiBtYXRjaGluZ05vZGVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvbkJlZm9yZURlbGV0ZVJlc3VsdCA9IGF3YWl0IG9uQmVmb3JlRGVsZXRlKHtcbiAgICAgICAgbm9kZXM6IG1hdGNoaW5nTm9kZXMsXG4gICAgICAgIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzLFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2Ygb25CZWZvcmVEZWxldGVSZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gb25CZWZvcmVEZWxldGVSZXN1bHQgPyB7IGVkZ2VzOiBtYXRjaGluZ0VkZ2VzLCBub2RlczogbWF0Y2hpbmdOb2RlcyB9IDogeyBlZGdlczogW10sIG5vZGVzOiBbXSB9O1xuICAgIH1cbiAgICByZXR1cm4gb25CZWZvcmVEZWxldGVSZXN1bHQ7XG59XG5cbmNvbnN0IGNsYW1wID0gKHZhbCwgbWluID0gMCwgbWF4ID0gMSkgPT4gTWF0aC5taW4oTWF0aC5tYXgodmFsLCBtaW4pLCBtYXgpO1xuY29uc3QgY2xhbXBQb3NpdGlvbiA9IChwb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9LCBleHRlbnQsIGRpbWVuc2lvbnMpID0+ICh7XG4gICAgeDogY2xhbXAocG9zaXRpb24ueCwgZXh0ZW50WzBdWzBdLCBleHRlbnRbMV1bMF0gLSAoZGltZW5zaW9ucz8ud2lkdGggPz8gMCkpLFxuICAgIHk6IGNsYW1wKHBvc2l0aW9uLnksIGV4dGVudFswXVsxXSwgZXh0ZW50WzFdWzFdIC0gKGRpbWVuc2lvbnM/LmhlaWdodCA/PyAwKSksXG59KTtcbmZ1bmN0aW9uIGNsYW1wUG9zaXRpb25Ub1BhcmVudChjaGlsZFBvc2l0aW9uLCBjaGlsZERpbWVuc2lvbnMsIHBhcmVudCkge1xuICAgIGNvbnN0IHsgd2lkdGg6IHBhcmVudFdpZHRoLCBoZWlnaHQ6IHBhcmVudEhlaWdodCB9ID0gZ2V0Tm9kZURpbWVuc2lvbnMocGFyZW50KTtcbiAgICBjb25zdCB7IHg6IHBhcmVudFgsIHk6IHBhcmVudFkgfSA9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAgICByZXR1cm4gY2xhbXBQb3NpdGlvbihjaGlsZFBvc2l0aW9uLCBbXG4gICAgICAgIFtwYXJlbnRYLCBwYXJlbnRZXSxcbiAgICAgICAgW3BhcmVudFggKyBwYXJlbnRXaWR0aCwgcGFyZW50WSArIHBhcmVudEhlaWdodF0sXG4gICAgXSwgY2hpbGREaW1lbnNpb25zKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgdmVsb2NpdHkgb2YgcGFubmluZyB3aGVuIHRoZSBtb3VzZSBpcyBjbG9zZSB0byB0aGUgZWRnZSBvZiB0aGUgY2FudmFzXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB2YWx1ZSAtIE9uZSBkaW1lbnNpb25hbCBwb2l0aW9uIG9mIHRoZSBtb3VzZSAoeCBvciB5KVxuICogQHBhcmFtIG1pbiAtIE1pbmltYWwgcG9zaXRpb24gb24gY2FudmFzIGJlZm9yZSBwYW5uaW5nIHN0YXJ0c1xuICogQHBhcmFtIG1heCAtIE1heGltYWwgcG9zaXRpb24gb24gY2FudmFzIGJlZm9yZSBwYW5uaW5nIHN0YXJ0c1xuICogQHJldHVybnMgLSBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgdGhhdCByZXByZXNlbnRzIHRoZSB2ZWxvY2l0eSBvZiBwYW5uaW5nXG4gKi9cbmNvbnN0IGNhbGNBdXRvUGFuVmVsb2NpdHkgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB7XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIHJldHVybiBjbGFtcChNYXRoLmFicyh2YWx1ZSAtIG1pbiksIDEsIG1pbikgLyBtaW47XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIHJldHVybiAtY2xhbXAoTWF0aC5hYnModmFsdWUgLSBtYXgpLCAxLCBtaW4pIC8gbWluO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5jb25zdCBjYWxjQXV0b1BhbiA9IChwb3MsIGJvdW5kcywgc3BlZWQgPSAxNSwgZGlzdGFuY2UgPSA0MCkgPT4ge1xuICAgIGNvbnN0IHhNb3ZlbWVudCA9IGNhbGNBdXRvUGFuVmVsb2NpdHkocG9zLngsIGRpc3RhbmNlLCBib3VuZHMud2lkdGggLSBkaXN0YW5jZSkgKiBzcGVlZDtcbiAgICBjb25zdCB5TW92ZW1lbnQgPSBjYWxjQXV0b1BhblZlbG9jaXR5KHBvcy55LCBkaXN0YW5jZSwgYm91bmRzLmhlaWdodCAtIGRpc3RhbmNlKSAqIHNwZWVkO1xuICAgIHJldHVybiBbeE1vdmVtZW50LCB5TW92ZW1lbnRdO1xufTtcbmNvbnN0IGdldEJvdW5kc09mQm94ZXMgPSAoYm94MSwgYm94MikgPT4gKHtcbiAgICB4OiBNYXRoLm1pbihib3gxLngsIGJveDIueCksXG4gICAgeTogTWF0aC5taW4oYm94MS55LCBib3gyLnkpLFxuICAgIHgyOiBNYXRoLm1heChib3gxLngyLCBib3gyLngyKSxcbiAgICB5MjogTWF0aC5tYXgoYm94MS55MiwgYm94Mi55MiksXG59KTtcbmNvbnN0IHJlY3RUb0JveCA9ICh7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSkgPT4gKHtcbiAgICB4LFxuICAgIHksXG4gICAgeDI6IHggKyB3aWR0aCxcbiAgICB5MjogeSArIGhlaWdodCxcbn0pO1xuY29uc3QgYm94VG9SZWN0ID0gKHsgeCwgeSwgeDIsIHkyIH0pID0+ICh7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiB4MiAtIHgsXG4gICAgaGVpZ2h0OiB5MiAtIHksXG59KTtcbmNvbnN0IG5vZGVUb1JlY3QgPSAobm9kZSwgbm9kZU9yaWdpbiA9IFswLCAwXSkgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gaXNJbnRlcm5hbE5vZGVCYXNlKG5vZGUpXG4gICAgICAgID8gbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZVxuICAgICAgICA6IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgbm9kZU9yaWdpbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGg6IG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gMCxcbiAgICAgICAgaGVpZ2h0OiBub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IDAsXG4gICAgfTtcbn07XG5jb25zdCBub2RlVG9Cb3ggPSAobm9kZSwgbm9kZU9yaWdpbiA9IFswLCAwXSkgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gaXNJbnRlcm5hbE5vZGVCYXNlKG5vZGUpXG4gICAgICAgID8gbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZVxuICAgICAgICA6IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgbm9kZU9yaWdpbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgeDI6IHggKyAobm9kZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyAwKSxcbiAgICAgICAgeTI6IHkgKyAobm9kZS5tZWFzdXJlZD8uaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyAwKSxcbiAgICB9O1xufTtcbmNvbnN0IGdldEJvdW5kc09mUmVjdHMgPSAocmVjdDEsIHJlY3QyKSA9PiBib3hUb1JlY3QoZ2V0Qm91bmRzT2ZCb3hlcyhyZWN0VG9Cb3gocmVjdDEpLCByZWN0VG9Cb3gocmVjdDIpKSk7XG5jb25zdCBnZXRPdmVybGFwcGluZ0FyZWEgPSAocmVjdEEsIHJlY3RCKSA9PiB7XG4gICAgY29uc3QgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0QS54ICsgcmVjdEEud2lkdGgsIHJlY3RCLnggKyByZWN0Qi53aWR0aCkgLSBNYXRoLm1heChyZWN0QS54LCByZWN0Qi54KSk7XG4gICAgY29uc3QgeU92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWN0QS55ICsgcmVjdEEuaGVpZ2h0LCByZWN0Qi55ICsgcmVjdEIuaGVpZ2h0KSAtIE1hdGgubWF4KHJlY3RBLnksIHJlY3RCLnkpKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHhPdmVybGFwICogeU92ZXJsYXApO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBpc1JlY3RPYmplY3QgPSAob2JqKSA9PiBpc051bWVyaWMob2JqLndpZHRoKSAmJiBpc051bWVyaWMob2JqLmhlaWdodCkgJiYgaXNOdW1lcmljKG9iai54KSAmJiBpc051bWVyaWMob2JqLnkpO1xuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IGlzTnVtZXJpYyA9IChuKSA9PiAhaXNOYU4obikgJiYgaXNGaW5pdGUobik7XG4vLyB1c2VkIGZvciBhMTF5IGtleSBib2FyZCBjb250cm9scyBmb3Igbm9kZXMgYW5kIGVkZ2VzXG5jb25zdCBkZXZXYXJuID0gKGlkLCBtZXNzYWdlKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW1JlYWN0IEZsb3ddOiAke21lc3NhZ2V9IEhlbHA6IGh0dHBzOi8vcmVhY3RmbG93LmRldi9lcnJvciMke2lkfWApO1xuICAgIH1cbn07XG5jb25zdCBzbmFwUG9zaXRpb24gPSAocG9zaXRpb24sIHNuYXBHcmlkID0gWzEsIDFdKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogc25hcEdyaWRbMF0gKiBNYXRoLnJvdW5kKHBvc2l0aW9uLnggLyBzbmFwR3JpZFswXSksXG4gICAgICAgIHk6IHNuYXBHcmlkWzFdICogTWF0aC5yb3VuZChwb3NpdGlvbi55IC8gc25hcEdyaWRbMV0pLFxuICAgIH07XG59O1xuY29uc3QgcG9pbnRUb1JlbmRlcmVyUG9pbnQgPSAoeyB4LCB5IH0sIFt0eCwgdHksIHRTY2FsZV0sIHNuYXBUb0dyaWQgPSBmYWxzZSwgc25hcEdyaWQgPSBbMSwgMV0pID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgeDogKHggLSB0eCkgLyB0U2NhbGUsXG4gICAgICAgIHk6ICh5IC0gdHkpIC8gdFNjYWxlLFxuICAgIH07XG4gICAgcmV0dXJuIHNuYXBUb0dyaWQgPyBzbmFwUG9zaXRpb24ocG9zaXRpb24sIHNuYXBHcmlkKSA6IHBvc2l0aW9uO1xufTtcbmNvbnN0IHJlbmRlcmVyUG9pbnRUb1BvaW50ID0gKHsgeCwgeSB9LCBbdHgsIHR5LCB0U2NhbGVdKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAqIHRTY2FsZSArIHR4LFxuICAgICAgICB5OiB5ICogdFNjYWxlICsgdHksXG4gICAgfTtcbn07XG4vKipcbiAqIFJldHVybnMgYSB2aWV3cG9ydCB0aGF0IGVuY2xvc2VzIHRoZSBnaXZlbiBib3VuZHMgd2l0aCBvcHRpb25hbCBwYWRkaW5nLlxuICogQHB1YmxpY1xuICogQHJlbWFya3MgWW91IGNhbiBkZXRlcm1pbmUgYm91bmRzIG9mIG5vZGVzIHdpdGgge0BsaW5rIGdldE5vZGVzQm91bmRzfSBhbmQge0BsaW5rIGdldEJvdW5kc09mUmVjdHN9XG4gKiBAcGFyYW0gYm91bmRzIC0gQm91bmRzIHRvIGZpdCBpbnNpZGUgdmlld3BvcnRcbiAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIGhlaWdodCAgLSBIZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0gbWluWm9vbSAtIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgcmVzdWx0aW5nIHZpZXdwb3J0XG4gKiBAcGFyYW0gbWF4Wm9vbSAtIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgcmVzdWx0aW5nIHZpZXdwb3J0XG4gKiBAcGFyYW0gcGFkZGluZyAtIE9wdGlvbmFsIHBhZGRpbmcgYXJvdW5kIHRoZSBib3VuZHNcbiAqIEByZXR1cm5zIEEgdHJhbnNmb3JuZWQge0BsaW5rIFZpZXdwb3J0fSB0aGF0IGVuY2xvc2VzIHRoZSBnaXZlbiBib3VuZHMgd2hpY2ggeW91IGNhbiBwYXNzIHRvIGUuZy4ge0BsaW5rIHNldFZpZXdwb3J0fVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoXG4gIHsgeDogMCwgeTogMCwgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDB9LFxuICAxMjAwLCA4MDAsIDAuNSwgMik7XG4gKi9cbmNvbnN0IGdldFZpZXdwb3J0Rm9yQm91bmRzID0gKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgcGFkZGluZykgPT4ge1xuICAgIGNvbnN0IHhab29tID0gd2lkdGggLyAoYm91bmRzLndpZHRoICogKDEgKyBwYWRkaW5nKSk7XG4gICAgY29uc3QgeVpvb20gPSBoZWlnaHQgLyAoYm91bmRzLmhlaWdodCAqICgxICsgcGFkZGluZykpO1xuICAgIGNvbnN0IHpvb20gPSBNYXRoLm1pbih4Wm9vbSwgeVpvb20pO1xuICAgIGNvbnN0IGNsYW1wZWRab29tID0gY2xhbXAoem9vbSwgbWluWm9vbSwgbWF4Wm9vbSk7XG4gICAgY29uc3QgYm91bmRzQ2VudGVyWCA9IGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC8gMjtcbiAgICBjb25zdCBib3VuZHNDZW50ZXJZID0gYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0IC8gMjtcbiAgICBjb25zdCB4ID0gd2lkdGggLyAyIC0gYm91bmRzQ2VudGVyWCAqIGNsYW1wZWRab29tO1xuICAgIGNvbnN0IHkgPSBoZWlnaHQgLyAyIC0gYm91bmRzQ2VudGVyWSAqIGNsYW1wZWRab29tO1xuICAgIHJldHVybiB7IHgsIHksIHpvb206IGNsYW1wZWRab29tIH07XG59O1xuY29uc3QgaXNNYWNPcyA9ICgpID0+IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvcj8udXNlckFnZW50Py5pbmRleE9mKCdNYWMnKSA+PSAwO1xuZnVuY3Rpb24gaXNDb29yZGluYXRlRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBleHRlbnQgIT09IHVuZGVmaW5lZCAmJiBleHRlbnQgIT09ICdwYXJlbnQnO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IDAsXG4gICAgICAgIGhlaWdodDogbm9kZS5tZWFzdXJlZD8uaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyAwLFxuICAgIH07XG59XG5mdW5jdGlvbiBub2RlSGFzRGltZW5zaW9ucyhub2RlKSB7XG4gICAgcmV0dXJuICgobm9kZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAobm9kZS5tZWFzdXJlZD8uaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCkgIT09IHVuZGVmaW5lZCk7XG59XG4vKipcbiAqIENvbnZlcnQgY2hpbGQgcG9zaXRpb24gdG8gYWJvc2x1dGUgcG9zaXRpb25cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBwb3NpdGlvblxuICogQHBhcmFtIHBhcmVudElkXG4gKiBAcGFyYW0gbm9kZUxvb2t1cFxuICogQHBhcmFtIG5vZGVPcmlnaW5cbiAqIEByZXR1cm5zIGFuIGludGVybmFsIG5vZGUgd2l0aCBhbiBhYnNvbHV0ZSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24ocG9zaXRpb24sIGRpbWVuc2lvbnMgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSwgcGFyZW50SWQsIG5vZGVMb29rdXAsIG5vZGVPcmlnaW4pIHtcbiAgICBjb25zdCBwb3NpdGlvbkFic29sdXRlID0geyAuLi5wb3NpdGlvbiB9O1xuICAgIGNvbnN0IHBhcmVudCA9IG5vZGVMb29rdXAuZ2V0KHBhcmVudElkKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHBhcmVudC5vcmlnaW4gfHwgbm9kZU9yaWdpbjtcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZS54ICs9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54IC0gKGRpbWVuc2lvbnMud2lkdGggPz8gMCkgKiBvcmlnaW5bMF07XG4gICAgICAgIHBvc2l0aW9uQWJzb2x1dGUueSArPSBwYXJlbnQuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSAtIChkaW1lbnNpb25zLmhlaWdodCA/PyAwKSAqIG9yaWdpblsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uQWJzb2x1dGU7XG59XG5mdW5jdGlvbiBhcmVTZXRzRXF1YWwoYSwgYikge1xuICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgICAgIGlmICghYi5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LCB7IHNuYXBHcmlkID0gWzAsIDBdLCBzbmFwVG9HcmlkID0gZmFsc2UsIHRyYW5zZm9ybSwgY29udGFpbmVyQm91bmRzIH0pIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQpO1xuICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBwb2ludFRvUmVuZGVyZXJQb2ludCh7IHg6IHggLSAoY29udGFpbmVyQm91bmRzPy5sZWZ0ID8/IDApLCB5OiB5IC0gKGNvbnRhaW5lckJvdW5kcz8udG9wID8/IDApIH0sIHRyYW5zZm9ybSk7XG4gICAgY29uc3QgeyB4OiB4U25hcHBlZCwgeTogeVNuYXBwZWQgfSA9IHNuYXBUb0dyaWQgPyBzbmFwUG9zaXRpb24ocG9pbnRlclBvcywgc25hcEdyaWQpIDogcG9pbnRlclBvcztcbiAgICAvLyB3ZSBuZWVkIHRoZSBzbmFwcGVkIHBvc2l0aW9uIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gc2tpcCB1bm5lY2Vzc2FyeSBkcmFnIGV2ZW50c1xuICAgIHJldHVybiB7XG4gICAgICAgIHhTbmFwcGVkLFxuICAgICAgICB5U25hcHBlZCxcbiAgICAgICAgLi4ucG9pbnRlclBvcyxcbiAgICB9O1xufVxuY29uc3QgZ2V0RGltZW5zaW9ucyA9IChub2RlKSA9PiAoe1xuICAgIHdpZHRoOiBub2RlLm9mZnNldFdpZHRoLFxuICAgIGhlaWdodDogbm9kZS5vZmZzZXRIZWlnaHQsXG59KTtcbmNvbnN0IGdldEhvc3RGb3JFbGVtZW50ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQ/LmdldFJvb3ROb2RlPy4oKSB8fCB3aW5kb3c/LmRvY3VtZW50O1xuY29uc3QgaW5wdXRUYWdzID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXTtcbmZ1bmN0aW9uIGlzSW5wdXRET01Ob2RlKGV2ZW50KSB7XG4gICAgLy8gdXNpbmcgY29tcG9zZWQgcGF0aCBmb3IgaGFuZGxpbmcgc2hhZG93IGRvbVxuICAgIGNvbnN0IHRhcmdldCA9IChldmVudC5jb21wb3NlZFBhdGg/LigpPy5bMF0gfHwgZXZlbnQudGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0Py5ub2RlVHlwZSAhPT0gMSAvKiBOb2RlLkVMRU1FTlRfTk9ERSAqLylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGlzSW5wdXQgPSBpbnB1dFRhZ3MuaW5jbHVkZXModGFyZ2V0Lm5vZGVOYW1lKSB8fCB0YXJnZXQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcbiAgICAvLyB3aGVuIGFuIGlucHV0IGZpZWxkIGlzIGZvY3VzZWQgd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGRlbGV0aW9uIG9yIG1vdmVtZW50IG9mIG5vZGVzXG4gICAgcmV0dXJuIGlzSW5wdXQgfHwgISF0YXJnZXQuY2xvc2VzdCgnLm5va2V5Jyk7XG59XG5jb25zdCBpc01vdXNlRXZlbnQgPSAoZXZlbnQpID0+ICdjbGllbnRYJyBpbiBldmVudDtcbmNvbnN0IGdldEV2ZW50UG9zaXRpb24gPSAoZXZlbnQsIGJvdW5kcykgPT4ge1xuICAgIGNvbnN0IGlzTW91c2UgPSBpc01vdXNlRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IGV2dFggPSBpc01vdXNlID8gZXZlbnQuY2xpZW50WCA6IGV2ZW50LnRvdWNoZXM/LlswXS5jbGllbnRYO1xuICAgIGNvbnN0IGV2dFkgPSBpc01vdXNlID8gZXZlbnQuY2xpZW50WSA6IGV2ZW50LnRvdWNoZXM/LlswXS5jbGllbnRZO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2dFggLSAoYm91bmRzPy5sZWZ0ID8/IDApLFxuICAgICAgICB5OiBldnRZIC0gKGJvdW5kcz8udG9wID8/IDApLFxuICAgIH07XG59O1xuLy8gVGhlIGhhbmRsZSBib3VuZHMgYXJlIGNhbGN1bGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG5vZGUgZWxlbWVudC5cbi8vIFdlIHN0b3JlIHRoZW0gaW4gdGhlIGludGVybmFscyBvYmplY3Qgb2YgdGhlIG5vZGUgaW4gb3JkZXIgdG8gYXZvaWRcbi8vIHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25zLlxuY29uc3QgZ2V0SGFuZGxlQm91bmRzID0gKHR5cGUsIG5vZGVFbGVtZW50LCBub2RlQm91bmRzLCB6b29tLCBub2RlSWQpID0+IHtcbiAgICBjb25zdCBoYW5kbGVzID0gbm9kZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7dHlwZX1gKTtcbiAgICBpZiAoIWhhbmRsZXMgfHwgIWhhbmRsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShoYW5kbGVzKS5tYXAoKGhhbmRsZSkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVCb3VuZHMgPSBoYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogaGFuZGxlLmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVpZCcpLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBoYW5kbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZXBvcycpLFxuICAgICAgICAgICAgeDogKGhhbmRsZUJvdW5kcy5sZWZ0IC0gbm9kZUJvdW5kcy5sZWZ0KSAvIHpvb20sXG4gICAgICAgICAgICB5OiAoaGFuZGxlQm91bmRzLnRvcCAtIG5vZGVCb3VuZHMudG9wKSAvIHpvb20sXG4gICAgICAgICAgICAuLi5nZXREaW1lbnNpb25zKGhhbmRsZSksXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBnZXRCZXppZXJFZGdlQ2VudGVyKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlQ29udHJvbFgsIHNvdXJjZUNvbnRyb2xZLCB0YXJnZXRDb250cm9sWCwgdGFyZ2V0Q29udHJvbFksIH0pIHtcbiAgICAvLyBjdWJpYyBiZXppZXIgdD0wLjUgbWlkIHBvaW50LCBub3QgdGhlIGFjdHVhbCBtaWQgcG9pbnQsIGJ1dCBlYXN5IHRvIGNhbGN1bGF0ZVxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY3NTE2MTAxL2hvdy10by1maW5kLWRpc3RhbmNlLW1pZC1wb2ludC1vZi1iZXppZXItY3VydmVcbiAgICBjb25zdCBjZW50ZXJYID0gc291cmNlWCAqIDAuMTI1ICsgc291cmNlQ29udHJvbFggKiAwLjM3NSArIHRhcmdldENvbnRyb2xYICogMC4zNzUgKyB0YXJnZXRYICogMC4xMjU7XG4gICAgY29uc3QgY2VudGVyWSA9IHNvdXJjZVkgKiAwLjEyNSArIHNvdXJjZUNvbnRyb2xZICogMC4zNzUgKyB0YXJnZXRDb250cm9sWSAqIDAuMzc1ICsgdGFyZ2V0WSAqIDAuMTI1O1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmFicyhjZW50ZXJYIC0gc291cmNlWCk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguYWJzKGNlbnRlclkgLSBzb3VyY2VZKTtcbiAgICByZXR1cm4gW2NlbnRlclgsIGNlbnRlclksIG9mZnNldFgsIG9mZnNldFldO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udHJvbE9mZnNldChkaXN0YW5jZSwgY3VydmF0dXJlKSB7XG4gICAgaWYgKGRpc3RhbmNlID49IDApIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIGRpc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmF0dXJlICogMjUgKiBNYXRoLnNxcnQoLWRpc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHsgcG9zLCB4MSwgeTEsIHgyLCB5MiwgYyB9KSB7XG4gICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcmV0dXJuIFt4MSAtIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeDEgLSB4MiwgYyksIHkxXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5SaWdodDpcbiAgICAgICAgICAgIHJldHVybiBbeDEgKyBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHgyIC0geDEsIGMpLCB5MV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uVG9wOlxuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEgLSBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHkxIC0geTIsIGMpXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Cb3R0b206XG4gICAgICAgICAgICByZXR1cm4gW3gxLCB5MSArIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeTIgLSB5MSwgYyldO1xuICAgIH1cbn1cbi8qKlxuICogR2V0IGEgYmV6aWVyIHBhdGggZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy5zb3VyY2VYIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHNvdXJjZSBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMuc291cmNlWSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBzb3VyY2UgaGFuZGxlXG4gKiBAcGFyYW0gcGFyYW1zLnNvdXJjZVBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBzb3VyY2UgaGFuZGxlIChkZWZhdWx0OiBQb3NpdGlvbi5Cb3R0b20pXG4gKiBAcGFyYW0gcGFyYW1zLnRhcmdldFggLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy50YXJnZXRZIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMudGFyZ2V0UG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBoYW5kbGUgKGRlZmF1bHQ6IFBvc2l0aW9uLlRvcClcbiAqIEBwYXJhbSBwYXJhbXMuY3VydmF0dXJlIC0gVGhlIGN1cnZhdHVyZSBvZiB0aGUgYmV6aWVyIGVkZ2VcbiAqIEByZXR1cm5zIEEgcGF0aCBzdHJpbmcgeW91IGNhbiB1c2UgaW4gYW4gU1ZHLCB0aGUgbGFiZWxYIGFuZCBsYWJlbFkgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKSBhbmQgb2Zmc2V0WCwgb2Zmc2V0WSBiZXR3ZWVuIHNvdXJjZSBoYW5kbGUgYW5kIGxhYmVsXG4gKiBAZXhhbXBsZVxuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAgICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gICAgXG4gICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEJlemllclBhdGgoe1xuICAgICAgc291cmNlWDogc291cmNlLngsXG4gICAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAgICAgIHNvdXJjZVBvc2l0aW9uOiBQb3NpdGlvbi5SaWdodCxcbiAgICAgIHRhcmdldFg6IHRhcmdldC54LFxuICAgICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gICAgICB0YXJnZXRQb3NpdGlvbjogUG9zaXRpb24uTGVmdCxcbn0pO1xuICovXG5mdW5jdGlvbiBnZXRCZXppZXJQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBjdXJ2YXR1cmUgPSAwLjI1LCB9KSB7XG4gICAgY29uc3QgW3NvdXJjZUNvbnRyb2xYLCBzb3VyY2VDb250cm9sWV0gPSBnZXRDb250cm9sV2l0aEN1cnZhdHVyZSh7XG4gICAgICAgIHBvczogc291cmNlUG9zaXRpb24sXG4gICAgICAgIHgxOiBzb3VyY2VYLFxuICAgICAgICB5MTogc291cmNlWSxcbiAgICAgICAgeDI6IHRhcmdldFgsXG4gICAgICAgIHkyOiB0YXJnZXRZLFxuICAgICAgICBjOiBjdXJ2YXR1cmUsXG4gICAgfSk7XG4gICAgY29uc3QgW3RhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWV0gPSBnZXRDb250cm9sV2l0aEN1cnZhdHVyZSh7XG4gICAgICAgIHBvczogdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIHgxOiB0YXJnZXRYLFxuICAgICAgICB5MTogdGFyZ2V0WSxcbiAgICAgICAgeDI6IHNvdXJjZVgsXG4gICAgICAgIHkyOiBzb3VyY2VZLFxuICAgICAgICBjOiBjdXJ2YXR1cmUsXG4gICAgfSk7XG4gICAgY29uc3QgW2xhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEJlemllckVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgICAgICBzb3VyY2VDb250cm9sWCxcbiAgICAgICAgc291cmNlQ29udHJvbFksXG4gICAgICAgIHRhcmdldENvbnRyb2xYLFxuICAgICAgICB0YXJnZXRDb250cm9sWSxcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBgTSR7c291cmNlWH0sJHtzb3VyY2VZfSBDJHtzb3VyY2VDb250cm9sWH0sJHtzb3VyY2VDb250cm9sWX0gJHt0YXJnZXRDb250cm9sWH0sJHt0YXJnZXRDb250cm9sWX0gJHt0YXJnZXRYfSwke3RhcmdldFl9YCxcbiAgICAgICAgbGFiZWxYLFxuICAgICAgICBsYWJlbFksXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFksXG4gICAgXTtcbn1cblxuLy8gdGhpcyBpcyB1c2VkIGZvciBzdHJhaWdodCBlZGdlcyBhbmQgc2ltcGxlIHNtb290aHN0ZXAgZWRnZXMgKExUUiwgUlRMLCBCVFQsIFRUQilcbmZ1bmN0aW9uIGdldEVkZ2VDZW50ZXIoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCB9KSB7XG4gICAgY29uc3QgeE9mZnNldCA9IE1hdGguYWJzKHRhcmdldFggLSBzb3VyY2VYKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWCA9IHRhcmdldFggPCBzb3VyY2VYID8gdGFyZ2V0WCArIHhPZmZzZXQgOiB0YXJnZXRYIC0geE9mZnNldDtcbiAgICBjb25zdCB5T2Zmc2V0ID0gTWF0aC5hYnModGFyZ2V0WSAtIHNvdXJjZVkpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gdGFyZ2V0WSA8IHNvdXJjZVkgPyB0YXJnZXRZICsgeU9mZnNldCA6IHRhcmdldFkgLSB5T2Zmc2V0O1xuICAgIHJldHVybiBbY2VudGVyWCwgY2VudGVyWSwgeE9mZnNldCwgeU9mZnNldF07XG59XG5mdW5jdGlvbiBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgoeyBzb3VyY2VOb2RlLCB0YXJnZXROb2RlLCBzZWxlY3RlZCA9IGZhbHNlLCB6SW5kZXggPSAwLCBlbGV2YXRlT25TZWxlY3QgPSBmYWxzZSwgfSkge1xuICAgIGlmICghZWxldmF0ZU9uU2VsZWN0KSB7XG4gICAgICAgIHJldHVybiB6SW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VPckNvbm5lY3RlZE5vZGVTZWxlY3RlZCA9IHNlbGVjdGVkIHx8IHRhcmdldE5vZGUuc2VsZWN0ZWQgfHwgc291cmNlTm9kZS5zZWxlY3RlZDtcbiAgICBjb25zdCBzZWxlY3RlZFpJbmRleCA9IE1hdGgubWF4KHNvdXJjZU5vZGUuaW50ZXJuYWxzLnogfHwgMCwgdGFyZ2V0Tm9kZS5pbnRlcm5hbHMueiB8fCAwLCAxMDAwKTtcbiAgICByZXR1cm4gekluZGV4ICsgKGVkZ2VPckNvbm5lY3RlZE5vZGVTZWxlY3RlZCA/IHNlbGVjdGVkWkluZGV4IDogMCk7XG59XG5mdW5jdGlvbiBpc0VkZ2VWaXNpYmxlKHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSwgd2lkdGgsIGhlaWdodCwgdHJhbnNmb3JtIH0pIHtcbiAgICBjb25zdCBlZGdlQm94ID0gZ2V0Qm91bmRzT2ZCb3hlcyhub2RlVG9Cb3goc291cmNlTm9kZSksIG5vZGVUb0JveCh0YXJnZXROb2RlKSk7XG4gICAgaWYgKGVkZ2VCb3gueCA9PT0gZWRnZUJveC54Mikge1xuICAgICAgICBlZGdlQm94LngyICs9IDE7XG4gICAgfVxuICAgIGlmIChlZGdlQm94LnkgPT09IGVkZ2VCb3gueTIpIHtcbiAgICAgICAgZWRnZUJveC55MiArPSAxO1xuICAgIH1cbiAgICBjb25zdCB2aWV3UmVjdCA9IHtcbiAgICAgICAgeDogLXRyYW5zZm9ybVswXSAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgeTogLXRyYW5zZm9ybVsxXSAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgd2lkdGg6IHdpZHRoIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCAvIHRyYW5zZm9ybVsyXSxcbiAgICB9O1xuICAgIHJldHVybiBnZXRPdmVybGFwcGluZ0FyZWEodmlld1JlY3QsIGJveFRvUmVjdChlZGdlQm94KSkgPiAwO1xufVxuY29uc3QgZ2V0RWRnZUlkID0gKHsgc291cmNlLCBzb3VyY2VIYW5kbGUsIHRhcmdldCwgdGFyZ2V0SGFuZGxlIH0pID0+IGB4eS1lZGdlX18ke3NvdXJjZX0ke3NvdXJjZUhhbmRsZSB8fCAnJ30tJHt0YXJnZXR9JHt0YXJnZXRIYW5kbGUgfHwgJyd9YDtcbmNvbnN0IGNvbm5lY3Rpb25FeGlzdHMgPSAoZWRnZSwgZWRnZXMpID0+IHtcbiAgICByZXR1cm4gZWRnZXMuc29tZSgoZWwpID0+IGVsLnNvdXJjZSA9PT0gZWRnZS5zb3VyY2UgJiZcbiAgICAgICAgZWwudGFyZ2V0ID09PSBlZGdlLnRhcmdldCAmJlxuICAgICAgICAoZWwuc291cmNlSGFuZGxlID09PSBlZGdlLnNvdXJjZUhhbmRsZSB8fCAoIWVsLnNvdXJjZUhhbmRsZSAmJiAhZWRnZS5zb3VyY2VIYW5kbGUpKSAmJlxuICAgICAgICAoZWwudGFyZ2V0SGFuZGxlID09PSBlZGdlLnRhcmdldEhhbmRsZSB8fCAoIWVsLnRhcmdldEhhbmRsZSAmJiAhZWRnZS50YXJnZXRIYW5kbGUpKSk7XG59O1xuLyoqXG4gKiBUaGlzIHV0aWwgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhZGQgYSBuZXcgRWRnZSB0byBhbiBhcnJheSBvZiBlZGdlc1xuICogQHJlbWFya3MgSXQgYWxzbyBwZXJmb3JtcyBzb21lIHZhbGlkYXRpb24gdG8gbWFrZSBzdXJlIHlvdSBkb24ndCBhZGQgYW4gaW52YWxpZCBlZGdlIG9yIGR1cGxpY2F0ZSBhbiBleGlzdGluZyBvbmUuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gZWRnZVBhcmFtcyAtIEVpdGhlciBhbiBFZGdlIG9yIGEgQ29ubmVjdGlvbiB5b3Ugd2FudCB0byBhZGRcbiAqIEBwYXJhbSBlZGdlcyAtICBUaGUgYXJyYXkgb2YgYWxsIGN1cnJlbnQgZWRnZXNcbiAqIEByZXR1cm5zIEEgbmV3IGFycmF5IG9mIGVkZ2VzIHdpdGggdGhlIG5ldyBlZGdlIGFkZGVkXG4gKi9cbmNvbnN0IGFkZEVkZ2UgPSAoZWRnZVBhcmFtcywgZWRnZXMpID0+IHtcbiAgICBpZiAoIWVkZ2VQYXJhbXMuc291cmNlIHx8ICFlZGdlUGFyYW1zLnRhcmdldCkge1xuICAgICAgICBkZXZXYXJuKCcwMDYnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNiddKCkpO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGxldCBlZGdlO1xuICAgIGlmIChpc0VkZ2VCYXNlKGVkZ2VQYXJhbXMpKSB7XG4gICAgICAgIGVkZ2UgPSB7IC4uLmVkZ2VQYXJhbXMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVkZ2UgPSB7XG4gICAgICAgICAgICAuLi5lZGdlUGFyYW1zLFxuICAgICAgICAgICAgaWQ6IGdldEVkZ2VJZChlZGdlUGFyYW1zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25FeGlzdHMoZWRnZSwgZWRnZXMpKSB7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgaWYgKGVkZ2Uuc291cmNlSGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBlZGdlLnNvdXJjZUhhbmRsZTtcbiAgICB9XG4gICAgaWYgKGVkZ2UudGFyZ2V0SGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBlZGdlLnRhcmdldEhhbmRsZTtcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2VzLmNvbmNhdChlZGdlKTtcbn07XG4vKipcbiAqIEEgaGFuZHkgdXRpbGl0eSB0byByZWNvbm5lY3QgYW4gZXhpc3RpbmcgZWRnZSB3aXRoIG5ldyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gb2xkRWRnZSAtIFRoZSBlZGdlIHlvdSB3YW50IHRvIHVwZGF0ZVxuICogQHBhcmFtIG5ld0Nvbm5lY3Rpb24gLSBUaGUgbmV3IGNvbm5lY3Rpb24geW91IHdhbnQgdG8gdXBkYXRlIHRoZSBlZGdlIHdpdGhcbiAqIEBwYXJhbSBlZGdlcyAtIFRoZSBhcnJheSBvZiBhbGwgY3VycmVudCBlZGdlc1xuICogQHBhcmFtIG9wdGlvbnMuc2hvdWxkUmVwbGFjZUlkIC0gc2hvdWxkIHRoZSBpZCBvZiB0aGUgb2xkIGVkZ2UgYmUgcmVwbGFjZWQgd2l0aCB0aGUgbmV3IGNvbm5lY3Rpb24gaWRcbiAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIGVkZ2VzIGFycmF5XG4gKi9cbmNvbnN0IHJlY29ubmVjdEVkZ2UgPSAob2xkRWRnZSwgbmV3Q29ubmVjdGlvbiwgZWRnZXMsIG9wdGlvbnMgPSB7IHNob3VsZFJlcGxhY2VJZDogdHJ1ZSB9KSA9PiB7XG4gICAgY29uc3QgeyBpZDogb2xkRWRnZUlkLCAuLi5yZXN0IH0gPSBvbGRFZGdlO1xuICAgIGlmICghbmV3Q29ubmVjdGlvbi5zb3VyY2UgfHwgIW5ld0Nvbm5lY3Rpb24udGFyZ2V0KSB7XG4gICAgICAgIGRldldhcm4oJzAwNicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA2J10oKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgY29uc3QgZm91bmRFZGdlID0gZWRnZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gb2xkRWRnZS5pZCk7XG4gICAgaWYgKCFmb3VuZEVkZ2UpIHtcbiAgICAgICAgZGV2V2FybignMDA3JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDcnXShvbGRFZGdlSWQpKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgb2xkIGVkZ2UgYW5kIGNyZWF0ZSB0aGUgbmV3IGVkZ2Ugd2l0aCBwYXJhbWV0ZXJzIG9mIG9sZCBlZGdlLlxuICAgIGNvbnN0IGVkZ2UgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGlkOiBvcHRpb25zLnNob3VsZFJlcGxhY2VJZCA/IGdldEVkZ2VJZChuZXdDb25uZWN0aW9uKSA6IG9sZEVkZ2VJZCxcbiAgICAgICAgc291cmNlOiBuZXdDb25uZWN0aW9uLnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiBuZXdDb25uZWN0aW9uLnRhcmdldCxcbiAgICAgICAgc291cmNlSGFuZGxlOiBuZXdDb25uZWN0aW9uLnNvdXJjZUhhbmRsZSxcbiAgICAgICAgdGFyZ2V0SGFuZGxlOiBuZXdDb25uZWN0aW9uLnRhcmdldEhhbmRsZSxcbiAgICB9O1xuICAgIHJldHVybiBlZGdlcy5maWx0ZXIoKGUpID0+IGUuaWQgIT09IG9sZEVkZ2VJZCkuY29uY2F0KGVkZ2UpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBzdHJhaWdodCBwYXRoIGZyb20gc291cmNlIHRvIHRhcmdldCBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMuc291cmNlWCAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBzb3VyY2UgaGFuZGxlXG4gKiBAcGFyYW0gcGFyYW1zLnNvdXJjZVkgLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgc291cmNlIGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy50YXJnZXRYIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHRhcmdldCBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMudGFyZ2V0WSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgaGFuZGxlXG4gKiBAcmV0dXJucyBBIHBhdGggc3RyaW5nIHlvdSBjYW4gdXNlIGluIGFuIFNWRywgdGhlIGxhYmVsWCBhbmQgbGFiZWxZIHBvc2l0aW9uIChjZW50ZXIgb2YgcGF0aCkgYW5kIG9mZnNldFgsIG9mZnNldFkgYmV0d2VlbiBzb3VyY2UgaGFuZGxlIGFuZCBsYWJlbFxuICogQGV4YW1wbGVcbiAqICBjb25zdCBzb3VyY2UgPSB7IHg6IDAsIHk6IDIwIH07XG4gICAgY29uc3QgdGFyZ2V0ID0geyB4OiAxNTAsIHk6IDEwMCB9O1xuICAgIFxuICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRTdHJhaWdodFBhdGgoe1xuICAgICAgc291cmNlWDogc291cmNlLngsXG4gICAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAgICAgIHNvdXJjZVBvc2l0aW9uOiBQb3NpdGlvbi5SaWdodCxcbiAgICAgIHRhcmdldFg6IHRhcmdldC54LFxuICAgICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gICAgICB0YXJnZXRQb3NpdGlvbjogUG9zaXRpb24uTGVmdCxcbiAgICB9KTtcbiAqL1xuZnVuY3Rpb24gZ2V0U3RyYWlnaHRQYXRoKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgfSkge1xuICAgIGNvbnN0IFtsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSxcbiAgICB9KTtcbiAgICByZXR1cm4gW2BNICR7c291cmNlWH0sJHtzb3VyY2VZfUwgJHt0YXJnZXRYfSwke3RhcmdldFl9YCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldO1xufVxuXG5jb25zdCBoYW5kbGVEaXJlY3Rpb25zID0ge1xuICAgIFtQb3NpdGlvbi5MZWZ0XTogeyB4OiAtMSwgeTogMCB9LFxuICAgIFtQb3NpdGlvbi5SaWdodF06IHsgeDogMSwgeTogMCB9LFxuICAgIFtQb3NpdGlvbi5Ub3BdOiB7IHg6IDAsIHk6IC0xIH0sXG4gICAgW1Bvc2l0aW9uLkJvdHRvbV06IHsgeDogMCwgeTogMSB9LFxufTtcbmNvbnN0IGdldERpcmVjdGlvbiA9ICh7IHNvdXJjZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldCwgfSkgPT4ge1xuICAgIGlmIChzb3VyY2VQb3NpdGlvbiA9PT0gUG9zaXRpb24uTGVmdCB8fCBzb3VyY2VQb3NpdGlvbiA9PT0gUG9zaXRpb24uUmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS54IDwgdGFyZ2V0LnggPyB7IHg6IDEsIHk6IDAgfSA6IHsgeDogLTEsIHk6IDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZS55IDwgdGFyZ2V0LnkgPyB7IHg6IDAsIHk6IDEgfSA6IHsgeDogMCwgeTogLTEgfTtcbn07XG5jb25zdCBkaXN0YW5jZSA9IChhLCBiKSA9PiBNYXRoLnNxcnQoTWF0aC5wb3coYi54IC0gYS54LCAyKSArIE1hdGgucG93KGIueSAtIGEueSwgMikpO1xuLy8gaXRoIHRoaXMgZnVuY3Rpb24gd2UgdHJ5IHRvIG1pbWljIGEgb3J0aG9nb25hbCBlZGdlIHJvdXRpbmcgYmVoYXZpb3VyXG4vLyBJdCdzIG5vdCBhcyBnb29kIGFzIGEgcmVhbCBvcnRob2dvbmFsIGVkZ2Ugcm91dGluZyBidXQgaXQncyBmYXN0ZXIgYW5kIGdvb2QgZW5vdWdoIGFzIGEgZGVmYXVsdCBmb3Igc3RlcCBhbmQgc21vb3RoIHN0ZXAgZWRnZXNcbmZ1bmN0aW9uIGdldFBvaW50cyh7IHNvdXJjZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldCwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGNlbnRlciwgb2Zmc2V0LCB9KSB7XG4gICAgY29uc3Qgc291cmNlRGlyID0gaGFuZGxlRGlyZWN0aW9uc1tzb3VyY2VQb3NpdGlvbl07XG4gICAgY29uc3QgdGFyZ2V0RGlyID0gaGFuZGxlRGlyZWN0aW9uc1t0YXJnZXRQb3NpdGlvbl07XG4gICAgY29uc3Qgc291cmNlR2FwcGVkID0geyB4OiBzb3VyY2UueCArIHNvdXJjZURpci54ICogb2Zmc2V0LCB5OiBzb3VyY2UueSArIHNvdXJjZURpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgdGFyZ2V0R2FwcGVkID0geyB4OiB0YXJnZXQueCArIHRhcmdldERpci54ICogb2Zmc2V0LCB5OiB0YXJnZXQueSArIHRhcmdldERpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgZGlyID0gZ2V0RGlyZWN0aW9uKHtcbiAgICAgICAgc291cmNlOiBzb3VyY2VHYXBwZWQsXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldEdhcHBlZCxcbiAgICB9KTtcbiAgICBjb25zdCBkaXJBY2Nlc3NvciA9IGRpci54ICE9PSAwID8gJ3gnIDogJ3knO1xuICAgIGNvbnN0IGN1cnJEaXIgPSBkaXJbZGlyQWNjZXNzb3JdO1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBsZXQgY2VudGVyWCwgY2VudGVyWTtcbiAgICBjb25zdCBzb3VyY2VHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCB0YXJnZXRHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCBbZGVmYXVsdENlbnRlclgsIGRlZmF1bHRDZW50ZXJZLCBkZWZhdWx0T2Zmc2V0WCwgZGVmYXVsdE9mZnNldFldID0gZ2V0RWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICAgICAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAgICAgICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gICAgICAgIHRhcmdldFk6IHRhcmdldC55LFxuICAgIH0pO1xuICAgIC8vIG9wcG9zaXRlIGhhbmRsZSBwb3NpdGlvbnMsIGRlZmF1bHQgY2FzZVxuICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdICogdGFyZ2V0RGlyW2RpckFjY2Vzc29yXSA9PT0gLTEpIHtcbiAgICAgICAgY2VudGVyWCA9IGNlbnRlci54ID8/IGRlZmF1bHRDZW50ZXJYO1xuICAgICAgICBjZW50ZXJZID0gY2VudGVyLnkgPz8gZGVmYXVsdENlbnRlclk7XG4gICAgICAgIC8vICAgIC0tLT5cbiAgICAgICAgLy8gICAgfFxuICAgICAgICAvLyA+LS0tXG4gICAgICAgIGNvbnN0IHZlcnRpY2FsU3BsaXQgPSBbXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHNvdXJjZUdhcHBlZC55IH0sXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHRhcmdldEdhcHBlZC55IH0sXG4gICAgICAgIF07XG4gICAgICAgIC8vICAgIHxcbiAgICAgICAgLy8gIC0tLVxuICAgICAgICAvLyAgfFxuICAgICAgICBjb25zdCBob3Jpem9udGFsU3BsaXQgPSBbXG4gICAgICAgICAgICB7IHg6IHNvdXJjZUdhcHBlZC54LCB5OiBjZW50ZXJZIH0sXG4gICAgICAgICAgICB7IHg6IHRhcmdldEdhcHBlZC54LCB5OiBjZW50ZXJZIH0sXG4gICAgICAgIF07XG4gICAgICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSBjdXJyRGlyKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gdmVydGljYWxTcGxpdCA6IGhvcml6b250YWxTcGxpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyBob3Jpem9udGFsU3BsaXQgOiB2ZXJ0aWNhbFNwbGl0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzb3VyY2VUYXJnZXQgbWVhbnMgd2UgdGFrZSB4IGZyb20gc291cmNlIGFuZCB5IGZyb20gdGFyZ2V0LCB0YXJnZXRTb3VyY2UgaXMgdGhlIG9wcG9zaXRlXG4gICAgICAgIGNvbnN0IHNvdXJjZVRhcmdldCA9IFt7IHg6IHNvdXJjZUdhcHBlZC54LCB5OiB0YXJnZXRHYXBwZWQueSB9XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0U291cmNlID0gW3sgeDogdGFyZ2V0R2FwcGVkLngsIHk6IHNvdXJjZUdhcHBlZC55IH1dO1xuICAgICAgICAvLyB0aGlzIGhhbmRsZXMgZWRnZXMgd2l0aCBzYW1lIGhhbmRsZSBwb3NpdGlvbnNcbiAgICAgICAgaWYgKGRpckFjY2Vzc29yID09PSAneCcpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHNvdXJjZURpci54ID09PSBjdXJyRGlyID8gdGFyZ2V0U291cmNlIDogc291cmNlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzID0gc291cmNlRGlyLnkgPT09IGN1cnJEaXIgPyBzb3VyY2VUYXJnZXQgOiB0YXJnZXRTb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVBvc2l0aW9uID09PSB0YXJnZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKHNvdXJjZVtkaXJBY2Nlc3Nvcl0gLSB0YXJnZXRbZGlyQWNjZXNzb3JdKTtcbiAgICAgICAgICAgIC8vIGlmIGFuIGVkZ2UgZ29lcyBmcm9tIHJpZ2h0IHRvIHJpZ2h0IGZvciBleGFtcGxlIChzb3VyY2VQb3NpdGlvbiA9PT0gdGFyZ2V0UG9zaXRpb24pIGFuZCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBzb3VyY2UueCBhbmQgdGFyZ2V0LnggaXMgbGVzcyB0aGFuIHRoZSBvZmZzZXQsIHRoZSBhZGRlZCBwb2ludCBhbmQgdGhlIGdhcHBlZCBzb3VyY2UvdGFyZ2V0IHdpbGwgb3ZlcmxhcC4gVGhpcyBsZWFkcyB0byBhIHdlaXJkIGVkZ2UgcGF0aC4gVG8gYXZvaWQgdGhpcyB3ZSBhZGQgYSBnYXBPZmZzZXQgdG8gdGhlIHNvdXJjZS90YXJnZXRcbiAgICAgICAgICAgIGlmIChkaWZmIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhcE9mZnNldCA9IE1hdGgubWluKG9mZnNldCAtIDEsIG9mZnNldCAtIGRpZmYpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSBjdXJyRGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUdhcE9mZnNldFtkaXJBY2Nlc3Nvcl0gPSAoc291cmNlR2FwcGVkW2RpckFjY2Vzc29yXSA+IHNvdXJjZVtkaXJBY2Nlc3Nvcl0gPyAtMSA6IDEpICogZ2FwT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0R2FwT2Zmc2V0W2RpckFjY2Vzc29yXSA9ICh0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JdID4gdGFyZ2V0W2RpckFjY2Vzc29yXSA/IC0xIDogMSkgKiBnYXBPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZXNlIGFyZSBjb25kaXRpb25zIGZvciBoYW5kbGluZyBtaXhlZCBoYW5kbGUgcG9zaXRpb25zIGxpa2UgUmlnaHQgLT4gQm90dG9tIGZvciBleGFtcGxlXG4gICAgICAgIGlmIChzb3VyY2VQb3NpdGlvbiAhPT0gdGFyZ2V0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGRpckFjY2Vzc29yT3Bwb3NpdGUgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICAgICAgICAgICAgY29uc3QgaXNTYW1lRGlyID0gc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gdGFyZ2V0RGlyW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlR3RUYXJnZXRPcHBvID0gc291cmNlR2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdID4gdGFyZ2V0R2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlTHRUYXJnZXRPcHBvID0gc291cmNlR2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdIDwgdGFyZ2V0R2FwcGVkW2RpckFjY2Vzc29yT3Bwb3NpdGVdO1xuICAgICAgICAgICAgY29uc3QgZmxpcFNvdXJjZVRhcmdldCA9IChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSAxICYmICgoIWlzU2FtZURpciAmJiBzb3VyY2VHdFRhcmdldE9wcG8pIHx8IChpc1NhbWVEaXIgJiYgc291cmNlTHRUYXJnZXRPcHBvKSkpIHx8XG4gICAgICAgICAgICAgICAgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gIT09IDEgJiYgKCghaXNTYW1lRGlyICYmIHNvdXJjZUx0VGFyZ2V0T3BwbykgfHwgKGlzU2FtZURpciAmJiBzb3VyY2VHdFRhcmdldE9wcG8pKSk7XG4gICAgICAgICAgICBpZiAoZmxpcFNvdXJjZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyBzb3VyY2VUYXJnZXQgOiB0YXJnZXRTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlR2FwUG9pbnQgPSB7IHg6IHNvdXJjZUdhcHBlZC54ICsgc291cmNlR2FwT2Zmc2V0LngsIHk6IHNvdXJjZUdhcHBlZC55ICsgc291cmNlR2FwT2Zmc2V0LnkgfTtcbiAgICAgICAgY29uc3QgdGFyZ2V0R2FwUG9pbnQgPSB7IHg6IHRhcmdldEdhcHBlZC54ICsgdGFyZ2V0R2FwT2Zmc2V0LngsIHk6IHRhcmdldEdhcHBlZC55ICsgdGFyZ2V0R2FwT2Zmc2V0LnkgfTtcbiAgICAgICAgY29uc3QgbWF4WERpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5hYnMoc291cmNlR2FwUG9pbnQueCAtIHBvaW50c1swXS54KSwgTWF0aC5hYnModGFyZ2V0R2FwUG9pbnQueCAtIHBvaW50c1swXS54KSk7XG4gICAgICAgIGNvbnN0IG1heFlEaXN0YW5jZSA9IE1hdGgubWF4KE1hdGguYWJzKHNvdXJjZUdhcFBvaW50LnkgLSBwb2ludHNbMF0ueSksIE1hdGguYWJzKHRhcmdldEdhcFBvaW50LnkgLSBwb2ludHNbMF0ueSkpO1xuICAgICAgICAvLyB3ZSB3YW50IHRvIHBsYWNlIHRoZSBsYWJlbCBvbiB0aGUgbG9uZ2VzdCBzZWdtZW50IG9mIHRoZSBlZGdlXG4gICAgICAgIGlmIChtYXhYRGlzdGFuY2UgPj0gbWF4WURpc3RhbmNlKSB7XG4gICAgICAgICAgICBjZW50ZXJYID0gKHNvdXJjZUdhcFBvaW50LnggKyB0YXJnZXRHYXBQb2ludC54KSAvIDI7XG4gICAgICAgICAgICBjZW50ZXJZID0gcG9pbnRzWzBdLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjZW50ZXJYID0gcG9pbnRzWzBdLng7XG4gICAgICAgICAgICBjZW50ZXJZID0gKHNvdXJjZUdhcFBvaW50LnkgKyB0YXJnZXRHYXBQb2ludC55KSAvIDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGF0aFBvaW50cyA9IFtcbiAgICAgICAgc291cmNlLFxuICAgICAgICB7IHg6IHNvdXJjZUdhcHBlZC54ICsgc291cmNlR2FwT2Zmc2V0LngsIHk6IHNvdXJjZUdhcHBlZC55ICsgc291cmNlR2FwT2Zmc2V0LnkgfSxcbiAgICAgICAgLi4ucG9pbnRzLFxuICAgICAgICB7IHg6IHRhcmdldEdhcHBlZC54ICsgdGFyZ2V0R2FwT2Zmc2V0LngsIHk6IHRhcmdldEdhcHBlZC55ICsgdGFyZ2V0R2FwT2Zmc2V0LnkgfSxcbiAgICAgICAgdGFyZ2V0LFxuICAgIF07XG4gICAgcmV0dXJuIFtwYXRoUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCBkZWZhdWx0T2Zmc2V0WCwgZGVmYXVsdE9mZnNldFldO1xufVxuZnVuY3Rpb24gZ2V0QmVuZChhLCBiLCBjLCBzaXplKSB7XG4gICAgY29uc3QgYmVuZFNpemUgPSBNYXRoLm1pbihkaXN0YW5jZShhLCBiKSAvIDIsIGRpc3RhbmNlKGIsIGMpIC8gMiwgc2l6ZSk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBiO1xuICAgIC8vIG5vIGJlbmRcbiAgICBpZiAoKGEueCA9PT0geCAmJiB4ID09PSBjLngpIHx8IChhLnkgPT09IHkgJiYgeSA9PT0gYy55KSkge1xuICAgICAgICByZXR1cm4gYEwke3h9ICR7eX1gO1xuICAgIH1cbiAgICAvLyBmaXJzdCBzZWdtZW50IGlzIGhvcml6b250YWxcbiAgICBpZiAoYS55ID09PSB5KSB7XG4gICAgICAgIGNvbnN0IHhEaXIgPSBhLnggPCBjLnggPyAtMSA6IDE7XG4gICAgICAgIGNvbnN0IHlEaXIgPSBhLnkgPCBjLnkgPyAxIDogLTE7XG4gICAgICAgIHJldHVybiBgTCAke3ggKyBiZW5kU2l6ZSAqIHhEaXJ9LCR7eX1RICR7eH0sJHt5fSAke3h9LCR7eSArIGJlbmRTaXplICogeURpcn1gO1xuICAgIH1cbiAgICBjb25zdCB4RGlyID0gYS54IDwgYy54ID8gMSA6IC0xO1xuICAgIGNvbnN0IHlEaXIgPSBhLnkgPCBjLnkgPyAtMSA6IDE7XG4gICAgcmV0dXJuIGBMICR7eH0sJHt5ICsgYmVuZFNpemUgKiB5RGlyfVEgJHt4fSwke3l9ICR7eCArIGJlbmRTaXplICogeERpcn0sJHt5fWA7XG59XG4vKipcbiAqIEdldCBhIHNtb290aCBzdGVwIHBhdGggZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy5zb3VyY2VYIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHNvdXJjZSBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMuc291cmNlWSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBzb3VyY2UgaGFuZGxlXG4gKiBAcGFyYW0gcGFyYW1zLnNvdXJjZVBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBzb3VyY2UgaGFuZGxlIChkZWZhdWx0OiBQb3NpdGlvbi5Cb3R0b20pXG4gKiBAcGFyYW0gcGFyYW1zLnRhcmdldFggLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy50YXJnZXRZIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMudGFyZ2V0UG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBoYW5kbGUgKGRlZmF1bHQ6IFBvc2l0aW9uLlRvcClcbiAqIEByZXR1cm5zIEEgcGF0aCBzdHJpbmcgeW91IGNhbiB1c2UgaW4gYW4gU1ZHLCB0aGUgbGFiZWxYIGFuZCBsYWJlbFkgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKSBhbmQgb2Zmc2V0WCwgb2Zmc2V0WSBiZXR3ZWVuIHNvdXJjZSBoYW5kbGUgYW5kIGxhYmVsXG4gKiBAZXhhbXBsZVxuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAgICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gICAgXG4gICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAgICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICAgICAgc291cmNlWTogc291cmNlLnksXG4gICAgICBzb3VyY2VQb3NpdGlvbjogUG9zaXRpb24uUmlnaHQsXG4gICAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAgICAgIHRhcmdldFk6IHRhcmdldC55LFxuICAgICAgdGFyZ2V0UG9zaXRpb246IFBvc2l0aW9uLkxlZnQsXG4gICAgfSk7XG4gKi9cbmZ1bmN0aW9uIGdldFNtb290aFN0ZXBQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBib3JkZXJSYWRpdXMgPSA1LCBjZW50ZXJYLCBjZW50ZXJZLCBvZmZzZXQgPSAyMCwgfSkge1xuICAgIGNvbnN0IFtwb2ludHMsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldFBvaW50cyh7XG4gICAgICAgIHNvdXJjZTogeyB4OiBzb3VyY2VYLCB5OiBzb3VyY2VZIH0sXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IHsgeDogdGFyZ2V0WCwgeTogdGFyZ2V0WSB9LFxuICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgY2VudGVyOiB7IHg6IGNlbnRlclgsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgb2Zmc2V0LFxuICAgIH0pO1xuICAgIGNvbnN0IHBhdGggPSBwb2ludHMucmVkdWNlKChyZXMsIHAsIGkpID0+IHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSAnJztcbiAgICAgICAgaWYgKGkgPiAwICYmIGkgPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc2VnbWVudCA9IGdldEJlbmQocG9pbnRzW2kgLSAxXSwgcCwgcG9pbnRzW2kgKyAxXSwgYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBgJHtpID09PSAwID8gJ00nIDogJ0wnfSR7cC54fSAke3AueX1gO1xuICAgICAgICB9XG4gICAgICAgIHJlcyArPSBzZWdtZW50O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sICcnKTtcbiAgICByZXR1cm4gW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlSW5pdGlhbGl6ZWQobm9kZSkge1xuICAgIHJldHVybiAobm9kZSAmJlxuICAgICAgICAhIShub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgbm9kZS5oYW5kbGVzPy5sZW5ndGgpICYmXG4gICAgICAgICEhKG5vZGUubWVhc3VyZWQud2lkdGggfHwgbm9kZS53aWR0aCB8fCBub2RlLmluaXRpYWxXaWR0aCkpO1xufVxuZnVuY3Rpb24gZ2V0RWRnZVBvc2l0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSB9ID0gcGFyYW1zO1xuICAgIGlmICghaXNOb2RlSW5pdGlhbGl6ZWQoc291cmNlTm9kZSkgfHwgIWlzTm9kZUluaXRpYWxpemVkKHRhcmdldE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VIYW5kbGVCb3VuZHMgPSBzb3VyY2VOb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHMoc291cmNlTm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCB0YXJnZXRIYW5kbGVCb3VuZHMgPSB0YXJnZXROb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHModGFyZ2V0Tm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCBzb3VyY2VIYW5kbGUgPSBnZXRIYW5kbGUkMShzb3VyY2VIYW5kbGVCb3VuZHM/LnNvdXJjZSA/PyBbXSwgcGFyYW1zLnNvdXJjZUhhbmRsZSk7XG4gICAgY29uc3QgdGFyZ2V0SGFuZGxlID0gZ2V0SGFuZGxlJDEoXG4gICAgLy8gd2hlbiBjb25uZWN0aW9uIHR5cGUgaXMgbG9vc2Ugd2UgY2FuIGRlZmluZSBhbGwgaGFuZGxlcyBhcyBzb3VyY2VzIGFuZCBjb25uZWN0IHNvdXJjZSAtPiBzb3VyY2VcbiAgICBwYXJhbXMuY29ubmVjdGlvbk1vZGUgPT09IENvbm5lY3Rpb25Nb2RlLlN0cmljdFxuICAgICAgICA/IHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdXG4gICAgICAgIDogKHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKS5jb25jYXQodGFyZ2V0SGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCBwYXJhbXMudGFyZ2V0SGFuZGxlKTtcbiAgICBpZiAoIXNvdXJjZUhhbmRsZSB8fCAhdGFyZ2V0SGFuZGxlKSB7XG4gICAgICAgIHBhcmFtcy5vbkVycm9yPy4oJzAwOCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA4J10oIXNvdXJjZUhhbmRsZSA/ICdzb3VyY2UnIDogJ3RhcmdldCcsIHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IHBhcmFtcy5zb3VyY2VIYW5kbGUsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IHBhcmFtcy50YXJnZXRIYW5kbGUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gc291cmNlSGFuZGxlPy5wb3NpdGlvbiB8fCBQb3NpdGlvbi5Cb3R0b207XG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRIYW5kbGU/LnBvc2l0aW9uIHx8IFBvc2l0aW9uLlRvcDtcbiAgICBjb25zdCBzb3VyY2UgPSBnZXRIYW5kbGVQb3NpdGlvbihzb3VyY2VOb2RlLCBzb3VyY2VIYW5kbGUsIHNvdXJjZVBvc2l0aW9uKTtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRIYW5kbGVQb3NpdGlvbih0YXJnZXROb2RlLCB0YXJnZXRIYW5kbGUsIHRhcmdldFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAgICAgICAgc291cmNlWTogc291cmNlLnksXG4gICAgICAgIHRhcmdldFg6IHRhcmdldC54LFxuICAgICAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b0hhbmRsZUJvdW5kcyhoYW5kbGVzKSB7XG4gICAgaWYgKCFoYW5kbGVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBbXTtcbiAgICBjb25zdCB0YXJnZXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZSBvZiBoYW5kbGVzKSB7XG4gICAgICAgIGhhbmRsZS53aWR0aCA9IGhhbmRsZS53aWR0aCA/PyAxO1xuICAgICAgICBoYW5kbGUuaGVpZ2h0ID0gaGFuZGxlLmhlaWdodCA/PyAxO1xuICAgICAgICBpZiAoaGFuZGxlLnR5cGUgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgICBzb3VyY2UucHVzaChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZS50eXBlID09PSAndGFyZ2V0Jykge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgaGFuZGxlLCBmYWxsYmFja1Bvc2l0aW9uID0gUG9zaXRpb24uTGVmdCwgY2VudGVyID0gZmFsc2UpIHtcbiAgICBjb25zdCB4ID0gKGhhbmRsZT8ueCA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueDtcbiAgICBjb25zdCB5ID0gKGhhbmRsZT8ueSA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGhhbmRsZSA/PyBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgIHJldHVybiB7IHg6IHggKyB3aWR0aCAvIDIsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gaGFuZGxlPy5wb3NpdGlvbiA/PyBmYWxsYmFja1Bvc2l0aW9uO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Ub3A6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGggLyAyLCB5IH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uUmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGgsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcmV0dXJuIHsgeDogeCArIHdpZHRoIC8gMiwgeTogeSArIGhlaWdodCB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5OiB5ICsgaGVpZ2h0IC8gMiB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEhhbmRsZSQxKGJvdW5kcywgaGFuZGxlSWQpIHtcbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgbm8gaGFuZGxlSWQgaXMgZ2l2ZW4sIHdlIHVzZSB0aGUgZmlyc3QgaGFuZGxlLCBvdGhlcndpc2Ugd2UgY2hlY2sgZm9yIHRoZSBpZFxuICAgIHJldHVybiAoIWhhbmRsZUlkID8gYm91bmRzWzBdIDogYm91bmRzLmZpbmQoKGQpID0+IGQuaWQgPT09IGhhbmRsZUlkKSkgfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFya2VySWQobWFya2VyLCBpZCkge1xuICAgIGlmICghbWFya2VyKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXJrZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfVxuICAgIGNvbnN0IGlkUHJlZml4ID0gaWQgPyBgJHtpZH1fX2AgOiAnJztcbiAgICByZXR1cm4gYCR7aWRQcmVmaXh9JHtPYmplY3Qua2V5cyhtYXJrZXIpXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBgJHtrZXl9PSR7bWFya2VyW2tleV19YClcbiAgICAgICAgLmpvaW4oJyYnKX1gO1xufVxuZnVuY3Rpb24gY3JlYXRlTWFya2VySWRzKGVkZ2VzLCB7IGlkLCBkZWZhdWx0Q29sb3IsIGRlZmF1bHRNYXJrZXJTdGFydCwgZGVmYXVsdE1hcmtlckVuZCwgfSkge1xuICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gZWRnZXNcbiAgICAgICAgLnJlZHVjZSgobWFya2VycywgZWRnZSkgPT4ge1xuICAgICAgICBbZWRnZS5tYXJrZXJTdGFydCB8fCBkZWZhdWx0TWFya2VyU3RhcnQsIGVkZ2UubWFya2VyRW5kIHx8IGRlZmF1bHRNYXJrZXJFbmRdLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtlciAmJiB0eXBlb2YgbWFya2VyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcklkID0gZ2V0TWFya2VySWQobWFya2VyLCBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZHMuaGFzKG1hcmtlcklkKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goeyBpZDogbWFya2VySWQsIGNvbG9yOiBtYXJrZXIuY29sb3IgfHwgZGVmYXVsdENvbG9yLCAuLi5tYXJrZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5hZGQobWFya2VySWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH0sIFtdKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pZC5sb2NhbGVDb21wYXJlKGIuaWQpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0obm9kZVJlY3QsIHZpZXdwb3J0LCBwb3NpdGlvbiwgb2Zmc2V0LCBhbGlnbikge1xuICAgIGxldCBhbGlnbm1lbnRPZmZzZXQgPSAwLjU7XG4gICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGFsaWdubWVudE9mZnNldCA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBhbGlnbm1lbnRPZmZzZXQgPSAxO1xuICAgIH1cbiAgICAvLyBwb3NpdGlvbiA9PT0gUG9zaXRpb24uVG9wXG4gICAgLy8gd2Ugc2V0IHRoZSB4IGFueSB5IHBvc2l0aW9uIG9mIHRoZSB0b29sYmFyIGJhc2VkIG9uIHRoZSBub2RlcyBwb3NpdGlvblxuICAgIGxldCBwb3MgPSBbXG4gICAgICAgIChub2RlUmVjdC54ICsgbm9kZVJlY3Qud2lkdGggKiBhbGlnbm1lbnRPZmZzZXQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LngsXG4gICAgICAgIG5vZGVSZWN0LnkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSAtIG9mZnNldCxcbiAgICBdO1xuICAgIC8vIGFuZCB0aGFuIHNoaWZ0IGl0IGJhc2VkIG9uIHRoZSBhbGlnbm1lbnQuIFRoZSBzaGlmdCB2YWx1ZXMgYXJlIGluICUuXG4gICAgbGV0IHNoaWZ0ID0gWy0xMDAgKiBhbGlnbm1lbnRPZmZzZXQsIC0xMDBdO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5SaWdodDpcbiAgICAgICAgICAgIHBvcyA9IFtcbiAgICAgICAgICAgICAgICAobm9kZVJlY3QueCArIG5vZGVSZWN0LndpZHRoKSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC54ICsgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIChub2RlUmVjdC55ICsgbm9kZVJlY3QuaGVpZ2h0ICogYWxpZ25tZW50T2Zmc2V0KSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHNoaWZ0ID0gWzAsIC0xMDAgKiBhbGlnbm1lbnRPZmZzZXRdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcG9zWzFdID0gKG5vZGVSZWN0LnkgKyBub2RlUmVjdC5oZWlnaHQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnkgKyBvZmZzZXQ7XG4gICAgICAgICAgICBzaGlmdFsxXSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcG9zID0gW1xuICAgICAgICAgICAgICAgIG5vZGVSZWN0LnggKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueCAtIG9mZnNldCxcbiAgICAgICAgICAgICAgICAobm9kZVJlY3QueSArIG5vZGVSZWN0LmhlaWdodCAqIGFsaWdubWVudE9mZnNldCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBzaGlmdCA9IFstMTAwLCAtMTAwICogYWxpZ25tZW50T2Zmc2V0XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3Bvc1swXX1weCwgJHtwb3NbMV19cHgpIHRyYW5zbGF0ZSgke3NoaWZ0WzBdfSUsICR7c2hpZnRbMV19JSlgO1xufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBub2RlT3JpZ2luOiBbMCwgMF0sXG4gICAgbm9kZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IHRydWUsXG4gICAgZGVmYXVsdHM6IHt9LFxufTtcbmNvbnN0IGFkb3B0VXNlck5vZGVzRGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgY2hlY2tFcXVhbGl0eTogdHJ1ZSxcbn07XG5mdW5jdGlvbiBtZXJnZU9iamVjdHMoYmFzZSwgaW5jb21pbmcpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLmJhc2UgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmNvbWluZykge1xuICAgICAgICBpZiAoaW5jb21pbmdba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0eXBlY2FzdCBpcyBzYWZlIGhlcmUsIGJlY2F1c2Ugd2UgY2hlY2sgZm9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpbmNvbWluZ1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucyhub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMb29rdXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkTm9kZShub2RlLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIF9vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uV2l0aE9yaWdpbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgX29wdGlvbnMubm9kZU9yaWdpbik7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpID8gbm9kZS5leHRlbnQgOiBfb3B0aW9ucy5ub2RlRXh0ZW50O1xuICAgICAgICAgICAgY29uc3QgY2xhbXBlZFBvc2l0aW9uID0gY2xhbXBQb3NpdGlvbihwb3NpdGlvbldpdGhPcmlnaW4sIGV4dGVudCwgZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSkpO1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wZWRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhhZG9wdFVzZXJOb2Rlc0RlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCB0bXBMb29rdXAgPSBuZXcgTWFwKG5vZGVMb29rdXApO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZVogPSBfb3B0aW9ucz8uZWxldmF0ZU5vZGVzT25TZWxlY3QgPyAxMDAwIDogMDtcbiAgICBub2RlTG9va3VwLmNsZWFyKCk7XG4gICAgcGFyZW50TG9va3VwLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCB1c2VyTm9kZSBvZiBub2Rlcykge1xuICAgICAgICBsZXQgaW50ZXJuYWxOb2RlID0gdG1wTG9va3VwLmdldCh1c2VyTm9kZS5pZCk7XG4gICAgICAgIGlmIChfb3B0aW9ucy5jaGVja0VxdWFsaXR5ICYmIHVzZXJOb2RlID09PSBpbnRlcm5hbE5vZGU/LmludGVybmFscy51c2VyTm9kZSkge1xuICAgICAgICAgICAgbm9kZUxvb2t1cC5zZXQodXNlck5vZGUuaWQsIGludGVybmFsTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbldpdGhPcmlnaW4gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKHVzZXJOb2RlLCBfb3B0aW9ucy5ub2RlT3JpZ2luKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IGlzQ29vcmRpbmF0ZUV4dGVudCh1c2VyTm9kZS5leHRlbnQpID8gdXNlck5vZGUuZXh0ZW50IDogX29wdGlvbnMubm9kZUV4dGVudDtcbiAgICAgICAgICAgIGNvbnN0IGNsYW1wZWRQb3NpdGlvbiA9IGNsYW1wUG9zaXRpb24ocG9zaXRpb25XaXRoT3JpZ2luLCBleHRlbnQsIGdldE5vZGVEaW1lbnNpb25zKHVzZXJOb2RlKSk7XG4gICAgICAgICAgICBpbnRlcm5hbE5vZGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uX29wdGlvbnMuZGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgLi4udXNlck5vZGUsXG4gICAgICAgICAgICAgICAgbWVhc3VyZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHVzZXJOb2RlLm1lYXN1cmVkPy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB1c2VyTm9kZS5tZWFzdXJlZD8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGU6IGNsYW1wZWRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdXNlciByZS1pbml0aWFsaXplcyB0aGUgbm9kZSBvciByZW1vdmVzIGBtZWFzdXJlZGAgZm9yIHdoYXRldmVyIHJlYXNvbiwgd2UgcmVzZXQgdGhlIGhhbmRsZUJvdW5kcyBzbyB0aGF0IHRoZSBub2RlIGdldHMgcmUtbWVhc3VyZWRcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQm91bmRzOiAhdXNlck5vZGUubWVhc3VyZWQgPyB1bmRlZmluZWQgOiBpbnRlcm5hbE5vZGU/LmludGVybmFscy5oYW5kbGVCb3VuZHMsXG4gICAgICAgICAgICAgICAgICAgIHo6IGNhbGN1bGF0ZVoodXNlck5vZGUsIHNlbGVjdGVkTm9kZVopLFxuICAgICAgICAgICAgICAgICAgICB1c2VyTm9kZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGVMb29rdXAuc2V0KHVzZXJOb2RlLmlkLCBpbnRlcm5hbE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyTm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgdXBkYXRlQ2hpbGROb2RlKGludGVybmFsTm9kZSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVBhcmVudExvb2t1cChub2RlLCBwYXJlbnRMb29rdXApIHtcbiAgICBpZiAoIW5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZE5vZGVzID0gcGFyZW50TG9va3VwLmdldChub2RlLnBhcmVudElkKTtcbiAgICBpZiAoY2hpbGROb2Rlcykge1xuICAgICAgICBjaGlsZE5vZGVzLnNldChub2RlLmlkLCBub2RlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmVudExvb2t1cC5zZXQobm9kZS5wYXJlbnRJZCwgbmV3IE1hcChbW25vZGUuaWQsIG5vZGVdXSkpO1xuICAgIH1cbn1cbi8qKlxuICogVXBkYXRlcyBwb3NpdGlvbkFic29sdXRlIGFuZCB6SW5kZXggb2YgYSBjaGlsZCBub2RlIGFuZCB0aGUgcGFyZW50TG9va3VwLlxuICovXG5mdW5jdGlvbiB1cGRhdGVDaGlsZE5vZGUobm9kZSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBlbGV2YXRlTm9kZXNPblNlbGVjdCwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCB9ID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCBwYXJlbnRJZCA9IG5vZGUucGFyZW50SWQ7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVMb29rdXAuZ2V0KHBhcmVudElkKTtcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBQYXJlbnQgbm9kZSAke3BhcmVudElkfSBub3QgZm91bmQuIFBsZWFzZSBtYWtlIHN1cmUgdGhhdCBwYXJlbnQgbm9kZXMgYXJlIGluIGZyb250IG9mIHRoZWlyIGNoaWxkIG5vZGVzIGluIHRoZSBub2RlcyBhcnJheS5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVQYXJlbnRMb29rdXAobm9kZSwgcGFyZW50TG9va3VwKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVaID0gZWxldmF0ZU5vZGVzT25TZWxlY3QgPyAxMDAwIDogMDtcbiAgICBjb25zdCB7IHgsIHksIHogfSA9IGNhbGN1bGF0ZUNoaWxkWFlaKG5vZGUsIHBhcmVudE5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIHNlbGVjdGVkTm9kZVopO1xuICAgIGNvbnN0IHsgcG9zaXRpb25BYnNvbHV0ZSB9ID0gbm9kZS5pbnRlcm5hbHM7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0geCAhPT0gcG9zaXRpb25BYnNvbHV0ZS54IHx8IHkgIT09IHBvc2l0aW9uQWJzb2x1dGUueTtcbiAgICBpZiAocG9zaXRpb25DaGFuZ2VkIHx8IHogIT09IG5vZGUuaW50ZXJuYWxzLnopIHtcbiAgICAgICAgLy8gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB0byBtYXJrIHRoZSBub2RlIGFzIHVwZGF0ZWRcbiAgICAgICAgbm9kZUxvb2t1cC5zZXQobm9kZS5pZCwge1xuICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUuaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGU6IHBvc2l0aW9uQ2hhbmdlZCA/IHsgeCwgeSB9IDogcG9zaXRpb25BYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICB6LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlWihub2RlLCBzZWxlY3RlZE5vZGVaKSB7XG4gICAgcmV0dXJuIChpc051bWVyaWMobm9kZS56SW5kZXgpID8gbm9kZS56SW5kZXggOiAwKSArIChub2RlLnNlbGVjdGVkID8gc2VsZWN0ZWROb2RlWiA6IDApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ2hpbGRYWVooY2hpbGROb2RlLCBwYXJlbnROb2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBzZWxlY3RlZE5vZGVaKSB7XG4gICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBwYXJlbnROb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgIGNvbnN0IGNoaWxkRGltZW5zaW9ucyA9IGdldE5vZGVEaW1lbnNpb25zKGNoaWxkTm9kZSk7XG4gICAgY29uc3QgcG9zaXRpb25XaXRoT3JpZ2luID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihjaGlsZE5vZGUsIG5vZGVPcmlnaW4pO1xuICAgIGNvbnN0IGNsYW1wZWRQb3NpdGlvbiA9IGlzQ29vcmRpbmF0ZUV4dGVudChjaGlsZE5vZGUuZXh0ZW50KVxuICAgICAgICA/IGNsYW1wUG9zaXRpb24ocG9zaXRpb25XaXRoT3JpZ2luLCBjaGlsZE5vZGUuZXh0ZW50LCBjaGlsZERpbWVuc2lvbnMpXG4gICAgICAgIDogcG9zaXRpb25XaXRoT3JpZ2luO1xuICAgIGxldCBhYnNvbHV0ZVBvc2l0aW9uID0gY2xhbXBQb3NpdGlvbih7IHg6IHBhcmVudFggKyBjbGFtcGVkUG9zaXRpb24ueCwgeTogcGFyZW50WSArIGNsYW1wZWRQb3NpdGlvbi55IH0sIG5vZGVFeHRlbnQsIGNoaWxkRGltZW5zaW9ucyk7XG4gICAgaWYgKGNoaWxkTm9kZS5leHRlbnQgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgIGFic29sdXRlUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uVG9QYXJlbnQoYWJzb2x1dGVQb3NpdGlvbiwgY2hpbGREaW1lbnNpb25zLCBwYXJlbnROb2RlKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRaID0gY2FsY3VsYXRlWihjaGlsZE5vZGUsIHNlbGVjdGVkTm9kZVopO1xuICAgIGNvbnN0IHBhcmVudFogPSBwYXJlbnROb2RlLmludGVybmFscy56ID8/IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogYWJzb2x1dGVQb3NpdGlvbi54LFxuICAgICAgICB5OiBhYnNvbHV0ZVBvc2l0aW9uLnksXG4gICAgICAgIHo6IHBhcmVudFogPiBjaGlsZFogPyBwYXJlbnRaIDogY2hpbGRaLFxuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVFeHBhbmRQYXJlbnQoY2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiA9IFswLCAwXSkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBwYXJlbnRFeHBhbnNpb25zID0gbmV3IE1hcCgpO1xuICAgIC8vIGRldGVybWluZSB0aGUgZXhwYW5kZWQgcmVjdGFuZ2xlIHRoZSBjaGlsZCBub2RlcyB3b3VsZCB0YWtlIGZvciBlYWNoIHBhcmVudFxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZUxvb2t1cC5nZXQoY2hpbGQucGFyZW50SWQpO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50UmVjdCA9IHBhcmVudEV4cGFuc2lvbnMuZ2V0KGNoaWxkLnBhcmVudElkKT8uZXhwYW5kZWRSZWN0ID8/IG5vZGVUb1JlY3QocGFyZW50KTtcbiAgICAgICAgY29uc3QgZXhwYW5kZWRSZWN0ID0gZ2V0Qm91bmRzT2ZSZWN0cyhwYXJlbnRSZWN0LCBjaGlsZC5yZWN0KTtcbiAgICAgICAgcGFyZW50RXhwYW5zaW9ucy5zZXQoY2hpbGQucGFyZW50SWQsIHsgZXhwYW5kZWRSZWN0LCBwYXJlbnQgfSk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRFeHBhbnNpb25zLnNpemUgPiAwKSB7XG4gICAgICAgIHBhcmVudEV4cGFuc2lvbnMuZm9yRWFjaCgoeyBleHBhbmRlZFJlY3QsIHBhcmVudCB9LCBwYXJlbnRJZCkgPT4ge1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiAmIGRpbWVuc2lvbnMgb2YgdGhlIHBhcmVudFxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25BYnNvbHV0ZSA9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBnZXROb2RlRGltZW5zaW9ucyhwYXJlbnQpO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gcGFyZW50Lm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZSBwYXJlbnQgZXhwYW5kcyBpbiB3aWR0aCBhbmQgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IHhDaGFuZ2UgPSBleHBhbmRlZFJlY3QueCA8IHBvc2l0aW9uQWJzb2x1dGUueCA/IE1hdGgucm91bmQoTWF0aC5hYnMocG9zaXRpb25BYnNvbHV0ZS54IC0gZXhwYW5kZWRSZWN0LngpKSA6IDA7XG4gICAgICAgICAgICBjb25zdCB5Q2hhbmdlID0gZXhwYW5kZWRSZWN0LnkgPCBwb3NpdGlvbkFic29sdXRlLnkgPyBNYXRoLnJvdW5kKE1hdGguYWJzKHBvc2l0aW9uQWJzb2x1dGUueSAtIGV4cGFuZGVkUmVjdC55KSkgOiAwO1xuICAgICAgICAgICAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heChkaW1lbnNpb25zLndpZHRoLCBNYXRoLnJvdW5kKGV4cGFuZGVkUmVjdC53aWR0aCkpO1xuICAgICAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoZGltZW5zaW9ucy5oZWlnaHQsIE1hdGgucm91bmQoZXhwYW5kZWRSZWN0LmhlaWdodCkpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGhDaGFuZ2UgPSAobmV3V2lkdGggLSBkaW1lbnNpb25zLndpZHRoKSAqIG9yaWdpblswXTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodENoYW5nZSA9IChuZXdIZWlnaHQgLSBkaW1lbnNpb25zLmhlaWdodCkgKiBvcmlnaW5bMV07XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNvcnJlY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGUgb3JpZ2luIGlzIG5vdCBbMCwwXVxuICAgICAgICAgICAgaWYgKHhDaGFuZ2UgPiAwIHx8IHlDaGFuZ2UgPiAwIHx8IHdpZHRoQ2hhbmdlIHx8IGhlaWdodENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBhcmVudC5wb3NpdGlvbi54IC0geENoYW5nZSArIHdpZHRoQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcGFyZW50LnBvc2l0aW9uLnkgLSB5Q2hhbmdlICsgaGVpZ2h0Q2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFdlIG1vdmUgYWxsIGNoaWxkIG5vZGVzIGluIHRoZSBvcHBzaXRlIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgIC8vIHNvIHRoZSB4LHkgY2hhbmdlcyBvZiB0aGUgcGFyZW50IGRvIG5vdCBtb3ZlIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHBhcmVudExvb2t1cC5nZXQocGFyZW50SWQpPy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbi5zb21lKChjaGlsZCkgPT4gY2hpbGQuaWQgPT09IGNoaWxkTm9kZS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNoaWxkTm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNoaWxkTm9kZS5wb3NpdGlvbi54ICsgeENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hpbGROb2RlLnBvc2l0aW9uLnkgKyB5Q2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjb3JyZWN0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGUgb3JpZ2luIGlzIG5vdCBbMCwwXVxuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCBleHBhbmRlZFJlY3Qud2lkdGggfHwgZGltZW5zaW9ucy5oZWlnaHQgPCBleHBhbmRlZFJlY3QuaGVpZ2h0IHx8IHhDaGFuZ2UgfHwgeUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbmV3V2lkdGggKyAoeENoYW5nZSA/IG9yaWdpblswXSAqIHhDaGFuZ2UgLSB3aWR0aENoYW5nZSA6IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHQgKyAoeUNoYW5nZSA/IG9yaWdpblsxXSAqIHlDaGFuZ2UgLSBoZWlnaHRDaGFuZ2UgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VzO1xufVxuZnVuY3Rpb24gdXBkYXRlTm9kZUludGVybmFscyh1cGRhdGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIGRvbU5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQpIHtcbiAgICBjb25zdCB2aWV3cG9ydE5vZGUgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcueHlmbG93X192aWV3cG9ydCcpO1xuICAgIGxldCB1cGRhdGVkSW50ZXJuYWxzID0gZmFsc2U7XG4gICAgaWYgKCF2aWV3cG9ydE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogW10sIHVwZGF0ZWRJbnRlcm5hbHMgfTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodmlld3BvcnROb2RlKTtcbiAgICBjb25zdCB7IG0yMjogem9vbSB9ID0gbmV3IHdpbmRvdy5ET01NYXRyaXhSZWFkT25seShzdHlsZS50cmFuc2Zvcm0pO1xuICAgIC8vIGluIHRoaXMgYXJyYXkgd2UgY29sbGVjdCBub2RlcywgdGhhdCBtaWdodCB0cmlnZ2VyIGNoYW5nZXMgKGxpa2UgZXhwYW5kaW5nIHBhcmVudClcbiAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KHVwZGF0ZS5pZCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaGlkZGVuKSB7XG4gICAgICAgICAgICBub2RlTG9va3VwLnNldChub2RlLmlkLCB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZS5pbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUJvdW5kczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVwZGF0ZWRJbnRlcm5hbHMgPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnModXBkYXRlLm5vZGVFbGVtZW50KTtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uQ2hhbmdlZCA9IG5vZGUubWVhc3VyZWQud2lkdGggIT09IGRpbWVuc2lvbnMud2lkdGggfHwgbm9kZS5tZWFzdXJlZC5oZWlnaHQgIT09IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBkb1VwZGF0ZSA9ICEhKGRpbWVuc2lvbnMud2lkdGggJiZcbiAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICYmXG4gICAgICAgICAgICAoZGltZW5zaW9uQ2hhbmdlZCB8fCAhbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzIHx8IHVwZGF0ZS5mb3JjZSkpO1xuICAgICAgICBpZiAoZG9VcGRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVCb3VuZHMgPSB1cGRhdGUubm9kZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpID8gbm9kZS5leHRlbnQgOiBub2RlRXh0ZW50O1xuICAgICAgICAgICAgbGV0IHsgcG9zaXRpb25BYnNvbHV0ZSB9ID0gbm9kZS5pbnRlcm5hbHM7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCAmJiBub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlID0gY2xhbXBQb3NpdGlvblRvUGFyZW50KHBvc2l0aW9uQWJzb2x1dGUsIGRpbWVuc2lvbnMsIG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4dGVudCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGUgPSBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uQWJzb2x1dGUsIGV4dGVudCwgZGltZW5zaW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgbWVhc3VyZWQ6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGUuaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZ2V0SGFuZGxlQm91bmRzKCdzb3VyY2UnLCB1cGRhdGUubm9kZUVsZW1lbnQsIG5vZGVCb3VuZHMsIHpvb20sIG5vZGUuaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBnZXRIYW5kbGVCb3VuZHMoJ3RhcmdldCcsIHVwZGF0ZS5ub2RlRWxlbWVudCwgbm9kZUJvdW5kcywgem9vbSwgbm9kZS5pZCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBub2RlTG9va3VwLnNldChub2RlLmlkLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2hpbGROb2RlKG5ld05vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgeyBub2RlT3JpZ2luIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlZEludGVybmFscyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZXhwYW5kUGFyZW50ICYmIG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RXhwYW5kQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBub2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDogbm9kZVRvUmVjdChuZXdOb2RlLCBub2RlT3JpZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnRFeHBhbmRDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQocGFyZW50RXhwYW5kQ2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2hhbmdlcywgdXBkYXRlZEludGVybmFscyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcGFuQnkoeyBkZWx0YSwgcGFuWm9vbSwgdHJhbnNmb3JtLCB0cmFuc2xhdGVFeHRlbnQsIHdpZHRoLCBoZWlnaHQsIH0pIHtcbiAgICBpZiAoIXBhblpvb20gfHwgKCFkZWx0YS54ICYmICFkZWx0YS55KSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgY29uc3QgbmV4dFZpZXdwb3J0ID0gYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydENvbnN0cmFpbmVkKHtcbiAgICAgICAgeDogdHJhbnNmb3JtWzBdICsgZGVsdGEueCxcbiAgICAgICAgeTogdHJhbnNmb3JtWzFdICsgZGVsdGEueSxcbiAgICAgICAgem9vbTogdHJhbnNmb3JtWzJdLFxuICAgIH0sIFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbd2lkdGgsIGhlaWdodF0sXG4gICAgXSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICBjb25zdCB0cmFuc2Zvcm1DaGFuZ2VkID0gISFuZXh0Vmlld3BvcnQgJiZcbiAgICAgICAgKG5leHRWaWV3cG9ydC54ICE9PSB0cmFuc2Zvcm1bMF0gfHwgbmV4dFZpZXdwb3J0LnkgIT09IHRyYW5zZm9ybVsxXSB8fCBuZXh0Vmlld3BvcnQuayAhPT0gdHJhbnNmb3JtWzJdKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRyYW5zZm9ybUNoYW5nZWQpO1xufVxuLyoqXG4gKiB0aGlzIGZ1bmN0aW9uIGFkZHMgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIGNvbm5lY3Rpb25Mb29rdXBcbiAqIGF0IHRoZSBmb2xsb3dpbmcga2V5czogbm9kZUlkLXR5cGUtaGFuZGxlSWQsIG5vZGVJZC10eXBlIGFuZCBub2RlSWRcbiAqIEBwYXJhbSB0eXBlIHR5cGUgb2YgdGhlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBjb25uZWN0aW9uIGNvbm5lY3Rpb24gdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGxvb2t1cFxuICogQHBhcmFtIGNvbm5lY3Rpb25LZXkgYXQgd2hpY2gga2V5IHRoZSBjb25uZWN0aW9uIHNob3VsZCBiZSBhZGRlZFxuICogQHBhcmFtIGNvbm5lY3Rpb25Mb29rdXAgcmVmZXJlbmNlIHRvIHRoZSBjb25uZWN0aW9uIGxvb2t1cFxuICogQHBhcmFtIG5vZGVJZCBub2RlSWQgb2YgdGhlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBoYW5kbGVJZCBoYW5kbGVJZCBvZiB0aGUgY29ubmVjaXRvblxuICovXG5mdW5jdGlvbiBhZGRDb25uZWN0aW9uVG9Mb29rdXAodHlwZSwgY29ubmVjdGlvbiwgY29ubmVjdGlvbktleSwgY29ubmVjdGlvbkxvb2t1cCwgbm9kZUlkLCBoYW5kbGVJZCkge1xuICAgIC8vIFdlIGFkZCB0aGUgY29ubmVjdGlvbiB0byB0aGUgY29ubmVjdGlvbkxvb2t1cCBhdCB0aGUgZm9sbG93aW5nIGtleXNcbiAgICAvLyAxLiBub2RlSWQsIDIuIG5vZGVJZC10eXBlLCAzLiBub2RlSWQtdHlwZS1oYW5kbGVJZFxuICAgIC8vIElmIHRoZSBrZXkgYWxyZWFkeSBleGlzdHMsIHdlIGFkZCB0aGUgY29ubmVjdGlvbiB0byB0aGUgZXhpc3RpbmcgbWFwXG4gICAgbGV0IGtleSA9IG5vZGVJZDtcbiAgICBjb25zdCBub2RlTWFwID0gY29ubmVjdGlvbkxvb2t1cC5nZXQoa2V5KSB8fCBuZXcgTWFwKCk7XG4gICAgY29ubmVjdGlvbkxvb2t1cC5zZXQoa2V5LCBub2RlTWFwLnNldChjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uKSk7XG4gICAga2V5ID0gYCR7bm9kZUlkfS0ke3R5cGV9YDtcbiAgICBjb25zdCB0eXBlTWFwID0gY29ubmVjdGlvbkxvb2t1cC5nZXQoa2V5KSB8fCBuZXcgTWFwKCk7XG4gICAgY29ubmVjdGlvbkxvb2t1cC5zZXQoa2V5LCB0eXBlTWFwLnNldChjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uKSk7XG4gICAgaWYgKGhhbmRsZUlkKSB7XG4gICAgICAgIGtleSA9IGAke25vZGVJZH0tJHt0eXBlfS0ke2hhbmRsZUlkfWA7XG4gICAgICAgIGNvbnN0IGhhbmRsZU1hcCA9IGNvbm5lY3Rpb25Mb29rdXAuZ2V0KGtleSkgfHwgbmV3IE1hcCgpO1xuICAgICAgICBjb25uZWN0aW9uTG9va3VwLnNldChrZXksIGhhbmRsZU1hcC5zZXQoY29ubmVjdGlvbktleSwgY29ubmVjdGlvbikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAoY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCwgZWRnZXMpIHtcbiAgICBjb25uZWN0aW9uTG9va3VwLmNsZWFyKCk7XG4gICAgZWRnZUxvb2t1cC5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBlZGdlcykge1xuICAgICAgICBjb25zdCB7IHNvdXJjZTogc291cmNlTm9kZSwgdGFyZ2V0OiB0YXJnZXROb2RlLCBzb3VyY2VIYW5kbGUgPSBudWxsLCB0YXJnZXRIYW5kbGUgPSBudWxsIH0gPSBlZGdlO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geyBlZGdlSWQ6IGVkZ2UuaWQsIHNvdXJjZTogc291cmNlTm9kZSwgdGFyZ2V0OiB0YXJnZXROb2RlLCBzb3VyY2VIYW5kbGUsIHRhcmdldEhhbmRsZSB9O1xuICAgICAgICBjb25zdCBzb3VyY2VLZXkgPSBgJHtzb3VyY2VOb2RlfS0ke3NvdXJjZUhhbmRsZX0tLSR7dGFyZ2V0Tm9kZX0tJHt0YXJnZXRIYW5kbGV9YDtcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gYCR7dGFyZ2V0Tm9kZX0tJHt0YXJnZXRIYW5kbGV9LS0ke3NvdXJjZU5vZGV9LSR7c291cmNlSGFuZGxlfWA7XG4gICAgICAgIGFkZENvbm5lY3Rpb25Ub0xvb2t1cCgnc291cmNlJywgY29ubmVjdGlvbiwgdGFyZ2V0S2V5LCBjb25uZWN0aW9uTG9va3VwLCBzb3VyY2VOb2RlLCBzb3VyY2VIYW5kbGUpO1xuICAgICAgICBhZGRDb25uZWN0aW9uVG9Mb29rdXAoJ3RhcmdldCcsIGNvbm5lY3Rpb24sIHNvdXJjZUtleSwgY29ubmVjdGlvbkxvb2t1cCwgdGFyZ2V0Tm9kZSwgdGFyZ2V0SGFuZGxlKTtcbiAgICAgICAgZWRnZUxvb2t1cC5zZXQoZWRnZS5pZCwgZWRnZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzaGFsbG93Tm9kZURhdGEoYSwgYikge1xuICAgIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBfYSA9IEFycmF5LmlzQXJyYXkoYSkgPyBhIDogW2FdO1xuICAgIGNvbnN0IF9iID0gQXJyYXkuaXNBcnJheShiKSA/IGIgOiBbYl07XG4gICAgaWYgKF9hLmxlbmd0aCAhPT0gX2IubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoX2FbaV0uaWQgIT09IF9iW2ldLmlkIHx8IF9hW2ldLnR5cGUgIT09IF9iW2ldLnR5cGUgfHwgIU9iamVjdC5pcyhfYVtpXS5kYXRhLCBfYltpXS5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1BhcmVudFNlbGVjdGVkKG5vZGUsIG5vZGVMb29rdXApIHtcbiAgICBpZiAoIW5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCk7XG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc1BhcmVudFNlbGVjdGVkKHBhcmVudE5vZGUsIG5vZGVMb29rdXApO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0b3IodGFyZ2V0LCBzZWxlY3RvciwgZG9tTm9kZSkge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKGN1cnJlbnQ/Lm1hdGNoZXM/LihzZWxlY3RvcikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IGRvbU5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Py5wYXJlbnRFbGVtZW50O1xuICAgIH0gd2hpbGUgKGN1cnJlbnQpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIGxvb2tzIGZvciBhbGwgc2VsZWN0ZWQgbm9kZXMgYW5kIGNyZWF0ZWQgYSBOb2RlRHJhZ0l0ZW0gZm9yIGVhY2ggb2YgdGhlbVxuZnVuY3Rpb24gZ2V0RHJhZ0l0ZW1zKG5vZGVMb29rdXAsIG5vZGVzRHJhZ2dhYmxlLCBtb3VzZVBvcywgbm9kZUlkKSB7XG4gICAgY29uc3QgZHJhZ0l0ZW1zID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBub2RlXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgIGlmICgobm9kZS5zZWxlY3RlZCB8fCBub2RlLmlkID09PSBub2RlSWQpICYmXG4gICAgICAgICAgICAoIW5vZGUucGFyZW50SWQgfHwgIWlzUGFyZW50U2VsZWN0ZWQobm9kZSwgbm9kZUxvb2t1cCkpICYmXG4gICAgICAgICAgICAobm9kZS5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBub2RlLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKSkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxOb2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGludGVybmFsTm9kZSkge1xuICAgICAgICAgICAgICAgIGRyYWdJdGVtcy5zZXQoaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpbnRlcm5hbE5vZGUucG9zaXRpb24gfHwgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBtb3VzZVBvcy54IC0gaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBtb3VzZVBvcy55IC0gaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudDogaW50ZXJuYWxOb2RlLmV4dGVudCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IGludGVybmFsTm9kZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBpbnRlcm5hbE5vZGUub3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBleHBhbmRQYXJlbnQ6IGludGVybmFsTm9kZS5leHBhbmRQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlIHx8IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtZWFzdXJlZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGludGVybmFsTm9kZS5tZWFzdXJlZC53aWR0aCA/PyAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpbnRlcm5hbE5vZGUubWVhc3VyZWQuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRyYWdJdGVtcztcbn1cbi8vIHJldHVybnMgdHdvIHBhcmFtczpcbi8vIDEuIHRoZSBkcmFnZ2VkIG5vZGUgKG9yIHRoZSBmaXJzdCBvZiB0aGUgbGlzdCwgaWYgd2UgYXJlIGRyYWdnaW5nIGEgbm9kZSBzZWxlY3Rpb24pXG4vLyAyLiBhcnJheSBvZiBzZWxlY3RlZCBub2RlcyAoZm9yIG11bHRpIHNlbGVjdGlvbnMpXG5mdW5jdGlvbiBnZXRFdmVudEhhbmRsZXJQYXJhbXMoeyBub2RlSWQsIGRyYWdJdGVtcywgbm9kZUxvb2t1cCwgZHJhZ2dpbmcgPSB0cnVlLCB9KSB7XG4gICAgY29uc3Qgbm9kZXNGcm9tRHJhZ0l0ZW1zID0gW107XG4gICAgZm9yIChjb25zdCBbaWQsIGRyYWdJdGVtXSBvZiBkcmFnSXRlbXMpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKT8uaW50ZXJuYWxzLnVzZXJOb2RlO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZXNGcm9tRHJhZ0l0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGRyYWdJdGVtLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIFtub2Rlc0Zyb21EcmFnSXRlbXNbMF0sIG5vZGVzRnJvbURyYWdJdGVtc107XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChub2RlSWQpPy5pbnRlcm5hbHMudXNlck5vZGU7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgIW5vZGVcbiAgICAgICAgICAgID8gbm9kZXNGcm9tRHJhZ0l0ZW1zWzBdXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBkcmFnSXRlbXMuZ2V0KG5vZGVJZCk/LnBvc2l0aW9uIHx8IG5vZGUucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBub2Rlc0Zyb21EcmFnSXRlbXMsXG4gICAgXTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIFhZRHJhZyh7IG9uTm9kZU1vdXNlRG93biwgZ2V0U3RvcmVJdGVtcywgb25EcmFnU3RhcnQsIG9uRHJhZywgb25EcmFnU3RvcCwgfSkge1xuICAgIGxldCBsYXN0UG9zID0geyB4OiBudWxsLCB5OiBudWxsIH07XG4gICAgbGV0IGF1dG9QYW5JZCA9IDA7XG4gICAgbGV0IGRyYWdJdGVtcyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgbW91c2VQb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgIGxldCBjb250YWluZXJCb3VuZHMgPSBudWxsO1xuICAgIGxldCBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBkM1NlbGVjdGlvbiA9IG51bGw7XG4gICAgbGV0IGFib3J0RHJhZyA9IGZhbHNlOyAvLyBwcmV2ZW50cyB1bmludGVudGlvbmFsIGRyYWdnaW5nIG9uIG11bHRpdG91Y2hcbiAgICAvLyBwdWJsaWMgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgbm9EcmFnQ2xhc3NOYW1lLCBoYW5kbGVTZWxlY3RvciwgZG9tTm9kZSwgaXNTZWxlY3RhYmxlLCBub2RlSWQsIG5vZGVDbGlja0Rpc3RhbmNlID0gMCwgfSkge1xuICAgICAgICBkM1NlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKTtcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlTm9kZXMoeyB4LCB5IH0sIGRyYWdFdmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBub2RlRXh0ZW50LCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgb25Ob2RlRHJhZywgb25TZWxlY3Rpb25EcmFnLCBvbkVycm9yLCB1cGRhdGVOb2RlUG9zaXRpb25zLCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHsgeCwgeSB9O1xuICAgICAgICAgICAgbGV0IGhhc0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5vZGVzQm94ID0geyB4OiAwLCB5OiAwLCB4MjogMCwgeTI6IDAgfTtcbiAgICAgICAgICAgIGlmIChkcmFnSXRlbXMuc2l6ZSA+IDEgJiYgbm9kZUV4dGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKGRyYWdJdGVtcyk7XG4gICAgICAgICAgICAgICAgbm9kZXNCb3ggPSByZWN0VG9Cb3gocmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZCwgZHJhZ0l0ZW1dIG9mIGRyYWdJdGVtcykge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUxvb2t1cC5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlzIG5vdCBpbiB0aGUgbm9kZUxvb2t1cCBhbnltb3JlLCBpdCB3YXMgcHJvYmFibHkgZGVsZXRlZCB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgaXQgYW55bW9yZVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5leHRQb3NpdGlvbiA9IHsgeDogeCAtIGRyYWdJdGVtLmRpc3RhbmNlLngsIHk6IHkgLSBkcmFnSXRlbS5kaXN0YW5jZS55IH07XG4gICAgICAgICAgICAgICAgaWYgKHNuYXBUb0dyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gc25hcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgc25hcEdyaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBzZWxlY3Rpb24gd2l0aCBtdWx0aXBsZSBub2RlcyBhbmQgYSBub2RlIGV4dGVudCBpcyBzZXQsIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBub2RlIGV4dGVudCBmb3IgZWFjaCBub2RlXG4gICAgICAgICAgICAgICAgLy8gYmFzZWQgb24gaXRzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIG5vZGUgc3RheXMgYXQgaXQncyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgIGxldCBhZGp1c3RlZE5vZGVFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIFtub2RlRXh0ZW50WzBdWzBdLCBub2RlRXh0ZW50WzBdWzFdXSxcbiAgICAgICAgICAgICAgICAgICAgW25vZGVFeHRlbnRbMV1bMF0sIG5vZGVFeHRlbnRbMV1bMV1dLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdJdGVtcy5zaXplID4gMSAmJiBub2RlRXh0ZW50ICYmICFkcmFnSXRlbS5leHRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwb3NpdGlvbkFic29sdXRlIH0gPSBkcmFnSXRlbS5pbnRlcm5hbHM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHgxID0gcG9zaXRpb25BYnNvbHV0ZS54IC0gbm9kZXNCb3gueCArIG5vZGVFeHRlbnRbMF1bMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHgyID0gcG9zaXRpb25BYnNvbHV0ZS54ICsgZHJhZ0l0ZW0ubWVhc3VyZWQud2lkdGggLSBub2Rlc0JveC54MiArIG5vZGVFeHRlbnRbMV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkxID0gcG9zaXRpb25BYnNvbHV0ZS55IC0gbm9kZXNCb3gueSArIG5vZGVFeHRlbnRbMF1bMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gcG9zaXRpb25BYnNvbHV0ZS55ICsgZHJhZ0l0ZW0ubWVhc3VyZWQuaGVpZ2h0IC0gbm9kZXNCb3gueTIgKyBub2RlRXh0ZW50WzFdWzFdO1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZE5vZGVFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBbeDEsIHkxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4MiwgeTJdLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uLCBwb3NpdGlvbkFic29sdXRlIH0gPSBjYWxjdWxhdGVOb2RlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBub2RlSWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQ6IGFkanVzdGVkTm9kZUV4dGVudCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IHdlIG9ubHkgZmlyZSBhIGNoYW5nZSBldmVudCB3aGVuIHRoZXJlIGlzIGEgY2hhbmdlXG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlID0gaGFzQ2hhbmdlIHx8IGRyYWdJdGVtLnBvc2l0aW9uLnggIT09IHBvc2l0aW9uLnggfHwgZHJhZ0l0ZW0ucG9zaXRpb24ueSAhPT0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgICAgICBkcmFnSXRlbS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGRyYWdJdGVtLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlID0gcG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhkcmFnSXRlbXMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGRyYWdFdmVudCAmJiAob25EcmFnIHx8IG9uTm9kZURyYWcgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbkRyYWc/LihkcmFnRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgb25Ob2RlRHJhZz8uKGRyYWdFdmVudCwgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Rpb25EcmFnPy4oZHJhZ0V2ZW50LCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBhdXRvUGFuKCkge1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXJCb3VuZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgcGFuQnksIGF1dG9QYW5TcGVlZCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgY29uc3QgW3hNb3ZlbWVudCwgeU1vdmVtZW50XSA9IGNhbGNBdXRvUGFuKG1vdXNlUG9zaXRpb24sIGNvbnRhaW5lckJvdW5kcywgYXV0b1BhblNwZWVkKTtcbiAgICAgICAgICAgIGlmICh4TW92ZW1lbnQgIT09IDAgfHwgeU1vdmVtZW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdFBvcy54ID0gKGxhc3RQb3MueCA/PyAwKSAtIHhNb3ZlbWVudCAvIHRyYW5zZm9ybVsyXTtcbiAgICAgICAgICAgICAgICBsYXN0UG9zLnkgPSAobGFzdFBvcy55ID8/IDApIC0geU1vdmVtZW50IC8gdHJhbnNmb3JtWzJdO1xuICAgICAgICAgICAgICAgIGlmIChhd2FpdCBwYW5CeSh7IHg6IHhNb3ZlbWVudCwgeTogeU1vdmVtZW50IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVzKGxhc3RQb3MsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9QYW5JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhdXRvUGFuKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFydERyYWcoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIG5vZGVzRHJhZ2dhYmxlLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBzZWxlY3ROb2Rlc09uRHJhZywgb25Ob2RlRHJhZ1N0YXJ0LCBvblNlbGVjdGlvbkRyYWdTdGFydCwgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCghc2VsZWN0Tm9kZXNPbkRyYWcgfHwgIWlzU2VsZWN0YWJsZSkgJiYgIW11bHRpU2VsZWN0aW9uQWN0aXZlICYmIG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUxvb2t1cC5nZXQobm9kZUlkKT8uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXNldCBzZWxlY3RlZCBub2RlcyB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPWZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1NlbGVjdGFibGUgJiYgc2VsZWN0Tm9kZXNPbkRyYWcgJiYgbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgb25Ob2RlTW91c2VEb3duPy4obm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgY29udGFpbmVyQm91bmRzIH0pO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHBvaW50ZXJQb3M7XG4gICAgICAgICAgICBkcmFnSXRlbXMgPSBnZXREcmFnSXRlbXMobm9kZUxvb2t1cCwgbm9kZXNEcmFnZ2FibGUsIHBvaW50ZXJQb3MsIG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLnNpemUgPiAwICYmIChvbkRyYWdTdGFydCB8fCBvbk5vZGVEcmFnU3RhcnQgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnU3RhcnQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzXSA9IGdldEV2ZW50SGFuZGxlclBhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgb25Ob2RlRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGQzRHJhZ0luc3RhbmNlID0gZHJhZygpXG4gICAgICAgICAgICAuY2xpY2tEaXN0YW5jZShub2RlQ2xpY2tEaXN0YW5jZSlcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgbm9kZURyYWdUaHJlc2hvbGQsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kcyA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHx8IG51bGw7XG4gICAgICAgICAgICBhYm9ydERyYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChub2RlRHJhZ1RocmVzaG9sZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RHJhZyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIGNvbnRhaW5lckJvdW5kcyB9KTtcbiAgICAgICAgICAgIGxhc3RQb3MgPSBwb2ludGVyUG9zO1xuICAgICAgICAgICAgbW91c2VQb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2RyYWcnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0b1Bhbk9uTm9kZURyYWcsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVEcmFnVGhyZXNob2xkLCBub2RlTG9va3VwIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIGNvbnRhaW5lckJvdW5kcyB9KTtcbiAgICAgICAgICAgIGlmICgoZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ3RvdWNobW92ZScgJiYgZXZlbnQuc291cmNlRXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB8fFxuICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgZGVsZXRlcyBhIG5vZGUgd2hpbGUgZHJhZ2dpbmcsIHdlIG5lZWQgdG8gYWJvcnQgdGhlIGRyYWcgdG8gcHJldmVudCBlcnJvcnNcbiAgICAgICAgICAgICAgICAobm9kZUlkICYmICFub2RlTG9va3VwLmhhcyhub2RlSWQpKSkge1xuICAgICAgICAgICAgICAgIGFib3J0RHJhZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnREcmFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhdXRvUGFuU3RhcnRlZCAmJiBhdXRvUGFuT25Ob2RlRHJhZyAmJiBkcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdXRvUGFuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHBvaW50ZXJQb3MueFNuYXBwZWQgLSAobGFzdFBvcy54ID8/IDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwb2ludGVyUG9zLnlTbmFwcGVkIC0gKGxhc3RQb3MueSA/PyAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBub2RlRHJhZ1RocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydERyYWcoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNraXAgZXZlbnRzIHdpdGhvdXQgbW92ZW1lbnRcbiAgICAgICAgICAgIGlmICgobGFzdFBvcy54ICE9PSBwb2ludGVyUG9zLnhTbmFwcGVkIHx8IGxhc3RQb3MueSAhPT0gcG9pbnRlclBvcy55U25hcHBlZCkgJiYgZHJhZ0l0ZW1zICYmIGRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZHJhZ0V2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQgYXMgTW91c2VFdmVudDtcbiAgICAgICAgICAgICAgICBtb3VzZVBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVOb2Rlcyhwb2ludGVyUG9zLCBldmVudC5zb3VyY2VFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2VuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkcmFnU3RhcnRlZCB8fCBhYm9ydERyYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGF1dG9QYW5JZCk7XG4gICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB1cGRhdGVOb2RlUG9zaXRpb25zLCBvbk5vZGVEcmFnU3RvcCwgb25TZWxlY3Rpb25EcmFnU3RvcCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoZHJhZ0l0ZW1zLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9uRHJhZ1N0b3AgfHwgb25Ob2RlRHJhZ1N0b3AgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnU3RvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXNdID0gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvbkRyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIG9uTm9kZURyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Rpb25EcmFnU3RvcD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gIWV2ZW50LmJ1dHRvbiAmJlxuICAgICAgICAgICAgICAgICghbm9EcmFnQ2xhc3NOYW1lIHx8ICFoYXNTZWxlY3Rvcih0YXJnZXQsIGAuJHtub0RyYWdDbGFzc05hbWV9YCwgZG9tTm9kZSkpICYmXG4gICAgICAgICAgICAgICAgKCFoYW5kbGVTZWxlY3RvciB8fCBoYXNTZWxlY3Rvcih0YXJnZXQsIGhhbmRsZVNlbGVjdG9yLCBkb21Ob2RlKSk7XG4gICAgICAgICAgICByZXR1cm4gaXNEcmFnZ2FibGU7XG4gICAgICAgIH0pO1xuICAgICAgICBkM1NlbGVjdGlvbi5jYWxsKGQzRHJhZ0luc3RhbmNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgZDNTZWxlY3Rpb24/Lm9uKCcuZHJhZycsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUsXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZXNXaXRoaW5EaXN0YW5jZShwb3NpdGlvbiwgbm9kZUxvb2t1cCwgZGlzdGFuY2UpIHtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IHJlY3QgPSB7XG4gICAgICAgIHg6IHBvc2l0aW9uLnggLSBkaXN0YW5jZSxcbiAgICAgICAgeTogcG9zaXRpb24ueSAtIGRpc3RhbmNlLFxuICAgICAgICB3aWR0aDogZGlzdGFuY2UgKiAyLFxuICAgICAgICBoZWlnaHQ6IGRpc3RhbmNlICogMixcbiAgICB9O1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTG9va3VwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChnZXRPdmVybGFwcGluZ0FyZWEocmVjdCwgbm9kZVRvUmVjdChub2RlKSkgPiAwKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbi8vIHRoaXMgZGlzdGFuY2UgaXMgdXNlZCBmb3IgdGhlIGFyZWEgYXJvdW5kIHRoZSB1c2VyIHBvaW50ZXJcbi8vIHdoaWxlIGRvaW5nIGEgY29ubmVjdGlvbiBmb3IgZmluZGluZyB0aGUgY2xvc2VzdCBub2Rlc1xuY29uc3QgQURESVRJT05BTF9ESVNUQU5DRSA9IDI1MDtcbmZ1bmN0aW9uIGdldENsb3Nlc3RIYW5kbGUocG9zaXRpb24sIGNvbm5lY3Rpb25SYWRpdXMsIG5vZGVMb29rdXAsIGZyb21IYW5kbGUpIHtcbiAgICBsZXQgY2xvc2VzdEhhbmRsZXMgPSBbXTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBjb25zdCBjbG9zZU5vZGVzID0gZ2V0Tm9kZXNXaXRoaW5EaXN0YW5jZShwb3NpdGlvbiwgbm9kZUxvb2t1cCwgY29ubmVjdGlvblJhZGl1cyArIEFERElUSU9OQUxfRElTVEFOQ0UpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjbG9zZU5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGFsbEhhbmRsZXMgPSBbLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8uc291cmNlID8/IFtdKSwgLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKV07XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlIG9mIGFsbEhhbmRsZXMpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBoYW5kbGUgaXMgdGhlIHNhbWUgYXMgdGhlIGZyb21IYW5kbGUgd2Ugc2tpcCBpdFxuICAgICAgICAgICAgaWYgKGZyb21IYW5kbGUubm9kZUlkID09PSBoYW5kbGUubm9kZUlkICYmIGZyb21IYW5kbGUudHlwZSA9PT0gaGFuZGxlLnR5cGUgJiYgZnJvbUhhbmRsZS5pZCA9PT0gaGFuZGxlLmlkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGhhbmRsZVxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXRIYW5kbGVQb3NpdGlvbihub2RlLCBoYW5kbGUsIGhhbmRsZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4IC0gcG9zaXRpb24ueCwgMikgKyBNYXRoLnBvdyh5IC0gcG9zaXRpb24ueSwgMikpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gY29ubmVjdGlvblJhZGl1cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0SGFuZGxlcyA9IFt7IC4uLmhhbmRsZSwgeCwgeSB9XTtcbiAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBtdWx0aXBsZSBoYW5kbGVzIGFyZSBvbiB0aGUgc2FtZSBkaXN0YW5jZSB3ZSBjb2xsZWN0IGFsbCBvZiB0aGVtXG4gICAgICAgICAgICAgICAgY2xvc2VzdEhhbmRsZXMucHVzaCh7IC4uLmhhbmRsZSwgeCwgeSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNsb3Nlc3RIYW5kbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gd2hlbiBtdWx0aXBsZSBoYW5kbGVzIG92ZXJsYXkgZWFjaCBvdGhlciB3ZSBwcmVmZXIgdGhlIG9wcG9zaXRlIGhhbmRsZVxuICAgIGlmIChjbG9zZXN0SGFuZGxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IG9wcG9zaXRlSGFuZGxlVHlwZSA9IGZyb21IYW5kbGUudHlwZSA9PT0gJ3NvdXJjZScgPyAndGFyZ2V0JyA6ICdzb3VyY2UnO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEhhbmRsZXMuZmluZCgoaGFuZGxlKSA9PiBoYW5kbGUudHlwZSA9PT0gb3Bwb3NpdGVIYW5kbGVUeXBlKSA/PyBjbG9zZXN0SGFuZGxlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3RIYW5kbGVzWzBdO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlKG5vZGVJZCwgaGFuZGxlVHlwZSwgaGFuZGxlSWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb25Nb2RlLCB3aXRoQWJzb2x1dGVQb3NpdGlvbiA9IGZhbHNlKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVzID0gY29ubmVjdGlvbk1vZGUgPT09ICdzdHJpY3QnXG4gICAgICAgID8gbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy5baGFuZGxlVHlwZV1cbiAgICAgICAgOiBbLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8uc291cmNlID8/IFtdKSwgLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKV07XG4gICAgY29uc3QgaGFuZGxlID0gKGhhbmRsZUlkID8gaGFuZGxlcz8uZmluZCgoaCkgPT4gaC5pZCA9PT0gaGFuZGxlSWQpIDogaGFuZGxlcz8uWzBdKSA/PyBudWxsO1xuICAgIHJldHVybiBoYW5kbGUgJiYgd2l0aEFic29sdXRlUG9zaXRpb25cbiAgICAgICAgPyB7IC4uLmhhbmRsZSwgLi4uZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgaGFuZGxlLCBoYW5kbGUucG9zaXRpb24sIHRydWUpIH1cbiAgICAgICAgOiBoYW5kbGU7XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVUeXBlKGVkZ2VVcGRhdGVyVHlwZSwgaGFuZGxlRG9tTm9kZSkge1xuICAgIGlmIChlZGdlVXBkYXRlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VVcGRhdGVyVHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlRG9tTm9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXJnZXQnKSkge1xuICAgICAgICByZXR1cm4gJ3RhcmdldCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhbmRsZURvbU5vZGU/LmNsYXNzTGlzdC5jb250YWlucygnc291cmNlJykpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2UnO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzQ29ubmVjdGlvblZhbGlkKGlzSW5zaWRlQ29ubmVjdGlvblJhZGl1cywgaXNIYW5kbGVWYWxpZCkge1xuICAgIGxldCBpc1ZhbGlkID0gbnVsbDtcbiAgICBpZiAoaXNIYW5kbGVWYWxpZCkge1xuICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNJbnNpZGVDb25uZWN0aW9uUmFkaXVzICYmICFpc0hhbmRsZVZhbGlkKSB7XG4gICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzVmFsaWQ7XG59XG5cbmNvbnN0IGFsd2F5c1ZhbGlkID0gKCkgPT4gdHJ1ZTtcbmZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQsIHsgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25SYWRpdXMsIGhhbmRsZUlkLCBub2RlSWQsIGVkZ2VVcGRhdGVyVHlwZSwgaXNUYXJnZXQsIGRvbU5vZGUsIG5vZGVMb29rdXAsIGxpYiwgYXV0b1Bhbk9uQ29ubmVjdCwgZmxvd0lkLCBwYW5CeSwgY2FuY2VsQ29ubmVjdGlvbiwgb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdCwgb25Db25uZWN0RW5kLCBpc1ZhbGlkQ29ubmVjdGlvbiA9IGFsd2F5c1ZhbGlkLCBvblJlY29ubmVjdEVuZCwgdXBkYXRlQ29ubmVjdGlvbiwgZ2V0VHJhbnNmb3JtLCBnZXRGcm9tSGFuZGxlLCBhdXRvUGFuU3BlZWQsIH0pIHtcbiAgICAvLyB3aGVuIHh5ZmxvdyBpcyB1c2VkIGluc2lkZSBhIHNoYWRvdyByb290IHdlIGNhbid0IHVzZSBkb2N1bWVudFxuICAgIGNvbnN0IGRvYyA9IGdldEhvc3RGb3JFbGVtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgbGV0IGF1dG9QYW5JZCA9IDA7XG4gICAgbGV0IGNsb3Nlc3RIYW5kbGU7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50KTtcbiAgICBjb25zdCBjbGlja2VkSGFuZGxlID0gZG9jPy5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IGhhbmRsZVR5cGUgPSBnZXRIYW5kbGVUeXBlKGVkZ2VVcGRhdGVyVHlwZSwgY2xpY2tlZEhhbmRsZSk7XG4gICAgY29uc3QgY29udGFpbmVyQm91bmRzID0gZG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKCFjb250YWluZXJCb3VuZHMgfHwgIWhhbmRsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSGFuZGxlSW50ZXJuYWwgPSBnZXRIYW5kbGUobm9kZUlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbk1vZGUpO1xuICAgIGlmICghZnJvbUhhbmRsZUludGVybmFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICBsZXQgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgY29ubmVjdGlvbiA9IG51bGw7XG4gICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgICBsZXQgaGFuZGxlRG9tTm9kZSA9IG51bGw7XG4gICAgLy8gd2hlbiB0aGUgdXNlciBpcyBtb3ZpbmcgdGhlIG1vdXNlIGNsb3NlIHRvIHRoZSBlZGdlIG9mIHRoZSBjYW52YXMgd2hpbGUgY29ubmVjdGluZyB3ZSBtb3ZlIHRoZSBjYW52YXNcbiAgICBmdW5jdGlvbiBhdXRvUGFuKCkge1xuICAgICAgICBpZiAoIWF1dG9QYW5PbkNvbm5lY3QgfHwgIWNvbnRhaW5lckJvdW5kcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IGNhbGNBdXRvUGFuKHBvc2l0aW9uLCBjb250YWluZXJCb3VuZHMsIGF1dG9QYW5TcGVlZCk7XG4gICAgICAgIHBhbkJ5KHsgeCwgeSB9KTtcbiAgICAgICAgYXV0b1BhbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9QYW4pO1xuICAgIH1cbiAgICAvLyBTdGF5cyB0aGUgc2FtZSBmb3IgYWxsIGNvbnNlY3V0aXZlIHBvaW50ZXJtb3ZlIGV2ZW50c1xuICAgIGNvbnN0IGZyb21IYW5kbGUgPSB7XG4gICAgICAgIC4uLmZyb21IYW5kbGVJbnRlcm5hbCxcbiAgICAgICAgbm9kZUlkLFxuICAgICAgICB0eXBlOiBoYW5kbGVUeXBlLFxuICAgICAgICBwb3NpdGlvbjogZnJvbUhhbmRsZUludGVybmFsLnBvc2l0aW9uLFxuICAgIH07XG4gICAgY29uc3QgZnJvbU5vZGVJbnRlcm5hbCA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgY29uc3QgZnJvbSA9IGdldEhhbmRsZVBvc2l0aW9uKGZyb21Ob2RlSW50ZXJuYWwsIGZyb21IYW5kbGUsIFBvc2l0aW9uLkxlZnQsIHRydWUpO1xuICAgIGNvbnN0IG5ld0Nvbm5lY3Rpb24gPSB7XG4gICAgICAgIGluUHJvZ3Jlc3M6IHRydWUsXG4gICAgICAgIGlzVmFsaWQ6IG51bGwsXG4gICAgICAgIGZyb20sXG4gICAgICAgIGZyb21IYW5kbGUsXG4gICAgICAgIGZyb21Qb3NpdGlvbjogZnJvbUhhbmRsZS5wb3NpdGlvbixcbiAgICAgICAgZnJvbU5vZGU6IGZyb21Ob2RlSW50ZXJuYWwsXG4gICAgICAgIHRvOiBwb3NpdGlvbixcbiAgICAgICAgdG9IYW5kbGU6IG51bGwsXG4gICAgICAgIHRvUG9zaXRpb246IG9wcG9zaXRlUG9zaXRpb25bZnJvbUhhbmRsZS5wb3NpdGlvbl0sXG4gICAgICAgIHRvTm9kZTogbnVsbCxcbiAgICB9O1xuICAgIHVwZGF0ZUNvbm5lY3Rpb24obmV3Q29ubmVjdGlvbik7XG4gICAgbGV0IHByZXZpb3VzQ29ubmVjdGlvbiA9IG5ld0Nvbm5lY3Rpb247XG4gICAgb25Db25uZWN0U3RhcnQ/LihldmVudCwgeyBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlIH0pO1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFnZXRGcm9tSGFuZGxlKCkgfHwgIWZyb21IYW5kbGUpIHtcbiAgICAgICAgICAgIG9uUG9pbnRlclVwKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgcG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgICAgICBjbG9zZXN0SGFuZGxlID0gZ2V0Q2xvc2VzdEhhbmRsZShwb2ludFRvUmVuZGVyZXJQb2ludChwb3NpdGlvbiwgdHJhbnNmb3JtLCBmYWxzZSwgWzEsIDFdKSwgY29ubmVjdGlvblJhZGl1cywgbm9kZUxvb2t1cCwgZnJvbUhhbmRsZSk7XG4gICAgICAgIGlmICghYXV0b1BhblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGF1dG9QYW4oKTtcbiAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBpc1ZhbGlkSGFuZGxlKGV2ZW50LCB7XG4gICAgICAgICAgICBoYW5kbGU6IGNsb3Nlc3RIYW5kbGUsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGZyb21Ob2RlSWQ6IG5vZGVJZCxcbiAgICAgICAgICAgIGZyb21IYW5kbGVJZDogaGFuZGxlSWQsXG4gICAgICAgICAgICBmcm9tVHlwZTogaXNUYXJnZXQgPyAndGFyZ2V0JyA6ICdzb3VyY2UnLFxuICAgICAgICAgICAgaXNWYWxpZENvbm5lY3Rpb24sXG4gICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBmbG93SWQsXG4gICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlRG9tTm9kZSA9IHJlc3VsdC5oYW5kbGVEb21Ob2RlO1xuICAgICAgICBjb25uZWN0aW9uID0gcmVzdWx0LmNvbm5lY3Rpb247XG4gICAgICAgIGlzVmFsaWQgPSBpc0Nvbm5lY3Rpb25WYWxpZCghIWNsb3Nlc3RIYW5kbGUsIHJlc3VsdC5pc1ZhbGlkKTtcbiAgICAgICAgY29uc3QgbmV3Q29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIC8vIGZyb20gc3RheXMgdGhlIHNhbWVcbiAgICAgICAgICAgIC4uLnByZXZpb3VzQ29ubmVjdGlvbixcbiAgICAgICAgICAgIGlzVmFsaWQsXG4gICAgICAgICAgICB0bzogY2xvc2VzdEhhbmRsZSAmJiBpc1ZhbGlkXG4gICAgICAgICAgICAgICAgPyByZW5kZXJlclBvaW50VG9Qb2ludCh7IHg6IGNsb3Nlc3RIYW5kbGUueCwgeTogY2xvc2VzdEhhbmRsZS55IH0sIHRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICA6IHBvc2l0aW9uLFxuICAgICAgICAgICAgdG9IYW5kbGU6IHJlc3VsdC50b0hhbmRsZSxcbiAgICAgICAgICAgIHRvUG9zaXRpb246IGlzVmFsaWQgJiYgcmVzdWx0LnRvSGFuZGxlID8gcmVzdWx0LnRvSGFuZGxlLnBvc2l0aW9uIDogb3Bwb3NpdGVQb3NpdGlvbltmcm9tSGFuZGxlLnBvc2l0aW9uXSxcbiAgICAgICAgICAgIHRvTm9kZTogcmVzdWx0LnRvSGFuZGxlID8gbm9kZUxvb2t1cC5nZXQocmVzdWx0LnRvSGFuZGxlLm5vZGVJZCkgOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgYW4gdXBkYXRlIHdoZW4gdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gaXMgc25hcHBlZCB0byB0aGUgc2FtZSBoYW5kbGUgYXMgYmVmb3JlXG4gICAgICAgIGlmIChpc1ZhbGlkICYmXG4gICAgICAgICAgICBjbG9zZXN0SGFuZGxlICYmXG4gICAgICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUgJiZcbiAgICAgICAgICAgIG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZS50eXBlID09PSBuZXdDb25uZWN0aW9uLnRvSGFuZGxlLnR5cGUgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZS5ub2RlSWQgPT09IG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUubm9kZUlkICYmXG4gICAgICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUuaWQgPT09IG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUuaWQgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50by54ID09PSBuZXdDb25uZWN0aW9uLnRvLnggJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50by55ID09PSBuZXdDb25uZWN0aW9uLnRvLnkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVDb25uZWN0aW9uKG5ld0Nvbm5lY3Rpb24pO1xuICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24gPSBuZXdDb25uZWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCkge1xuICAgICAgICBpZiAoKGNsb3Nlc3RIYW5kbGUgfHwgaGFuZGxlRG9tTm9kZSkgJiYgY29ubmVjdGlvbiAmJiBpc1ZhbGlkKSB7XG4gICAgICAgICAgICBvbkNvbm5lY3Q/Lihjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpdCdzIGltcG9ydGFudCB0byBnZXQgYSBmcmVzaCByZWZlcmVuY2UgZnJvbSB0aGUgc3RvcmUgaGVyZVxuICAgICAgICAvLyBpbiBvcmRlciB0byBnZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBvbkNvbm5lY3RFbmRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCB7IGluUHJvZ3Jlc3MsIC4uLmNvbm5lY3Rpb25TdGF0ZSB9ID0gcHJldmlvdXNDb25uZWN0aW9uO1xuICAgICAgICBjb25zdCBmaW5hbENvbm5lY3Rpb25TdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLmNvbm5lY3Rpb25TdGF0ZSxcbiAgICAgICAgICAgIHRvUG9zaXRpb246IHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZSA/IHByZXZpb3VzQ29ubmVjdGlvbi50b1Bvc2l0aW9uIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgb25Db25uZWN0RW5kPy4oZXZlbnQsIGZpbmFsQ29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgaWYgKGVkZ2VVcGRhdGVyVHlwZSkge1xuICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ/LihldmVudCwgZmluYWxDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhbmNlbENvbm5lY3Rpb24oKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkKTtcbiAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICBjb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgaGFuZGxlRG9tTm9kZSA9IG51bGw7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblBvaW50ZXJVcCk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Qb2ludGVyVXApO1xuICAgIH1cbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblBvaW50ZXJVcCk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uUG9pbnRlclVwKTtcbn1cbi8vIGNoZWNrcyBpZiAgYW5kIHJldHVybnMgY29ubmVjdGlvbiBpbiBmb20gb2YgYW4gb2JqZWN0IHsgc291cmNlOiAxMjMsIHRhcmdldDogMzEyIH1cbmZ1bmN0aW9uIGlzVmFsaWRIYW5kbGUoZXZlbnQsIHsgaGFuZGxlLCBjb25uZWN0aW9uTW9kZSwgZnJvbU5vZGVJZCwgZnJvbUhhbmRsZUlkLCBmcm9tVHlwZSwgZG9jLCBsaWIsIGZsb3dJZCwgaXNWYWxpZENvbm5lY3Rpb24gPSBhbHdheXNWYWxpZCwgbm9kZUxvb2t1cCwgfSkge1xuICAgIGNvbnN0IGlzVGFyZ2V0ID0gZnJvbVR5cGUgPT09ICd0YXJnZXQnO1xuICAgIGNvbnN0IGhhbmRsZURvbU5vZGUgPSBoYW5kbGVcbiAgICAgICAgPyBkb2MucXVlcnlTZWxlY3RvcihgLiR7bGlifS1mbG93X19oYW5kbGVbZGF0YS1pZD1cIiR7Zmxvd0lkfS0ke2hhbmRsZT8ubm9kZUlkfS0ke2hhbmRsZT8uaWR9LSR7aGFuZGxlPy50eXBlfVwiXWApXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQpO1xuICAgIGNvbnN0IGhhbmRsZUJlbG93ID0gZG9jLmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgLy8gd2UgYWx3YXlzIHdhbnQgdG8gcHJpb3JpdGl6ZSB0aGUgaGFuZGxlIGJlbG93IHRoZSBtb3VzZSBjdXJzb3Igb3ZlciB0aGUgY2xvc2VzdCBkaXN0YW5jZSBoYW5kbGUsXG4gICAgLy8gYmVjYXVzZSBpdCBjb3VsZCBiZSB0aGF0IHRoZSBjZW50ZXIgb2YgYW5vdGhlciBoYW5kbGUgaXMgY2xvc2VyIHRvIHRoZSBtb3VzZSBwb2ludGVyIHRoYW4gdGhlIGhhbmRsZSBiZWxvdyB0aGUgY3Vyc29yXG4gICAgY29uc3QgaGFuZGxlVG9DaGVjayA9IGhhbmRsZUJlbG93Py5jbGFzc0xpc3QuY29udGFpbnMoYCR7bGlifS1mbG93X19oYW5kbGVgKSA/IGhhbmRsZUJlbG93IDogaGFuZGxlRG9tTm9kZTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGhhbmRsZURvbU5vZGU6IGhhbmRsZVRvQ2hlY2ssXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBjb25uZWN0aW9uOiBudWxsLFxuICAgICAgICB0b0hhbmRsZTogbnVsbCxcbiAgICB9O1xuICAgIGlmIChoYW5kbGVUb0NoZWNrKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZVR5cGUgPSBnZXRIYW5kbGVUeXBlKHVuZGVmaW5lZCwgaGFuZGxlVG9DaGVjayk7XG4gICAgICAgIGNvbnN0IGhhbmRsZU5vZGVJZCA9IGhhbmRsZVRvQ2hlY2suZ2V0QXR0cmlidXRlKCdkYXRhLW5vZGVpZCcpO1xuICAgICAgICBjb25zdCBoYW5kbGVJZCA9IGhhbmRsZVRvQ2hlY2suZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZWlkJyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RhYmxlID0gaGFuZGxlVG9DaGVjay5jbGFzc0xpc3QuY29udGFpbnMoJ2Nvbm5lY3RhYmxlJyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RhYmxlRW5kID0gaGFuZGxlVG9DaGVjay5jbGFzc0xpc3QuY29udGFpbnMoJ2Nvbm5lY3RhYmxlZW5kJyk7XG4gICAgICAgIGlmICghaGFuZGxlTm9kZUlkIHx8ICFoYW5kbGVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICBzb3VyY2U6IGlzVGFyZ2V0ID8gaGFuZGxlTm9kZUlkIDogZnJvbU5vZGVJZCxcbiAgICAgICAgICAgIHNvdXJjZUhhbmRsZTogaXNUYXJnZXQgPyBoYW5kbGVJZCA6IGZyb21IYW5kbGVJZCxcbiAgICAgICAgICAgIHRhcmdldDogaXNUYXJnZXQgPyBmcm9tTm9kZUlkIDogaGFuZGxlTm9kZUlkLFxuICAgICAgICAgICAgdGFyZ2V0SGFuZGxlOiBpc1RhcmdldCA/IGZyb21IYW5kbGVJZCA6IGhhbmRsZUlkLFxuICAgICAgICB9O1xuICAgICAgICByZXN1bHQuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGFibGUgPSBjb25uZWN0YWJsZSAmJiBjb25uZWN0YWJsZUVuZDtcbiAgICAgICAgLy8gaW4gc3RyaWN0IG1vZGUgd2UgZG9uJ3QgYWxsb3cgdGFyZ2V0IHRvIHRhcmdldCBvciBzb3VyY2UgdG8gc291cmNlIGNvbm5lY3Rpb25zXG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBpc0Nvbm5lY3RhYmxlICYmXG4gICAgICAgICAgICAoY29ubmVjdGlvbk1vZGUgPT09IENvbm5lY3Rpb25Nb2RlLlN0cmljdFxuICAgICAgICAgICAgICAgID8gKGlzVGFyZ2V0ICYmIGhhbmRsZVR5cGUgPT09ICdzb3VyY2UnKSB8fCAoIWlzVGFyZ2V0ICYmIGhhbmRsZVR5cGUgPT09ICd0YXJnZXQnKVxuICAgICAgICAgICAgICAgIDogaGFuZGxlTm9kZUlkICE9PSBmcm9tTm9kZUlkIHx8IGhhbmRsZUlkICE9PSBmcm9tSGFuZGxlSWQpO1xuICAgICAgICByZXN1bHQuaXNWYWxpZCA9IGlzVmFsaWQgJiYgaXNWYWxpZENvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgIHJlc3VsdC50b0hhbmRsZSA9IGdldEhhbmRsZShoYW5kbGVOb2RlSWQsIGhhbmRsZVR5cGUsIGhhbmRsZUlkLCBub2RlTG9va3VwLCBjb25uZWN0aW9uTW9kZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgWFlIYW5kbGUgPSB7XG4gICAgb25Qb2ludGVyRG93bixcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkSGFuZGxlLFxufTtcblxuZnVuY3Rpb24gWFlNaW5pbWFwKHsgZG9tTm9kZSwgcGFuWm9vbSwgZ2V0VHJhbnNmb3JtLCBnZXRWaWV3U2NhbGUgfSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKTtcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyB0cmFuc2xhdGVFeHRlbnQsIHdpZHRoLCBoZWlnaHQsIHpvb21TdGVwID0gMTAsIHBhbm5hYmxlID0gdHJ1ZSwgem9vbWFibGUgPSB0cnVlLCBpbnZlcnNlUGFuID0gZmFsc2UsIH0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgem9vbUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50LnR5cGUgIT09ICd3aGVlbCcgfHwgIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwaW5jaERlbHRhID0gLWV2ZW50LnNvdXJjZUV2ZW50LmRlbHRhWSAqXG4gICAgICAgICAgICAgICAgKGV2ZW50LnNvdXJjZUV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDAuMDUgOiBldmVudC5zb3VyY2VFdmVudC5kZWx0YU1vZGUgPyAxIDogMC4wMDIpICpcbiAgICAgICAgICAgICAgICB6b29tU3RlcDtcbiAgICAgICAgICAgIGNvbnN0IG5leHRab29tID0gdHJhbnNmb3JtWzJdICogTWF0aC5wb3coMiwgcGluY2hEZWx0YSk7XG4gICAgICAgICAgICBwYW5ab29tLnNjYWxlVG8obmV4dFpvb20pO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcGFuU3RhcnQgPSBbMCwgMF07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHBhblN0YXJ0SGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGV2ZW50LnNvdXJjZUV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICAgICAgICAgIHBhblN0YXJ0ID0gW1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRYID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc291cmNlRXZlbnQuY2xpZW50WSA/PyBldmVudC5zb3VyY2VFdmVudC50b3VjaGVzWzBdLmNsaWVudFksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcGFuSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBpZiAoKGV2ZW50LnNvdXJjZUV2ZW50LnR5cGUgIT09ICdtb3VzZW1vdmUnICYmIGV2ZW50LnNvdXJjZUV2ZW50LnR5cGUgIT09ICd0b3VjaG1vdmUnKSB8fCAhcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhbkN1cnJlbnQgPSBbXG4gICAgICAgICAgICAgICAgZXZlbnQuc291cmNlRXZlbnQuY2xpZW50WCA/PyBldmVudC5zb3VyY2VFdmVudC50b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgZXZlbnQuc291cmNlRXZlbnQuY2xpZW50WSA/PyBldmVudC5zb3VyY2VFdmVudC50b3VjaGVzWzBdLmNsaWVudFksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgcGFuRGVsdGEgPSBbcGFuQ3VycmVudFswXSAtIHBhblN0YXJ0WzBdLCBwYW5DdXJyZW50WzFdIC0gcGFuU3RhcnRbMV1dO1xuICAgICAgICAgICAgcGFuU3RhcnQgPSBwYW5DdXJyZW50O1xuICAgICAgICAgICAgY29uc3QgbW92ZVNjYWxlID0gZ2V0Vmlld1NjYWxlKCkgKiBNYXRoLm1heCh0cmFuc2Zvcm1bMl0sIE1hdGgubG9nKHRyYW5zZm9ybVsyXSkpICogKGludmVyc2VQYW4gPyAtMSA6IDEpO1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogdHJhbnNmb3JtWzBdIC0gcGFuRGVsdGFbMF0gKiBtb3ZlU2NhbGUsXG4gICAgICAgICAgICAgICAgeTogdHJhbnNmb3JtWzFdIC0gcGFuRGVsdGFbMV0gKiBtb3ZlU2NhbGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICAgICAgICBbd2lkdGgsIGhlaWdodF0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcGFuWm9vbS5zZXRWaWV3cG9ydENvbnN0cmFpbmVkKHtcbiAgICAgICAgICAgICAgICB4OiBwb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgIHk6IHBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgem9vbTogdHJhbnNmb3JtWzJdLFxuICAgICAgICAgICAgfSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB6b29tQW5kUGFuSGFuZGxlciA9IHpvb20oKVxuICAgICAgICAgICAgLm9uKCdzdGFydCcsIHBhblN0YXJ0SGFuZGxlcilcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIC5vbignem9vbScsIHBhbm5hYmxlID8gcGFuSGFuZGxlciA6IG51bGwpXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAub24oJ3pvb20ud2hlZWwnLCB6b29tYWJsZSA/IHpvb21IYW5kbGVyIDogbnVsbCk7XG4gICAgICAgIHNlbGVjdGlvbi5jYWxsKHpvb21BbmRQYW5IYW5kbGVyLCB7fSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHNlbGVjdGlvbi5vbignem9vbScsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUsXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgICAgIHBvaW50ZXIsXG4gICAgfTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3Qgdmlld0NoYW5nZWQgPSAocHJldlZpZXdwb3J0LCBldmVudFZpZXdwb3J0KSA9PiBwcmV2Vmlld3BvcnQueCAhPT0gZXZlbnRWaWV3cG9ydC54IHx8IHByZXZWaWV3cG9ydC55ICE9PSBldmVudFZpZXdwb3J0LnkgfHwgcHJldlZpZXdwb3J0Lnpvb20gIT09IGV2ZW50Vmlld3BvcnQuaztcbmNvbnN0IHRyYW5zZm9ybVRvVmlld3BvcnQgPSAodHJhbnNmb3JtKSA9PiAoe1xuICAgIHg6IHRyYW5zZm9ybS54LFxuICAgIHk6IHRyYW5zZm9ybS55LFxuICAgIHpvb206IHRyYW5zZm9ybS5rLFxufSk7XG5jb25zdCB2aWV3cG9ydFRvVHJhbnNmb3JtID0gKHsgeCwgeSwgem9vbSB9KSA9PiB6b29tSWRlbnRpdHkudHJhbnNsYXRlKHgsIHkpLnNjYWxlKHpvb20pO1xuY29uc3QgaXNXcmFwcGVkV2l0aENsYXNzID0gKGV2ZW50LCBjbGFzc05hbWUpID0+IGV2ZW50LnRhcmdldC5jbG9zZXN0KGAuJHtjbGFzc05hbWV9YCk7XG5jb25zdCBpc1JpZ2h0Q2xpY2tQYW4gPSAocGFuT25EcmFnLCB1c2VkQnV0dG9uKSA9PiB1c2VkQnV0dG9uID09PSAyICYmIEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoMik7XG5jb25zdCBnZXREM1RyYW5zaXRpb24gPSAoc2VsZWN0aW9uLCBkdXJhdGlvbiA9IDAsIG9uRW5kID0gKCkgPT4geyB9KSA9PiB7XG4gICAgY29uc3QgaGFzRHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInICYmIGR1cmF0aW9uID4gMDtcbiAgICBpZiAoIWhhc0R1cmF0aW9uKSB7XG4gICAgICAgIG9uRW5kKCk7XG4gICAgfVxuICAgIHJldHVybiBoYXNEdXJhdGlvbiA/IHNlbGVjdGlvbi50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLm9uKCdlbmQnLCBvbkVuZCkgOiBzZWxlY3Rpb247XG59O1xuY29uc3Qgd2hlZWxEZWx0YSA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGZhY3RvciA9IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWNPcygpID8gMTAgOiAxO1xuICAgIHJldHVybiAtZXZlbnQuZGVsdGFZICogKGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDAuMDUgOiBldmVudC5kZWx0YU1vZGUgPyAxIDogMC4wMDIpICogZmFjdG9yO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlUGFuT25TY3JvbGxIYW5kbGVyKHsgem9vbVBhblZhbHVlcywgbm9XaGVlbENsYXNzTmFtZSwgZDNTZWxlY3Rpb24sIGQzWm9vbSwgcGFuT25TY3JvbGxNb2RlLCBwYW5PblNjcm9sbFNwZWVkLCB6b29tT25QaW5jaCwgb25QYW5ab29tU3RhcnQsIG9uUGFuWm9vbSwgb25QYW5ab29tRW5kLCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1doZWVsQ2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IGQzU2VsZWN0aW9uLnByb3BlcnR5KCdfX3pvb20nKS5rIHx8IDE7XG4gICAgICAgIC8vIG1hY29zIHNldHMgY3RybEtleT10cnVlIGZvciBwaW5jaCBnZXN0dXJlIG9uIGEgdHJhY2twYWRcbiAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgem9vbU9uUGluY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRlcihldmVudCk7XG4gICAgICAgICAgICBjb25zdCBwaW5jaERlbHRhID0gd2hlZWxEZWx0YShldmVudCk7XG4gICAgICAgICAgICBjb25zdCB6b29tID0gY3VycmVudFpvb20gKiBNYXRoLnBvdygyLCBwaW5jaERlbHRhKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGQzWm9vbS5zY2FsZVRvKGQzU2VsZWN0aW9uLCB6b29tLCBwb2ludCwgZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluY3JlYXNlIHNjcm9sbCBzcGVlZCBpbiBmaXJlZm94XG4gICAgICAgIC8vIGZpcmVmb3g6IGRlbHRhTW9kZSA9PT0gMTsgY2hyb21lOiBkZWx0YU1vZGUgPT09IDBcbiAgICAgICAgY29uc3QgZGVsdGFOb3JtYWxpemUgPSBldmVudC5kZWx0YU1vZGUgPT09IDEgPyAyMCA6IDE7XG4gICAgICAgIGxldCBkZWx0YVggPSBwYW5PblNjcm9sbE1vZGUgPT09IFBhbk9uU2Nyb2xsTW9kZS5WZXJ0aWNhbCA/IDAgOiBldmVudC5kZWx0YVggKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgbGV0IGRlbHRhWSA9IHBhbk9uU2Nyb2xsTW9kZSA9PT0gUGFuT25TY3JvbGxNb2RlLkhvcml6b250YWwgPyAwIDogZXZlbnQuZGVsdGFZICogZGVsdGFOb3JtYWxpemU7XG4gICAgICAgIC8vIHRoaXMgZW5hYmxlcyB2ZXJ0aWNhbCBzY3JvbGxpbmcgd2l0aCBzaGlmdCArIHNjcm9sbCBvbiB3aW5kb3dzXG4gICAgICAgIGlmICghaXNNYWNPcygpICYmIGV2ZW50LnNoaWZ0S2V5ICYmIHBhbk9uU2Nyb2xsTW9kZSAhPT0gUGFuT25TY3JvbGxNb2RlLlZlcnRpY2FsKSB7XG4gICAgICAgICAgICBkZWx0YVggPSBldmVudC5kZWx0YVkgKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgICAgIGRlbHRhWSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZDNab29tLnRyYW5zbGF0ZUJ5KGQzU2VsZWN0aW9uLCAtKGRlbHRhWCAvIGN1cnJlbnRab29tKSAqIHBhbk9uU2Nyb2xsU3BlZWQsIC0oZGVsdGFZIC8gY3VycmVudFpvb20pICogcGFuT25TY3JvbGxTcGVlZCwgXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgeyBpbnRlcm5hbDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgbmV4dFZpZXdwb3J0ID0gdHJhbnNmb3JtVG9WaWV3cG9ydChkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJykpO1xuICAgICAgICBjbGVhclRpbWVvdXQoem9vbVBhblZhbHVlcy5wYW5TY3JvbGxUaW1lb3V0KTtcbiAgICAgICAgLy8gZm9yIHBhbiBvbiBzY3JvbGwgd2UgbmVlZCB0byBoYW5kbGUgdGhlIGV2ZW50IGNhbGxzIG9uIG91ciBvd25cbiAgICAgICAgLy8gd2UgY2FuJ3QgdXNlIHRoZSBzdGFydCwgem9vbSBhbmQgZW5kIGV2ZW50cyBmcm9tIGQzLXpvb21cbiAgICAgICAgLy8gYmVjYXVzZSBzdGFydCBhbmQgbW92ZSBnZXRzIGNhbGxlZCBvbiBldmVyeSBzY3JvbGwgZXZlbnQgYW5kIG5vdCBvbmNlIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgaWYgKCF6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0Py4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHpvb21QYW5WYWx1ZXMuaXNQYW5TY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIG9uUGFuWm9vbT8uKGV2ZW50LCBuZXh0Vmlld3BvcnQpO1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy5wYW5TY3JvbGxUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kPy4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVab29tT25TY3JvbGxIYW5kbGVyKHsgbm9XaGVlbENsYXNzTmFtZSwgcHJldmVudFNjcm9sbGluZywgZDNab29tSGFuZGxlciB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCwgZCkge1xuICAgICAgICAvLyB3ZSBzdGlsbCB3YW50IHRvIGVuYWJsZSBwaW5jaCB6b29taW5nIGV2ZW4gaWYgcHJldmVudFNjcm9sbGluZyBpcyBzZXQgdG8gZmFsc2VcbiAgICAgICAgY29uc3QgcHJldmVudFpvb20gPSAhcHJldmVudFNjcm9sbGluZyAmJiBldmVudC50eXBlID09PSAnd2hlZWwnICYmICFldmVudC5jdHJsS2V5O1xuICAgICAgICBpZiAocHJldmVudFpvb20gfHwgaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1doZWVsQ2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZDNab29tSGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50LCBkKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGFuWm9vbVN0YXJ0SGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIG9uRHJhZ2dpbmdDaGFuZ2UsIG9uUGFuWm9vbVN0YXJ0IH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudD8uaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHRyYW5zZm9ybVRvVmlld3BvcnQoZXZlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZW1lbWJlciBpdCBoZXJlLCBiZWNhdXNlIGl0J3MgYWx3YXlzIDAgaW4gdGhlIFwiem9vbVwiIGV2ZW50XG4gICAgICAgIHpvb21QYW5WYWx1ZXMubW91c2VCdXR0b24gPSBldmVudC5zb3VyY2VFdmVudD8uYnV0dG9uIHx8IDA7XG4gICAgICAgIHpvb21QYW5WYWx1ZXMuaXNab29taW5nT3JQYW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgem9vbVBhblZhbHVlcy5wcmV2Vmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50Py50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgb25EcmFnZ2luZ0NoYW5nZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25QYW5ab29tU3RhcnQpIHtcbiAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIHZpZXdwb3J0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYW5ab29tSGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIHBhbk9uRHJhZywgb25QYW5lQ29udGV4dE1lbnUsIG9uVHJhbnNmb3JtQ2hhbmdlLCBvblBhblpvb20sIH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIHpvb21QYW5WYWx1ZXMudXNlZFJpZ2h0TW91c2VCdXR0b24gPSAhIShvblBhbmVDb250ZXh0TWVudSAmJiBpc1JpZ2h0Q2xpY2tQYW4ocGFuT25EcmFnLCB6b29tUGFuVmFsdWVzLm1vdXNlQnV0dG9uID8/IDApKTtcbiAgICAgICAgaWYgKCFldmVudC5zb3VyY2VFdmVudD8uc3luYykge1xuICAgICAgICAgICAgb25UcmFuc2Zvcm1DaGFuZ2UoW2V2ZW50LnRyYW5zZm9ybS54LCBldmVudC50cmFuc2Zvcm0ueSwgZXZlbnQudHJhbnNmb3JtLmtdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25QYW5ab29tICYmICFldmVudC5zb3VyY2VFdmVudD8uaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIG9uUGFuWm9vbT8uKGV2ZW50LnNvdXJjZUV2ZW50LCB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGV2ZW50LnRyYW5zZm9ybSkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhblpvb21FbmRIYW5kbGVyKHsgem9vbVBhblZhbHVlcywgcGFuT25EcmFnLCBwYW5PblNjcm9sbCwgb25EcmFnZ2luZ0NoYW5nZSwgb25QYW5ab29tRW5kLCBvblBhbmVDb250ZXh0TWVudSwgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50Py5pbnRlcm5hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHpvb21QYW5WYWx1ZXMuaXNab29taW5nT3JQYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChvblBhbmVDb250ZXh0TWVudSAmJlxuICAgICAgICAgICAgaXNSaWdodENsaWNrUGFuKHBhbk9uRHJhZywgem9vbVBhblZhbHVlcy5tb3VzZUJ1dHRvbiA/PyAwKSAmJlxuICAgICAgICAgICAgIXpvb21QYW5WYWx1ZXMudXNlZFJpZ2h0TW91c2VCdXR0b24gJiZcbiAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICBvblBhbmVDb250ZXh0TWVudShldmVudC5zb3VyY2VFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgem9vbVBhblZhbHVlcy51c2VkUmlnaHRNb3VzZUJ1dHRvbiA9IGZhbHNlO1xuICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgaWYgKG9uUGFuWm9vbUVuZCAmJiB2aWV3Q2hhbmdlZCh6b29tUGFuVmFsdWVzLnByZXZWaWV3cG9ydCwgZXZlbnQudHJhbnNmb3JtKSkge1xuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGV2ZW50LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICB6b29tUGFuVmFsdWVzLnByZXZWaWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHpvb21QYW5WYWx1ZXMudGltZXJJZCk7XG4gICAgICAgICAgICB6b29tUGFuVmFsdWVzLnRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQ/LihldmVudC5zb3VyY2VFdmVudCwgdmlld3BvcnQpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIGEgc2V0VGltZW91dCBmb3IgcGFuT25TY3JvbGwgdG8gc3VwcmVzcyBtdWx0aXBsZSBlbmQgZXZlbnRzIGZpcmVkIGR1cmluZyBzY3JvbGxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsID8gMTUwIDogMCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXIoeyB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsIHpvb21PblNjcm9sbCwgem9vbU9uUGluY2gsIHBhbk9uRHJhZywgcGFuT25TY3JvbGwsIHpvb21PbkRvdWJsZUNsaWNrLCB1c2VyU2VsZWN0aW9uQWN0aXZlLCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgbGliLCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB6b29tU2Nyb2xsID0gem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkIHx8IHpvb21PblNjcm9sbDtcbiAgICAgICAgY29uc3QgcGluY2hab29tID0gem9vbU9uUGluY2ggJiYgZXZlbnQuY3RybEtleTtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMSAmJlxuICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgJiZcbiAgICAgICAgICAgIChpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIGAke2xpYn0tZmxvd19fbm9kZWApIHx8IGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgYCR7bGlifS1mbG93X19lZGdlYCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhbGwgaW50ZXJhY3Rpb25zIGFyZSBkaXNhYmxlZCwgd2UgcHJldmVudCBhbGwgem9vbSBldmVudHNcbiAgICAgICAgaWYgKCFwYW5PbkRyYWcgJiYgIXpvb21TY3JvbGwgJiYgIXBhbk9uU2Nyb2xsICYmICF6b29tT25Eb3VibGVDbGljayAmJiAhem9vbU9uUGluY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkdXJpbmcgYSBzZWxlY3Rpb24gd2UgcHJldmVudCBhbGwgb3RoZXIgaW50ZXJhY3Rpb25zXG4gICAgICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggdGhlIG5vd2hlZWwgY2xhc3MsIHdlIHByZXZlbnQgem9vbWluZ1xuICAgICAgICBpZiAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1doZWVsQ2xhc3NOYW1lKSAmJiBldmVudC50eXBlID09PSAnd2hlZWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggdGhlIG5vcGFuIGNsYXNzLCB3ZSBwcmV2ZW50IHBhbm5pbmdcbiAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9QYW5DbGFzc05hbWUpICYmXG4gICAgICAgICAgICAoZXZlbnQudHlwZSAhPT0gJ3doZWVsJyB8fCAocGFuT25TY3JvbGwgJiYgZXZlbnQudHlwZSA9PT0gJ3doZWVsJyAmJiAhem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXpvb21PblBpbmNoICYmIGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghem9vbU9uUGluY2ggJiYgZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnICYmIGV2ZW50LnRvdWNoZXM/Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIHlvdSBtYW5hZ2UgdG8gc3RhcnQgd2l0aCAyIHRvdWNoZXMsIHdlIHByZXZlbnQgbmF0aXZlIHpvb21cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3aGVuIHRoZXJlIGlzIG5vIHNjcm9sbCBoYW5kbGluZyBlbmFibGVkLCB3ZSBwcmV2ZW50IGFsbCB3aGVlbCBldmVudHNcbiAgICAgICAgaWYgKCF6b29tU2Nyb2xsICYmICFwYW5PblNjcm9sbCAmJiAhcGluY2hab29tICYmIGV2ZW50LnR5cGUgPT09ICd3aGVlbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgcGFuZSBpcyBub3QgbW92YWJsZSwgd2UgcHJldmVudCBkcmFnZ2luZyBpdCB3aXRoIG1vdXNlc3RhcnQgb3IgdG91Y2hzdGFydFxuICAgICAgICBpZiAoIXBhbk9uRHJhZyAmJiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBwYW5lIGlzIG9ubHkgbW92YWJsZSB1c2luZyBhbGxvd2VkIGNsaWNrc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmICFwYW5PbkRyYWcuaW5jbHVkZXMoZXZlbnQuYnV0dG9uKSAmJiBldmVudC50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG9ubHkgYWxsb3cgcmlnaHQgY2xpY2tzIGlmIHBhbiBvbiBkcmFnIGlzIHNldCB0byByaWdodCBjbGlja1xuICAgICAgICBjb25zdCBidXR0b25BbGxvd2VkID0gKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoZXZlbnQuYnV0dG9uKSkgfHwgIWV2ZW50LmJ1dHRvbiB8fCBldmVudC5idXR0b24gPD0gMTtcbiAgICAgICAgLy8gZGVmYXVsdCBmaWx0ZXIgZm9yIGQzLXpvb21cbiAgICAgICAgcmV0dXJuICghZXZlbnQuY3RybEtleSB8fCBldmVudC50eXBlID09PSAnd2hlZWwnKSAmJiBidXR0b25BbGxvd2VkO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIFhZUGFuWm9vbSh7IGRvbU5vZGUsIG1pblpvb20sIG1heFpvb20sIHBhbmVDbGlja0Rpc3RhbmNlLCB0cmFuc2xhdGVFeHRlbnQsIHZpZXdwb3J0LCBvblBhblpvb20sIG9uUGFuWm9vbVN0YXJ0LCBvblBhblpvb21FbmQsIG9uRHJhZ2dpbmdDaGFuZ2UsIH0pIHtcbiAgICBjb25zdCB6b29tUGFuVmFsdWVzID0ge1xuICAgICAgICBpc1pvb21pbmdPclBhbm5pbmc6IGZhbHNlLFxuICAgICAgICB1c2VkUmlnaHRNb3VzZUJ1dHRvbjogZmFsc2UsXG4gICAgICAgIHByZXZWaWV3cG9ydDogeyB4OiAwLCB5OiAwLCB6b29tOiAwIH0sXG4gICAgICAgIG1vdXNlQnV0dG9uOiAwLFxuICAgICAgICB0aW1lcklkOiB1bmRlZmluZWQsXG4gICAgICAgIHBhblNjcm9sbFRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNQYW5TY3JvbGxpbmc6IGZhbHNlLFxuICAgIH07XG4gICAgY29uc3QgYmJveCA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZDNab29tSW5zdGFuY2UgPSB6b29tKClcbiAgICAgICAgLmNsaWNrRGlzdGFuY2UoIWlzTnVtZXJpYyhwYW5lQ2xpY2tEaXN0YW5jZSkgfHwgcGFuZUNsaWNrRGlzdGFuY2UgPCAwID8gMCA6IHBhbmVDbGlja0Rpc3RhbmNlKVxuICAgICAgICAuc2NhbGVFeHRlbnQoW21pblpvb20sIG1heFpvb21dKVxuICAgICAgICAudHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgY29uc3QgZDNTZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSkuY2FsbChkM1pvb21JbnN0YW5jZSk7XG4gICAgc2V0Vmlld3BvcnRDb25zdHJhaW5lZCh7XG4gICAgICAgIHg6IHZpZXdwb3J0LngsXG4gICAgICAgIHk6IHZpZXdwb3J0LnksXG4gICAgICAgIHpvb206IGNsYW1wKHZpZXdwb3J0Lnpvb20sIG1pblpvb20sIG1heFpvb20pLFxuICAgIH0sIFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbYmJveC53aWR0aCwgYmJveC5oZWlnaHRdLFxuICAgIF0sIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgY29uc3QgZDNab29tSGFuZGxlciA9IGQzU2VsZWN0aW9uLm9uKCd3aGVlbC56b29tJyk7XG4gICAgY29uc3QgZDNEYmxDbGlja1pvb21IYW5kbGVyID0gZDNTZWxlY3Rpb24ub24oJ2RibGNsaWNrLnpvb20nKTtcbiAgICBkM1pvb21JbnN0YW5jZS53aGVlbERlbHRhKHdoZWVsRGVsdGEpO1xuICAgIGZ1bmN0aW9uIHNldFRyYW5zZm9ybSh0cmFuc2Zvcm0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8udHJhbnNmb3JtKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24sICgpID0+IHJlc29sdmUodHJ1ZSkpLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIC8vIHB1YmxpYyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgb25QYW5lQ29udGV4dE1lbnUsIHVzZXJTZWxlY3Rpb25BY3RpdmUsIHBhbk9uU2Nyb2xsLCBwYW5PbkRyYWcsIHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25TY3JvbGxTcGVlZCwgcHJldmVudFNjcm9sbGluZywgem9vbU9uUGluY2gsIHpvb21PblNjcm9sbCwgem9vbU9uRG91YmxlQ2xpY2ssIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCwgbGliLCBvblRyYW5zZm9ybUNoYW5nZSwgfSkge1xuICAgICAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSAmJiAhem9vbVBhblZhbHVlcy5pc1pvb21pbmdPclBhbm5pbmcpIHtcbiAgICAgICAgICAgIGRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1Bhbk9uU2Nyb2xsID0gcGFuT25TY3JvbGwgJiYgIXpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCAmJiAhdXNlclNlbGVjdGlvbkFjdGl2ZTtcbiAgICAgICAgY29uc3Qgd2hlZWxIYW5kbGVyID0gaXNQYW5PblNjcm9sbFxuICAgICAgICAgICAgPyBjcmVhdGVQYW5PblNjcm9sbEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBkM1NlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBkM1pvb206IGQzWm9vbUluc3RhbmNlLFxuICAgICAgICAgICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgICAgICAgICBwYW5PblNjcm9sbFNwZWVkLFxuICAgICAgICAgICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBjcmVhdGVab29tT25TY3JvbGxIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHByZXZlbnRTY3JvbGxpbmcsXG4gICAgICAgICAgICAgICAgZDNab29tSGFuZGxlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBkM1NlbGVjdGlvbi5vbignd2hlZWwuem9vbScsIHdoZWVsSGFuZGxlciwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgaWYgKCF1c2VyU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICAvLyBwYW4gem9vbSBzdGFydFxuICAgICAgICAgICAgY29uc3Qgc3RhcnRIYW5kbGVyID0gY3JlYXRlUGFuWm9vbVN0YXJ0SGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignc3RhcnQnLCBzdGFydEhhbmRsZXIpO1xuICAgICAgICAgICAgLy8gcGFuIHpvb21cbiAgICAgICAgICAgIGNvbnN0IHBhblpvb21IYW5kbGVyID0gY3JlYXRlUGFuWm9vbUhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgICAgIG9uUGFuZUNvbnRleHRNZW51OiAhIW9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbSxcbiAgICAgICAgICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZDNab29tSW5zdGFuY2Uub24oJ3pvb20nLCBwYW5ab29tSGFuZGxlcik7XG4gICAgICAgICAgICAvLyBwYW4gem9vbSBlbmRcbiAgICAgICAgICAgIGNvbnN0IHBhblpvb21FbmRIYW5kbGVyID0gY3JlYXRlUGFuWm9vbUVuZEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgICAgIG9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZCxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignZW5kJywgcGFuWm9vbUVuZEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IGNyZWF0ZUZpbHRlcih7XG4gICAgICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgICAgIHpvb21PbkRvdWJsZUNsaWNrLFxuICAgICAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICB9KTtcbiAgICAgICAgZDNab29tSW5zdGFuY2UuZmlsdGVyKGZpbHRlcik7XG4gICAgICAgIC8vIFdlIGNhbm5vdCBhZGQgem9vbU9uRG91YmxlQ2xpY2sgdG8gdGhlIGZpbHRlciBhYm92ZSBiZWNhdXNlXG4gICAgICAgIC8vIGRvdWJsZSB0YXBwaW5nIG9uIHRvdWNoIHNjcmVlbnMgY2lyY3VtdmVudHMgdGhlIGZpbHRlciBhbmRcbiAgICAgICAgLy8gZGJsY2xpY2suem9vbSBpcyBmaXJlZCBvbiB0aGUgc2VsZWN0aW9uIGRpcmVjdGx5XG4gICAgICAgIGlmICh6b29tT25Eb3VibGVDbGljaykge1xuICAgICAgICAgICAgZDNTZWxlY3Rpb24ub24oJ2RibGNsaWNrLnpvb20nLCBkM0RibENsaWNrWm9vbUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZDNTZWxlY3Rpb24ub24oJ2RibGNsaWNrLnpvb20nLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignem9vbScsIG51bGwpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzZXRWaWV3cG9ydENvbnN0cmFpbmVkKHZpZXdwb3J0LCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkge1xuICAgICAgICBjb25zdCBuZXh0VHJhbnNmb3JtID0gdmlld3BvcnRUb1RyYW5zZm9ybSh2aWV3cG9ydCk7XG4gICAgICAgIGNvbnN0IGNvbnRyYWluZWRUcmFuc2Zvcm0gPSBkM1pvb21JbnN0YW5jZT8uY29uc3RyYWluKCkobmV4dFRyYW5zZm9ybSwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgICAgICBpZiAoY29udHJhaW5lZFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgYXdhaXQgc2V0VHJhbnNmb3JtKGNvbnRyYWluZWRUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZShjb250cmFpbmVkVHJhbnNmb3JtKSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNldFZpZXdwb3J0KHZpZXdwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB2aWV3cG9ydFRvVHJhbnNmb3JtKHZpZXdwb3J0KTtcbiAgICAgICAgYXdhaXQgc2V0VHJhbnNmb3JtKG5leHRUcmFuc2Zvcm0sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUobmV4dFRyYW5zZm9ybSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzeW5jVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VHJhbnNmb3JtID0gdmlld3BvcnRUb1RyYW5zZm9ybSh2aWV3cG9ydCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gZDNTZWxlY3Rpb24ucHJvcGVydHkoJ19fem9vbScpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0uayAhPT0gdmlld3BvcnQuem9vbSB8fFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0ueCAhPT0gdmlld3BvcnQueCB8fFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0ueSAhPT0gdmlld3BvcnQueSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LnRyYW5zZm9ybShkM1NlbGVjdGlvbiwgbmV4dFRyYW5zZm9ybSwgbnVsbCwgeyBzeW5jOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFZpZXdwb3J0KCkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBkM1NlbGVjdGlvbiA/IHpvb21UcmFuc2Zvcm0oZDNTZWxlY3Rpb24ubm9kZSgpKSA6IHsgeDogMCwgeTogMCwgazogMSB9O1xuICAgICAgICByZXR1cm4geyB4OiB0cmFuc2Zvcm0ueCwgeTogdHJhbnNmb3JtLnksIHpvb206IHRyYW5zZm9ybS5rIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlVG8oem9vbSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlPy5zY2FsZVRvKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24sICgpID0+IHJlc29sdmUodHJ1ZSkpLCB6b29tKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZUJ5KGZhY3Rvciwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlPy5zY2FsZUJ5KGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24sICgpID0+IHJlc29sdmUodHJ1ZSkpLCBmYWN0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFNjYWxlRXh0ZW50KHNjYWxlRXh0ZW50KSB7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlPy5zY2FsZUV4dGVudChzY2FsZUV4dGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0ZUV4dGVudCh0cmFuc2xhdGVFeHRlbnQpIHtcbiAgICAgICAgZDNab29tSW5zdGFuY2U/LnRyYW5zbGF0ZUV4dGVudCh0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRDbGlja0Rpc3RhbmNlKGRpc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkRGlzdGFuY2UgPSAhaXNOdW1lcmljKGRpc3RhbmNlKSB8fCBkaXN0YW5jZSA8IDAgPyAwIDogZGlzdGFuY2U7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlPy5jbGlja0Rpc3RhbmNlKHZhbGlkRGlzdGFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUsXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgICAgIHNldFZpZXdwb3J0LFxuICAgICAgICBzZXRWaWV3cG9ydENvbnN0cmFpbmVkLFxuICAgICAgICBnZXRWaWV3cG9ydCxcbiAgICAgICAgc2NhbGVUbyxcbiAgICAgICAgc2NhbGVCeSxcbiAgICAgICAgc2V0U2NhbGVFeHRlbnQsXG4gICAgICAgIHNldFRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgc3luY1ZpZXdwb3J0LFxuICAgICAgICBzZXRDbGlja0Rpc3RhbmNlLFxuICAgIH07XG59XG5cbnZhciBSZXNpemVDb250cm9sVmFyaWFudDtcbihmdW5jdGlvbiAoUmVzaXplQ29udHJvbFZhcmlhbnQpIHtcbiAgICBSZXNpemVDb250cm9sVmFyaWFudFtcIkxpbmVcIl0gPSBcImxpbmVcIjtcbiAgICBSZXNpemVDb250cm9sVmFyaWFudFtcIkhhbmRsZVwiXSA9IFwiaGFuZGxlXCI7XG59KShSZXNpemVDb250cm9sVmFyaWFudCB8fCAoUmVzaXplQ29udHJvbFZhcmlhbnQgPSB7fSkpO1xuY29uc3QgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TID0gWyd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLCAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0J107XG5jb25zdCBYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcblxuLyoqXG4gKiBHZXQgYWxsIGNvbm5lY3RpbmcgZWRnZXMgZm9yIGEgZ2l2ZW4gc2V0IG9mIG5vZGVzXG4gKiBAcGFyYW0gd2lkdGggLSBuZXcgd2lkdGggb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBwcmV2V2lkdGggLSBwcmV2aW91cyB3aWR0aCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIGhlaWdodCAtIG5ldyBoZWlnaHQgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBwcmV2SGVpZ2h0IC0gcHJldmlvdXMgaGVpZ2h0IG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gYWZmZWN0c1ggLSB3aGV0aGVyIHRvIGludmVydCB0aGUgcmVzaXplIGRpcmVjdGlvbiBmb3IgdGhlIHggYXhpc1xuICogQHBhcmFtIGFmZmVjdHNZIC0gd2hldGhlciB0byBpbnZlcnQgdGhlIHJlc2l6ZSBkaXJlY3Rpb24gZm9yIHRoZSB5IGF4aXNcbiAqIEByZXR1cm5zIGFycmF5IG9mIHR3byBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSByZXNpemUgZm9yIGVhY2ggYXhpcywgMCA9IG5vIGNoYW5nZSwgMSA9IGluY3JlYXNlLCAtMSA9IGRlY3JlYXNlXG4gKi9cbmZ1bmN0aW9uIGdldFJlc2l6ZURpcmVjdGlvbih7IHdpZHRoLCBwcmV2V2lkdGgsIGhlaWdodCwgcHJldkhlaWdodCwgYWZmZWN0c1gsIGFmZmVjdHNZLCB9KSB7XG4gICAgY29uc3QgZGVsdGFXaWR0aCA9IHdpZHRoIC0gcHJldldpZHRoO1xuICAgIGNvbnN0IGRlbHRhSGVpZ2h0ID0gaGVpZ2h0IC0gcHJldkhlaWdodDtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBbZGVsdGFXaWR0aCA+IDAgPyAxIDogZGVsdGFXaWR0aCA8IDAgPyAtMSA6IDAsIGRlbHRhSGVpZ2h0ID4gMCA/IDEgOiBkZWx0YUhlaWdodCA8IDAgPyAtMSA6IDBdO1xuICAgIGlmIChkZWx0YVdpZHRoICYmIGFmZmVjdHNYKSB7XG4gICAgICAgIGRpcmVjdGlvblswXSA9IGRpcmVjdGlvblswXSAqIC0xO1xuICAgIH1cbiAgICBpZiAoZGVsdGFIZWlnaHQgJiYgYWZmZWN0c1kpIHtcbiAgICAgICAgZGlyZWN0aW9uWzFdID0gZGlyZWN0aW9uWzFdICogLTE7XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rpb247XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgY29udHJvbCBwb3NpdGlvbiB0aGF0IGlzIGJlaW5nIGRyYWdnZWQgdG8gZGltZW5zaW9ucyB0aGF0IGFyZSBiZWluZyByZXNpemVkXG4gKiBAcGFyYW0gY29udHJvbFBvc2l0aW9uIC0gcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgdGhhdCBpcyBiZWluZyBkcmFnZ2VkXG4gKiBAcmV0dXJucyBpc0hvcml6b250YWwsIGlzVmVydGljYWwsIGFmZmVjdHNYLCBhZmZlY3RzWSxcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udHJvbERpcmVjdGlvbihjb250cm9sUG9zaXRpb24pIHtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ3JpZ2h0JykgfHwgY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdsZWZ0Jyk7XG4gICAgY29uc3QgaXNWZXJ0aWNhbCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygnYm90dG9tJykgfHwgY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCd0b3AnKTtcbiAgICBjb25zdCBhZmZlY3RzWCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygnbGVmdCcpO1xuICAgIGNvbnN0IGFmZmVjdHNZID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCd0b3AnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0hvcml6b250YWwsXG4gICAgICAgIGlzVmVydGljYWwsXG4gICAgICAgIGFmZmVjdHNYLFxuICAgICAgICBhZmZlY3RzWSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJFeHRlbnRDbGFtcChsb3dlckV4dGVudCwgbG93ZXJCb3VuZCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBsb3dlckJvdW5kIC0gbG93ZXJFeHRlbnQpO1xufVxuZnVuY3Rpb24gZ2V0VXBwZXJFeHRlbnRDbGFtcCh1cHBlckV4dGVudCwgdXBwZXJCb3VuZCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCB1cHBlckV4dGVudCAtIHVwcGVyQm91bmQpO1xufVxuZnVuY3Rpb24gZ2V0U2l6ZUNsYW1wKHNpemUsIG1pblNpemUsIG1heFNpemUpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWluU2l6ZSAtIHNpemUsIHNpemUgLSBtYXhTaXplKTtcbn1cbmZ1bmN0aW9uIHhvcihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyAhYiA6IGI7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgbmV3IHdpZHRoICYgaGVpZ2h0IGFuZCB4ICYgeSBvZiBub2RlIGFmdGVyIHJlc2l6ZSBiYXNlZCBvbiBwb2ludGVyIHBvc2l0aW9uXG4gKiBAZGVzY3JpcHRpb24gLSBCdWNrbGUgdXAsIHRoaXMgaXMgYSBjaHVua3kgb25lLi4uIElmIHlvdSB3YW50IHRvIGRldGVybWluZSB0aGUgbmV3IGRpbWVuc2lvbnMgb2YgYSBub2RlIGFmdGVyIGEgcmVzaXplLFxuICogeW91IGhhdmUgdG8gYWNjb3VudCBmb3IgYWxsIHBvc3NpYmxlIHJlc3RyaWN0aW9uczogbWluL21heCB3aWR0aC9oZWlnaHQgb2YgdGhlIG5vZGUsIHRoZSBtYXhpbXVtIGV4dGVudCB0aGUgbm9kZSBpcyBhbGxvd2VkXG4gKiB0byBtb3ZlIGluIChpbiB0aGlzIGNhc2U6IHJlc2l6ZSBpbnRvKSBkZXRlcm1pbmVkIGJ5IHRoZSBwYXJlbnQgbm9kZSwgdGhlIG1pbmltYWwgZXh0ZW50IGRldGVybWluZWQgYnkgY2hpbGQgbm9kZXNcbiAqIHdpdGggZXhwYW5kUGFyZW50IG9yIGV4dGVudDogJ3BhcmVudCcgc2V0IGFuZCBvaCB5ZWFoLCB0aGVzZSB0aGluZ3MgYWxzbyBoYXZlIHRvIHdvcmsgd2l0aCBrZWVwQXNwZWN0UmF0aW8hXG4gKiBUaGUgd2F5IHRoaXMgaXMgZG9uZSBpcyBieSBkZXRlcm1pbmluZyBob3cgbXVjaCBlYWNoIG9mIHRoZXNlIHJlc3RyaWN0aW5nIGFjdHVhbGx5IHJlc3RyaWN0cyB0aGUgcmVzaXplIGFuZCB0aGVuIGFwcGx5aW5nIHRoZVxuICogc3Ryb25nZXN0IHJlc3RyaWN0aW9uLiBCZWNhdXNlIHRoZSByZXNpemUgYWZmZWN0cyB4LCB5IGFuZCB3aWR0aCwgaGVpZ2h0IGFuZCB3aWR0aCwgaGVpZ2h0IG9mIGEgb3Bwb3Npbmcgc2lkZSB3aXRoIGtlZXBBc3BlY3RSYXRpbyxcbiAqIHRoZSByZXNpemUgYW1vdW50IGlzIGFsd2F5cyBrZXB0IGluIGRpc3RYICYgZGlzdFkgYW1vdW50ICh0aGUgZGlzdGFuY2UgaW4gbW91c2UgbW92ZW1lbnQpXG4gKiBJbnN0ZWFkIG9mIGNsYW1waW5nIGVhY2ggdmFsdWUsIHdlIGZpcnN0IGNhbGN1bGF0ZSB0aGUgYmlnZ2VzdCAnY2xhbXAnIChmb3IgdGhlIGxhY2sgb2YgYSBiZXR0ZXIgbmFtZSkgYW5kIHRoZW4gYXBwbHkgaXQgdG8gYWxsIHZhbHVlcy5cbiAqIFRvIGNvbXBsaWNhdGUgdGhpbmdzIG5vZGVPcmlnaW4gaGFzIHRvIGJlIHRha2VuIGludG8gYWNjb3VudCBhcyB3ZWxsLiBUaGlzIGlzIGRvbmUgYnkgb2Zmc2V0dGluZyB0aGUgbm9kZXMgYXMgaWYgdGhlaXIgb3JpZ2luIGlzIFswLCAwXSxcbiAqIHRoZW4gY2FsY3VsYXRpbmcgdGhlIHJlc3RyaWN0aW9ucyBhcyB1c3VhbFxuICogQHBhcmFtIHN0YXJ0VmFsdWVzIC0gc3RhcnRpbmcgdmFsdWVzIG9mIHJlc2l6ZVxuICogQHBhcmFtIGNvbnRyb2xEaXJlY3Rpb24gLSBkaW1lbnNpb25zIGFmZmVjdGVkIGJ5IHRoZSByZXNpemVcbiAqIEBwYXJhbSBwb2ludGVyUG9zaXRpb24gLSB0aGUgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGNvcnJlY3RlZCBmb3Igc25hcHBpbmdcbiAqIEBwYXJhbSBib3VuZGFyaWVzIC0gbWluaW11bSBhbmQgbWF4aW11bSBkaW1lbnNpb25zIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0ga2VlcEFzcGVjdFJhdGlvIC0gcHJldmVudCBjaGFuZ2VzIG9mIGFzcHJlY3QgcmF0aW9cbiAqIEByZXR1cm5zIHgsIHksIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIG5vZGUgYWZ0ZXIgcmVzaXplXG4gKi9cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnNBZnRlclJlc2l6ZShzdGFydFZhbHVlcywgY29udHJvbERpcmVjdGlvbiwgcG9pbnRlclBvc2l0aW9uLCBib3VuZGFyaWVzLCBrZWVwQXNwZWN0UmF0aW8sIG5vZGVPcmlnaW4sIGV4dGVudCwgY2hpbGRFeHRlbnQpIHtcbiAgICBsZXQgeyBhZmZlY3RzWCwgYWZmZWN0c1kgfSA9IGNvbnRyb2xEaXJlY3Rpb247XG4gICAgY29uc3QgeyBpc0hvcml6b250YWwsIGlzVmVydGljYWwgfSA9IGNvbnRyb2xEaXJlY3Rpb247XG4gICAgY29uc3QgaXNEaWFnb25hbCA9IGlzSG9yaXpvbnRhbCAmJiBpc1ZlcnRpY2FsO1xuICAgIGNvbnN0IHsgeFNuYXBwZWQsIHlTbmFwcGVkIH0gPSBwb2ludGVyUG9zaXRpb247XG4gICAgY29uc3QgeyBtaW5XaWR0aCwgbWF4V2lkdGgsIG1pbkhlaWdodCwgbWF4SGVpZ2h0IH0gPSBib3VuZGFyaWVzO1xuICAgIGNvbnN0IHsgeDogc3RhcnRYLCB5OiBzdGFydFksIHdpZHRoOiBzdGFydFdpZHRoLCBoZWlnaHQ6IHN0YXJ0SGVpZ2h0LCBhc3BlY3RSYXRpbyB9ID0gc3RhcnRWYWx1ZXM7XG4gICAgbGV0IGRpc3RYID0gTWF0aC5mbG9vcihpc0hvcml6b250YWwgPyB4U25hcHBlZCAtIHN0YXJ0VmFsdWVzLnBvaW50ZXJYIDogMCk7XG4gICAgbGV0IGRpc3RZID0gTWF0aC5mbG9vcihpc1ZlcnRpY2FsID8geVNuYXBwZWQgLSBzdGFydFZhbHVlcy5wb2ludGVyWSA6IDApO1xuICAgIGNvbnN0IG5ld1dpZHRoID0gc3RhcnRXaWR0aCArIChhZmZlY3RzWCA/IC1kaXN0WCA6IGRpc3RYKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBzdGFydEhlaWdodCArIChhZmZlY3RzWSA/IC1kaXN0WSA6IGRpc3RZKTtcbiAgICBjb25zdCBvcmlnaW5PZmZzZXRYID0gLW5vZGVPcmlnaW5bMF0gKiBzdGFydFdpZHRoO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFkgPSAtbm9kZU9yaWdpblsxXSAqIHN0YXJ0SGVpZ2h0O1xuICAgIC8vIENoZWNrIGlmIG1heFdpZHRoLCBtaW5XV2lkdGgsIG1heEhlaWdodCwgbWluSGVpZ2h0IGFyZSByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgbGV0IGNsYW1wWCA9IGdldFNpemVDbGFtcChuZXdXaWR0aCwgbWluV2lkdGgsIG1heFdpZHRoKTtcbiAgICBsZXQgY2xhbXBZID0gZ2V0U2l6ZUNsYW1wKG5ld0hlaWdodCwgbWluSGVpZ2h0LCBtYXhIZWlnaHQpO1xuICAgIC8vIENoZWNrIGlmIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGV4dGVudCkge1xuICAgICAgICBsZXQgeEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgbGV0IHlFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgIGlmIChhZmZlY3RzWCAmJiBkaXN0WCA8IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgZGlzdFggKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMF1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWCAmJiBkaXN0WCA+IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3V2lkdGggKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMV1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZmZlY3RzWSAmJiBkaXN0WSA8IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRZICsgZGlzdFkgKyBvcmlnaW5PZmZzZXRZLCBleHRlbnRbMF1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWSAmJiBkaXN0WSA+IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgbmV3SGVpZ2h0ICsgb3JpZ2luT2Zmc2V0WSwgZXh0ZW50WzFdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIHhFeHRlbnRDbGFtcCk7XG4gICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgeUV4dGVudENsYW1wKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgIGxldCB4RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBsZXQgeUV4dGVudENsYW1wID0gMDtcbiAgICAgICAgaWYgKGFmZmVjdHNYICYmIGRpc3RYID4gMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBkaXN0WCwgY2hpbGRFeHRlbnRbMF1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWCAmJiBkaXN0WCA8IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3V2lkdGgsIGNoaWxkRXh0ZW50WzFdWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZmZWN0c1kgJiYgZGlzdFkgPiAwKSB7XG4gICAgICAgICAgICB5RXh0ZW50Q2xhbXAgPSBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WSArIGRpc3RZLCBjaGlsZEV4dGVudFswXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNZICYmIGRpc3RZIDwgMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdIZWlnaHQsIGNoaWxkRXh0ZW50WzFdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIHhFeHRlbnRDbGFtcCk7XG4gICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgeUV4dGVudENsYW1wKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGFzcGVjdCByYXRpbyByZXNpemluZyBvZiB0aGUgb3RoZXIgc2lkZSBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgaWYgKGtlZXBBc3BlY3RSYXRpbykge1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbWF4IGRpbWVuc2lvbnMgbWlnaHQgYmUgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgY29uc3QgYXNwZWN0SGVpZ2h0Q2xhbXAgPSBnZXRTaXplQ2xhbXAobmV3V2lkdGggLyBhc3BlY3RSYXRpbywgbWluSGVpZ2h0LCBtYXhIZWlnaHQpICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEhlaWdodENsYW1wKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBleHRlbnQgaXMgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgaWYgKGV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1ggJiYgIWFmZmVjdHNZICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgb3JpZ2luT2Zmc2V0WSArIG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8sIGV4dGVudFsxXVsxXSkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRZICsgb3JpZ2luT2Zmc2V0WSArIChhZmZlY3RzWCA/IGRpc3RYIDogLWRpc3RYKSAvIGFzcGVjdFJhdGlvLCBleHRlbnRbMF1bMV0pICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBYID0gTWF0aC5tYXgoY2xhbXBYLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2hpbGQgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICAgICAgICAgIGlmIChjaGlsZEV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1ggJiYgIWFmZmVjdHNZICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdXaWR0aCAvIGFzcGVjdFJhdGlvLCBjaGlsZEV4dGVudFsxXVsxXSkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgKGFmZmVjdHNYID8gZGlzdFggOiAtZGlzdFgpIC8gYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzBdWzFdKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB0aGUgc2FtZSB0aGluZyBmb3IgdmVydGljYWwgcmVzaXppbmdcbiAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzcGVjdFdpZHRoQ2xhbXAgPSBnZXRTaXplQ2xhbXAobmV3SGVpZ2h0ICogYXNwZWN0UmF0aW8sIG1pbldpZHRoLCBtYXhXaWR0aCkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgYXNwZWN0V2lkdGhDbGFtcCk7XG4gICAgICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWSAmJiAhYWZmZWN0c1ggJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbyArIG9yaWdpbk9mZnNldFgsIGV4dGVudFsxXVswXSkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgKGFmZmVjdHNZID8gZGlzdFkgOiAtZGlzdFkpICogYXNwZWN0UmF0aW8gKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMF1bMF0pIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXNwZWN0RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmICgoIWFmZmVjdHNYICYmICFhZmZlY3RzWSkgfHwgKGFmZmVjdHNZICYmICFhZmZlY3RzWCAmJiBpc0RpYWdvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3SGVpZ2h0ICogYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzFdWzBdKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyAoYWZmZWN0c1kgPyBkaXN0WSA6IC1kaXN0WSkgKiBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMF1bMF0pIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgYXNwZWN0RXh0ZW50Q2xhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3RZID0gZGlzdFkgKyAoZGlzdFkgPCAwID8gY2xhbXBZIDogLWNsYW1wWSk7XG4gICAgZGlzdFggPSBkaXN0WCArIChkaXN0WCA8IDAgPyBjbGFtcFggOiAtY2xhbXBYKTtcbiAgICBpZiAoa2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICAgIGlmIChpc0RpYWdvbmFsKSB7XG4gICAgICAgICAgICBpZiAobmV3V2lkdGggPiBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIGRpc3RZID0gKHhvcihhZmZlY3RzWCwgYWZmZWN0c1kpID8gLWRpc3RYIDogZGlzdFgpIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXN0WCA9ICh4b3IoYWZmZWN0c1gsIGFmZmVjdHNZKSA/IC1kaXN0WSA6IGRpc3RZKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGRpc3RZID0gZGlzdFggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICBhZmZlY3RzWSA9IGFmZmVjdHNYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzdFggPSBkaXN0WSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIGFmZmVjdHNYID0gYWZmZWN0c1k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeCA9IGFmZmVjdHNYID8gc3RhcnRYICsgZGlzdFggOiBzdGFydFg7XG4gICAgY29uc3QgeSA9IGFmZmVjdHNZID8gc3RhcnRZICsgZGlzdFkgOiBzdGFydFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHN0YXJ0V2lkdGggKyAoYWZmZWN0c1ggPyAtZGlzdFggOiBkaXN0WCksXG4gICAgICAgIGhlaWdodDogc3RhcnRIZWlnaHQgKyAoYWZmZWN0c1kgPyAtZGlzdFkgOiBkaXN0WSksXG4gICAgICAgIHg6IG5vZGVPcmlnaW5bMF0gKiBkaXN0WCAqICghYWZmZWN0c1ggPyAxIDogLTEpICsgeCxcbiAgICAgICAgeTogbm9kZU9yaWdpblsxXSAqIGRpc3RZICogKCFhZmZlY3RzWSA/IDEgOiAtMSkgKyB5LFxuICAgIH07XG59XG5cbmNvbnN0IGluaXRQcmV2VmFsdWVzID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwLCB4OiAwLCB5OiAwIH07XG5jb25zdCBpbml0U3RhcnRWYWx1ZXMgPSB7XG4gICAgLi4uaW5pdFByZXZWYWx1ZXMsXG4gICAgcG9pbnRlclg6IDAsXG4gICAgcG9pbnRlclk6IDAsXG4gICAgYXNwZWN0UmF0aW86IDEsXG59O1xuZnVuY3Rpb24gbm9kZVRvUGFyZW50RXh0ZW50KG5vZGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFtub2RlLm1lYXN1cmVkLndpZHRoLCBub2RlLm1lYXN1cmVkLmhlaWdodF0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG5vZGVUb0NoaWxkRXh0ZW50KGNoaWxkLCBwYXJlbnQsIG5vZGVPcmlnaW4pIHtcbiAgICBjb25zdCB4ID0gcGFyZW50LnBvc2l0aW9uLnggKyBjaGlsZC5wb3NpdGlvbi54O1xuICAgIGNvbnN0IHkgPSBwYXJlbnQucG9zaXRpb24ueSArIGNoaWxkLnBvc2l0aW9uLnk7XG4gICAgY29uc3Qgd2lkdGggPSBjaGlsZC5tZWFzdXJlZC53aWR0aCA/PyAwO1xuICAgIGNvbnN0IGhlaWdodCA9IGNoaWxkLm1lYXN1cmVkLmhlaWdodCA/PyAwO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFggPSBub2RlT3JpZ2luWzBdICogd2lkdGg7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WSA9IG5vZGVPcmlnaW5bMV0gKiBoZWlnaHQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgW3ggLSBvcmlnaW5PZmZzZXRYLCB5IC0gb3JpZ2luT2Zmc2V0WV0sXG4gICAgICAgIFt4ICsgd2lkdGggLSBvcmlnaW5PZmZzZXRYLCB5ICsgaGVpZ2h0IC0gb3JpZ2luT2Zmc2V0WV0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIFhZUmVzaXplcih7IGRvbU5vZGUsIG5vZGVJZCwgZ2V0U3RvcmVJdGVtcywgb25DaGFuZ2UsIG9uRW5kIH0pIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSk7XG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgY29udHJvbFBvc2l0aW9uLCBib3VuZGFyaWVzLCBrZWVwQXNwZWN0UmF0aW8sIG9uUmVzaXplU3RhcnQsIG9uUmVzaXplLCBvblJlc2l6ZUVuZCwgc2hvdWxkUmVzaXplLCB9KSB7XG4gICAgICAgIGxldCBwcmV2VmFsdWVzID0geyAuLi5pbml0UHJldlZhbHVlcyB9O1xuICAgICAgICBsZXQgc3RhcnRWYWx1ZXMgPSB7IC4uLmluaXRTdGFydFZhbHVlcyB9O1xuICAgICAgICBjb25zdCBjb250cm9sRGlyZWN0aW9uID0gZ2V0Q29udHJvbERpcmVjdGlvbihjb250cm9sUG9zaXRpb24pO1xuICAgICAgICBsZXQgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNvbnRhaW5lckJvdW5kcyA9IG51bGw7XG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gW107XG4gICAgICAgIGxldCBwYXJlbnROb2RlID0gdW5kZWZpbmVkOyAvLyBOZWVkZWQgdG8gZml4IGV4cGFuZFBhcmVudFxuICAgICAgICBsZXQgcGFyZW50RXh0ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY2hpbGRFeHRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGRyYWdIYW5kbGVyID0gZHJhZygpXG4gICAgICAgICAgICAub24oJ3N0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVPcmlnaW4sIHBhbmVEb21Ob2RlIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kcyA9IHBhbmVEb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA/PyBudWxsO1xuICAgICAgICAgICAgY29uc3QgeyB4U25hcHBlZCwgeVNuYXBwZWQgfSA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICBzbmFwVG9HcmlkLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJldlZhbHVlcyA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogbm9kZS5tZWFzdXJlZC53aWR0aCA/PyAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbm9kZS5tZWFzdXJlZC5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICB4OiBub2RlLnBvc2l0aW9uLnggPz8gMCxcbiAgICAgICAgICAgICAgICB5OiBub2RlLnBvc2l0aW9uLnkgPz8gMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdGFydFZhbHVlcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2VmFsdWVzLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJYOiB4U25hcHBlZCxcbiAgICAgICAgICAgICAgICBwb2ludGVyWTogeVNuYXBwZWQsXG4gICAgICAgICAgICAgICAgYXNwZWN0UmF0aW86IHByZXZWYWx1ZXMud2lkdGggLyBwcmV2VmFsdWVzLmhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYXJlbnROb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50SWQgJiYgKG5vZGUuZXh0ZW50ID09PSAncGFyZW50JyB8fCBub2RlLmV4cGFuZFBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCk7XG4gICAgICAgICAgICAgICAgcGFyZW50RXh0ZW50ID0gcGFyZW50Tm9kZSAmJiBub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcgPyBub2RlVG9QYXJlbnRFeHRlbnQocGFyZW50Tm9kZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb2xsZWN0IGFsbCBjaGlsZCBub2RlcyB0byBjb3JyZWN0IHRoZWlyIHJlbGF0aXZlIHBvc2l0aW9ucyB3aGVuIHRvcC9sZWZ0IGNoYW5nZXNcbiAgICAgICAgICAgIC8vIERldGVybWluZSBsYXJnZXN0IG1pbmltYWwgZXh0ZW50IHRoZSBwYXJlbnQgbm9kZSBpcyBhbGxvd2VkIHRvIHJlc2l6ZSB0b1xuICAgICAgICAgICAgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICAgICAgY2hpbGRFeHRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZElkLCBjaGlsZF0gb2Ygbm9kZUxvb2t1cCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnRJZCA9PT0gbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY2hpbGRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IC4uLmNoaWxkLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnQ6IGNoaWxkLmV4dGVudCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5leHRlbnQgPT09ICdwYXJlbnQnIHx8IGNoaWxkLmV4cGFuZFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gbm9kZVRvQ2hpbGRFeHRlbnQoY2hpbGQsIG5vZGUsIGNoaWxkLm9yaWdpbiA/PyBub2RlT3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEV4dGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbTWF0aC5taW4oZXh0ZW50WzBdWzBdLCBjaGlsZEV4dGVudFswXVswXSksIE1hdGgubWluKGV4dGVudFswXVsxXSwgY2hpbGRFeHRlbnRbMF1bMV0pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW01hdGgubWF4KGV4dGVudFsxXVswXSwgY2hpbGRFeHRlbnRbMV1bMF0pLCBNYXRoLm1heChleHRlbnRbMV1bMV0sIGNoaWxkRXh0ZW50WzFdWzFdKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRXh0ZW50ID0gZXh0ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25SZXNpemVTdGFydD8uKGV2ZW50LCB7IC4uLnByZXZWYWx1ZXMgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2RyYWcnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbjogc3RvcmVOb2RlT3JpZ2luIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zaXRpb24gPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgc25hcEdyaWQsXG4gICAgICAgICAgICAgICAgc25hcFRvR3JpZCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJCb3VuZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB4OiBwcmV2WCwgeTogcHJldlksIHdpZHRoOiBwcmV2V2lkdGgsIGhlaWdodDogcHJldkhlaWdodCB9ID0gcHJldlZhbHVlcztcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHt9O1xuICAgICAgICAgICAgY29uc3Qgbm9kZU9yaWdpbiA9IG5vZGUub3JpZ2luID8/IHN0b3JlTm9kZU9yaWdpbjtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgeCwgeSB9ID0gZ2V0RGltZW5zaW9uc0FmdGVyUmVzaXplKHN0YXJ0VmFsdWVzLCBjb250cm9sRGlyZWN0aW9uLCBwb2ludGVyUG9zaXRpb24sIGJvdW5kYXJpZXMsIGtlZXBBc3BlY3RSYXRpbywgbm9kZU9yaWdpbiwgcGFyZW50RXh0ZW50LCBjaGlsZEV4dGVudCk7XG4gICAgICAgICAgICBjb25zdCBpc1dpZHRoQ2hhbmdlID0gd2lkdGggIT09IHByZXZXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGlzSGVpZ2h0Q2hhbmdlID0gaGVpZ2h0ICE9PSBwcmV2SGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgaXNYUG9zQ2hhbmdlID0geCAhPT0gcHJldlggJiYgaXNXaWR0aENoYW5nZTtcbiAgICAgICAgICAgIGNvbnN0IGlzWVBvc0NoYW5nZSA9IHkgIT09IHByZXZZICYmIGlzSGVpZ2h0Q2hhbmdlO1xuICAgICAgICAgICAgaWYgKCFpc1hQb3NDaGFuZ2UgJiYgIWlzWVBvc0NoYW5nZSAmJiAhaXNXaWR0aENoYW5nZSAmJiAhaXNIZWlnaHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNYUG9zQ2hhbmdlIHx8IGlzWVBvc0NoYW5nZSB8fCBub2RlT3JpZ2luWzBdID09PSAxIHx8IG5vZGVPcmlnaW5bMV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2UueCA9IGlzWFBvc0NoYW5nZSA/IHggOiBwcmV2VmFsdWVzLng7XG4gICAgICAgICAgICAgICAgY2hhbmdlLnkgPSBpc1lQb3NDaGFuZ2UgPyB5IDogcHJldlZhbHVlcy55O1xuICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueCA9IGNoYW5nZS54O1xuICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueSA9IGNoYW5nZS55O1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gdG9wL2xlZnQgY2hhbmdlcywgY29ycmVjdCB0aGUgcmVsYXRpdmUgcG9zaXRpb25zIG9mIGNoaWxkIG5vZGVzXG4gICAgICAgICAgICAgICAgLy8gc28gdGhhdCB0aGV5IHN0YXkgaW4gdGhlIHNhbWUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhDaGFuZ2UgPSB4IC0gcHJldlg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHlDaGFuZ2UgPSB5IC0gcHJldlk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGROb2RlIG9mIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjaGlsZE5vZGUucG9zaXRpb24ueCAtIHhDaGFuZ2UgKyBub2RlT3JpZ2luWzBdICogKHdpZHRoIC0gcHJldldpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBjaGlsZE5vZGUucG9zaXRpb24ueSAtIHlDaGFuZ2UgKyBub2RlT3JpZ2luWzFdICogKGhlaWdodCAtIHByZXZIZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkQ2hhbmdlcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNXaWR0aENoYW5nZSB8fCBpc0hlaWdodENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZS53aWR0aCA9IGlzV2lkdGhDaGFuZ2UgPyB3aWR0aCA6IHByZXZWYWx1ZXMud2lkdGg7XG4gICAgICAgICAgICAgICAgY2hhbmdlLmhlaWdodCA9IGlzSGVpZ2h0Q2hhbmdlID8gaGVpZ2h0IDogcHJldlZhbHVlcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy53aWR0aCA9IGNoYW5nZS53aWR0aDtcbiAgICAgICAgICAgICAgICBwcmV2VmFsdWVzLmhlaWdodCA9IGNoYW5nZS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXggZXhwYW5kUGFyZW50IHdoZW4gcmVzaXppbmcgZnJvbSB0b3AvbGVmdFxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgbm9kZS5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4TGltaXQgPSBub2RlT3JpZ2luWzBdICogKGNoYW5nZS53aWR0aCA/PyAwKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnggJiYgY2hhbmdlLnggPCB4TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlZhbHVlcy54ID0geExpbWl0O1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlcy54ID0gc3RhcnRWYWx1ZXMueCAtIChjaGFuZ2UueCAtIHhMaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHlMaW1pdCA9IG5vZGVPcmlnaW5bMV0gKiAoY2hhbmdlLmhlaWdodCA/PyAwKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnkgJiYgY2hhbmdlLnkgPCB5TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlZhbHVlcy55ID0geUxpbWl0O1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlcy55ID0gc3RhcnRWYWx1ZXMueSAtIChjaGFuZ2UueSAtIHlMaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gZ2V0UmVzaXplRGlyZWN0aW9uKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcHJldlZhbHVlcy53aWR0aCxcbiAgICAgICAgICAgICAgICBwcmV2V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwcmV2VmFsdWVzLmhlaWdodCxcbiAgICAgICAgICAgICAgICBwcmV2SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGFmZmVjdHNYOiBjb250cm9sRGlyZWN0aW9uLmFmZmVjdHNYLFxuICAgICAgICAgICAgICAgIGFmZmVjdHNZOiBjb250cm9sRGlyZWN0aW9uLmFmZmVjdHNZLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0VmFsdWVzID0geyAuLi5wcmV2VmFsdWVzLCBkaXJlY3Rpb24gfTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxSZXNpemUgPSBzaG91bGRSZXNpemU/LihldmVudCwgbmV4dFZhbHVlcyk7XG4gICAgICAgICAgICBpZiAoY2FsbFJlc2l6ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblJlc2l6ZT8uKGV2ZW50LCBuZXh0VmFsdWVzKTtcbiAgICAgICAgICAgIG9uQ2hhbmdlKGNoYW5nZSwgY2hpbGRDaGFuZ2VzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvblJlc2l6ZUVuZD8uKGV2ZW50LCB7IC4uLnByZXZWYWx1ZXMgfSk7XG4gICAgICAgICAgICBvbkVuZD8uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxlY3Rpb24uY2FsbChkcmFnSGFuZGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHNlbGVjdGlvbi5vbignLmRyYWcnLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkZXN0cm95LFxuICAgIH07XG59XG5cbmV4cG9ydCB7IENvbm5lY3Rpb25MaW5lVHlwZSwgQ29ubmVjdGlvbk1vZGUsIE1hcmtlclR5cGUsIFBhbk9uU2Nyb2xsTW9kZSwgUG9zaXRpb24sIFJlc2l6ZUNvbnRyb2xWYXJpYW50LCBTZWxlY3Rpb25Nb2RlLCBYWURyYWcsIFhZSGFuZGxlLCBYWU1pbmltYXAsIFhZUGFuWm9vbSwgWFlSZXNpemVyLCBYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMsIFhZX1JFU0laRVJfTElORV9QT1NJVElPTlMsIGFkZEVkZ2UsIGFkb3B0VXNlck5vZGVzLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsLCBhcmVTZXRzRXF1YWwsIGJveFRvUmVjdCwgY2FsY0F1dG9QYW4sIGNhbGN1bGF0ZU5vZGVQb3NpdGlvbiwgY2xhbXAsIGNsYW1wUG9zaXRpb24sIGNsYW1wUG9zaXRpb25Ub1BhcmVudCwgY3JlYXRlTWFya2VySWRzLCBkZXZXYXJuLCBlbGVtZW50U2VsZWN0aW9uS2V5cywgZXJyb3JNZXNzYWdlcywgZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uLCBmaXRWaWV3LCBnZXRCZXppZXJFZGdlQ2VudGVyLCBnZXRCZXppZXJQYXRoLCBnZXRCb3VuZHNPZkJveGVzLCBnZXRCb3VuZHNPZlJlY3RzLCBnZXRDb25uZWN0ZWRFZGdlcywgZ2V0Q29ubmVjdGlvblN0YXR1cywgZ2V0RGltZW5zaW9ucywgZ2V0RWRnZUNlbnRlciwgZ2V0RWRnZVBvc2l0aW9uLCBnZXRFbGVtZW50c1RvUmVtb3ZlLCBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgsIGdldEV2ZW50UG9zaXRpb24sIGdldEZpdFZpZXdOb2RlcywgZ2V0SGFuZGxlQm91bmRzLCBnZXRIYW5kbGVQb3NpdGlvbiwgZ2V0SG9zdEZvckVsZW1lbnQsIGdldEluY29tZXJzLCBnZXRJbnRlcm5hbE5vZGVzQm91bmRzLCBnZXRNYXJrZXJJZCwgZ2V0Tm9kZURpbWVuc2lvbnMsIGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4sIGdldE5vZGVUb29sYmFyVHJhbnNmb3JtLCBnZXROb2Rlc0JvdW5kcywgZ2V0Tm9kZXNJbnNpZGUsIGdldE91dGdvZXJzLCBnZXRPdmVybGFwcGluZ0FyZWEsIGdldFBvaW50ZXJQb3NpdGlvbiwgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UsIGhhbmRsZUV4cGFuZFBhcmVudCwgaW5maW5pdGVFeHRlbnQsIGluaXRpYWxDb25uZWN0aW9uLCBpc0Nvb3JkaW5hdGVFeHRlbnQsIGlzRWRnZUJhc2UsIGlzRWRnZVZpc2libGUsIGlzSW5wdXRET01Ob2RlLCBpc0ludGVybmFsTm9kZUJhc2UsIGlzTWFjT3MsIGlzTW91c2VFdmVudCwgaXNOb2RlQmFzZSwgaXNOdW1lcmljLCBpc1JlY3RPYmplY3QsIG5vZGVIYXNEaW1lbnNpb25zLCBub2RlVG9Cb3gsIG5vZGVUb1JlY3QsIG9wcG9zaXRlUG9zaXRpb24sIHBhbkJ5LCBwb2ludFRvUmVuZGVyZXJQb2ludCwgcmVjb25uZWN0RWRnZSwgcmVjdFRvQm94LCByZW5kZXJlclBvaW50VG9Qb2ludCwgc2hhbGxvd05vZGVEYXRhLCBzbmFwUG9zaXRpb24sIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zLCB1cGRhdGVDb25uZWN0aW9uTG9va3VwLCB1cGRhdGVOb2RlSW50ZXJuYWxzIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/react/dist/style.css":
/*!***************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/style.css ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"869ef40efae5\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxEaGFybWVzaCByYWlrd2FyXFxEZXNrdG9wXFxPc2ludEFzc2lnbm1lbnRcXGFzc2lnbm1lbnRcXEZyb250ZW5kXFxub2RlX21vZHVsZXNcXEB4eWZsb3dcXHJlYWN0XFxkaXN0XFxzdHlsZS5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI4NjllZjQwZWZhZTVcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/style.css\n");

/***/ })

};
;